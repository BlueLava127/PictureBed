# JavaSE

## Java基础

### Java命名规范

1. 类：开头字母大写，其余单词首字母大写
2. 方法：第一个单词开头小写，后面单词开头大写
3. 常量名：全大写，用下划线分割
4. 区别接口类和实现类：在接口实现类后加Imp
5. 包：一律小写

### Java数据类型

1. 引用数据类型：数组、类、接口、注解、枚举
2. 基本数据类型：整数型、浮点型、字符型、布尔型

### 基本数据类型

| 整数型：               |                       | 取值范围                                 | 默认值   |
| ---------------------- | --------------------- | ---------------------------------------- | -------- |
| byte                   | 占用内存1个字节(8位)  | [-128,127]                               | 0        |
| short（短整型）        | 占用内存2个字节(16位) | -32768~32767                             | 0        |
| int（默认整型）        | 占用内存4个字节(32位) | -2147483648~2147483647                   | 0        |
| long（长整型）         | 占用内存8个字节(64位) | -9223372036854775808~9223372036854775807 | 0        |
| **浮点型**             |                       |                                          |          |
| float（单精度浮点数）  | 占用内存4个字节       | -3.40E+38 ~ +3.40E+38                    | 0.0      |
| double（双精度浮点数） | 占用内存8个字节       | -1.79E+308 ~ +1.79E+308                  | 0.0      |
| **布尔型**             |                       |                                          |          |
| boolean                |                       | true、false                              | false    |
| **字符型**             |                       |                                          |          |
| char                   | 只能存储单个值        | ''                                       | 空白字符 |

**引用类型数组默认值为null**

![强转](https://java-laplace.oss-cn-shanghai.aliyuncs.com/img/%E5%BC%BA%E8%BD%AC.png)

### 位运算符

> &	|	^	~ 	>>	>>>	<<

+ &（与运算符）：有0则0
+ |（或运算符）：有1则1
+ ^（位异或运算符）：相同为0，不同为1
+ ~（按位取反运算符）：按位取反
+ \>>（右位移运算符）：将运算符左边的对象向右移动运算符右边指定的位数。使用符号扩展机制，也就是说，如果值为正，则在高位补0，如果值为负，则在高位补1。低位溢出，符号位不变，并用符号位补溢出的高位
+ \>>>（无符号右位移运算符）：将运算符左边的对象向右移动运算符右边指定的位数。采用0扩展机制，也就是说，无论值的正负，都在高位补0
+ \<<（左位移运算符）：将运算符左边的对象向左移动运算符右边指定的位数（在低位补0）

**应用场景：**

1. 判断奇偶

2. 判断一个正整数是不是2的整数次幂

	```
	(n&(n-1))==0
	```

### 进制

1. 二进制：二进制数的书写通常在数的右下方注上基数2、或加前缀0b，或在后面加B表示，其中B是英文二进制Binary的首字母。
2. 八进制：八进制用下标8、或加前缀0，或数据后面加O表示，其中O是英文八进制Octal的首字母O
3. 十进制：对于十进制数可以不加标注，或加后缀D，其中D是英文十进制Decimal的首字母D
4. 十六进制：对于十六进制加前缀0x，或加后缀H，其中H是英文十六进制Hexadecimal的首字母H

### 强类型语言

​	Java是一种强类型语言，声明定义变量的过程中，数据类型很明确，每种类型都会有一个对应的关键字进行声明。

### Scanner类

```java
//	从键盘读入一个数据（整数、浮点、字符串...）
Scanner sc = new Scanner(System.in);//创建Scanner对象
int num = sc.nextInt();//将输入的信息返回到num
Sc.close()//关闭扫描器
//JDK1.5才出现，在此之前使用BufferedReader读取
BufferedReader br = new BufferedReader(new InputStreamReader(System.in))
```

### Random类

```java
//	得到一个随机的整数值
Random r = new Random();
int num = r.nextInt(100) + 1
```

### return

​	有返回值的方法必须在方法体的最后位置定义return关键字将数据返回给到程序

**作用:**

1. 将数据返回给方法的调用处
 	2. 结束当前方法

【**取余取模**】：

当x和y的正负相同时，取余和取模结果相同；

当x和y的正负不同时，取余结果的符号和x相同，取模结果的符号和y相同。（口诀：取余取头，取模取尾）

### JVM内存

1. 栈：存放方法。（局部变量）
2. 堆：new 出来的对象（垃圾回收器主要针对）（实例变量）
3. 方法区：类的信息、字节码信息、代码片段。（静态变量）
4. 本地方法区
5. 寄存器

### 形参参数和实际参数

#### 形参参数

在设计方法的过程中就需要明确形式参数,定义在小括号中，形参没有具体的数据,就是一块存储区域(变量)，存在的意义就是为了接受实际参数

#### 实际参数

在方法被调用的过程中明确实参数据，会被传入到小括号中，实参有具体数据,将实参传递给形参，之后方法体中参与运算的都是实际参数

【注意】：将实参传递给形参的过程，我们称为参数传递过程、现象

### 方法的重载

​	解决方法起名字难（冲突）的问题

【**满足方法重载的要求**】：

1. 必须定义在同一个类中
2. 方法名必须相同
3. 方法的形参列表必须不同（类型、位置、个数）

## 数组

​	在内存中开辟一组连续的空间区域，内部有多个小区域，有数据类型的限定，可以存入一组匹配类型的数据

### **静态初始化**

声明定义数组&创建数组对象并且为数组元素赋值同时进行

```
数据类型[] 数组名 = 数据类型[]{数据1，数据2，数据3}
int[] scores = {12,456,567,23}
```

### **动态初始化**

```
步骤一：声明定义数组&创建数组对象
	  数据类型[] 数组名 = new 数据类型[容量/长度]
步骤二：数组名配合下标/索引进行元素赋值的操作
	   数组名[下标] = 值；
	   String[] names = new String[4];
	   name[0] = "张三";
	   ...
```

### 数组的常用操作

遍历、最值、总和、平均值、复制、反转、排序、查找

### 数组执行过程中内存解析原理

【**堆内存**】：

+ new出来的对象都在堆内存中
+ 堆中的对象都有地址值
+ 堆中对象内部的区域空间都有默认值

【**注意**】：数组长度一旦确定就不可改变

### 数组拷贝

+ System.arraycopy(拷贝源数组，源起点，目标数组，目标数组起点，拷贝长度);

### 二维数组

**静态初始化**

```
数据类型[][] 数组名 = new 数据类型[][]{一维数组,二维数组...};
int[][] scores = new int[][]{{23,45,65},{34,54,65},...}
简化：
数据类型[][] 数组名 = 数据类型[][]{一维数组,二维数组...};
int[][] scores = int[][]{{23,45,65},{34,54,65},...}
```

**动态初始化**

```
一：//每个一维数组元素个数相同
数据类型[][] 数组名 = new 数据类型[行数/一维数组的个数][列数/每个一维数组中元素的个数]
数组名[行][列] = 值
二：//每个一元数组元素个数不同
//定义并创建二维数组对象
数据类型[][] 数组名 = new 数据类型[行数/一维数组的个数][]
//创建一维数组对象
数组名[行数] = new 数据类型[一维数组元素个数]
//为每个一维数组中每一个元素进行赋值操作
数组名[行数][列数] = 值；	
```

## 面向对象

### 属性

​	又称成员变量，属于类的成员之一

**作用**：用于描述某类事物的特征、特点。

```
1.数据类型 属性名 = 属性值；
2.数据类型 属性名；
```

### 类和对象的关系

**类：**对于多个对象进行共性内容的抽象描述就得到了类。类是抽象的、模糊的；可以看作是一个设计图，是创建对象的模板。

**对象：**对象是一个个实实在在的个体，在内存中占用空间区域；通过类的实例化而得到。

### 成员变量和局部变量的区别

```
1.定义位置：
	成员变量：定义在类的成员位置
	局部变量：定义在类的局部位置
2.内存中的位置：
	成员变量：在堆中
	局部变量：在栈中
3.默认值：
	成员变量：有默认值
	局部变量：没有默认值
4.作用范围：
	成员变量：可以在整个class中被使用
	局部变量：只能在方法内部被使用
5.生命周期：
	成员变量：随着对象在堆中的创建在堆中而开辟空间，随着对象被gc回收而清除内存
	局部变量：随着方法的进栈在栈中开辟空间，随着方法的出栈被回收
```

### 匿名对象

```
new 对象.属性/方法
```

**特点：**从创建完毕开始，只能被使用一次

## 封装

​	在外界如果直接让对象操作属性 ==> 对象名.属性名的形式为属性进行赋值操作可能出现数据不合理的情况（安全隐患），我们就没收外界对象名.属性名赋值的权利 ==> 私有化属性（private），需要在本类中提供一组公共（public）的访问方式供外界调用 ==>getter方法和setter方法

### getter&setter

getter方法作用：得到、获取属性值 ==>有返回值

setter方法作用：设置属性值 ==>没有返回值

```java
private double money;
public double getMoney(){
	return money;
}
public void setMoney(double m){
	money = m;
}
```

【**结论**】：在后期学习和开发环境下，属性都需要私有化，并且都要添加getter和setter方法，绝大多数情况：getter和setter方法的内部不用做合理性检验

## 构造方法

【**作用**】

- 创建对象都需要调用构造方法

- 为对象的属性进行赋值操作

	- 构造方法，又称构造函数、构造器，它是一种特殊的方法，它是一个与类同名的方法，没有返回值类型，甚至连void也没有。对象的创建就是通过构造方法来完成，其功能主要是完成对象的初始化。当类实例化一个对象时会自动调用构造方法。
	- 构造方法和其他方法一样也可以重载。
	- 主要完成对象的初始化工作，构造方法的调用是在创建一个对象时使用new操作进行的。
	- 在设计类的过程中，如果不显示的定义构造方法，那么编译器会自动提供一个默认空参数的构造方法给到程序（隐式存在），如果一旦定义了任何构造方法，那么编译器就不会再提供默认空参数的构造方法。

### 创建对象的五种方法

- 使用new关键字

	```java
	ObjectName obj = new ObjectName()
	```

- 使用反射的Class类newInstance()方法

	```java
	ObjectName obj = ObjectName.class.newInstance()
	```

- 使用反射的Constructor类的newInstance()方法

	```java
	ObjectName obj = ObjectName.class.getConstructor.newInstance()
	```

- 使用对象克隆clone()方法

	```java
	ObjectName obj = obj.clone()
	```

- 使用反序列化（ObjectInputStream）的readObject()方法

	```java
	try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { 
		ObjectName obj = ois.readObject(); 
	}
	```

### 四要素

+ 修饰符
+ 构造方法名：与类同名
+ 形参列表
+ 构造方法体：为属性进行赋值操作

### 属性赋值时机关系图

​	默认值  ==>  构造方法赋值  ==>  对象名.属性名/setter方法

### 与构造代码块的区别

​	构造代码块是给所有不同对象的共性进行统一初始化，构造函数是对应的对象进行初始化。

**【注意事项】**：构造方法的首行位置存在隐式三步：

1. super()
2. 为非静态属性进行显示赋值操作
3. 执行构造代码块

【**注意**】：上述2、3没有先天的先后顺序，到底谁先被执行完全取决于代码的定义顺序

### this的三个作用

1. 记录了正在创建或者已经创建完毕的对象的内存地址
2. 区分同名的成员变量和局部变量
3. 本类中构造方法之间相互调用

**注意事项**

1. 构造方法之间对this的调用必须是构造器中的第一个语句
2. 构造方法之间相互调用不能形成闭合回路,否则对象永远不能创建完毕
2. this存储在堆内存中
2. this只能使用在实例方法中（谁调用这个实例方法，this就是谁）
2. this不能出现在静态方法里面

### static

​	修饰类、属性、方法和代码块

1. 静态的成员与类有关,非静态的成员与对象有关
2. 类加载要远远早于对象加载：**先有类（早出现的），后有对象（晚出现的）**
3. 早的不能调用晚的，晚的可以调用早的
4. 生命周期现象

修饰方法的特点/好处：节省内存空间，代码量变少（类名直接调用）

修饰属性的特点/好处：定义一份给所有对象共用

**注意事项：**

```markdown
场景一：
		类名可以直接访问类中的静态成员(属性、方法)					同一生命周期
		类名不可以直接访问类中的非静态成员(属性、方法)				早的不能调用晚的
		对象名可以直接访问类中的非静态成员(属性、方法)				同一生命周期
		对象名可以直接访问类中的静态成员(属性、方法)					晚的可以调用早的

场景二：
		在静态方法中可以直接访问本类的静态成员(属性、方法)			同一生命周期
		在静态方法中不可以直接访问本类的非静态成员(属性、方法)		早的不能直接调用晚的
		在静态方法中可以间接访问本类的非静态成员(属性、方法)
				具体步骤如下：
					第一步：先创建一个Demo对象
					第二步：通过对象调用非静态成员(属性、方法)即可
		在非静态方法中可以直接访问本类的非静态成员(属性、方法)		同一生命周期
		在非静态方法中可以直接访问本类的静态成员(属性、方法)		晚的可以调用早的
```
## 代码块

### 静态代码块

​	将某些容器/组件对象提前准备好  ==>  随着类的加载就准备就绪了，随着类的加载而被执行，只会被加载执行一次  

**定义格式**

```java
static{

}
```

### 构造代码块

​	将多个构造方法中相同的代码进行抽取，定义到构造代码块中；每次创建对象，构造代码块都会被执行一次

**目的**

​	提高程序的复用性

**定义格式**

```
{

}
```

### 局部代码块

​	作用：限制代码的使用范围

**定义格式**

```、
{

}
```

【**比较**】：构造代码块和局部代码块虽然格式一模一样，但是定义的位置不相同；

​		构造代码块定义在类的成员位置					局部代码块定义在类的局部位置

### Java程序初始化顺序

1. 父类的静态代码块
2. 子类的静态代码块
3. 父类的普通代码块
4. 父类的构造方法
5. 子类的普通代码块
6. 子类的构造方法

【**重点例题**】

```java
public class Test
{	
    public static Test t1 = new Test();
    {//构造代码块
         System.out.println("blockA");
    }
    static
    {//静态代码块
        System.out.println("blockB");
    }
    public static void main(String[] args)
    {
        Test t2 = new Test();
    }
 }
```

```markdown
<clinit>是类实例化<init>是实例初始化
首先弄懂一个概念：静态成员变量，静态代码块是一个级别的，谁在前面先执行谁，test1是静态成员变量，在第一行。当我们运行程序的时候，类开始加载，加载类的时候加载静态的东西，test1是Test类的静态成员变量，并且在第一行，那么先加载它，test1=new Test（），这里只看等号的右侧，因为是new所以是创建Test的对象，创建对象的时候使用init，而在init中，构造代码块是优先于构造方法，所以先走构造代码块，（估计很多同学就卡在这里了，说为啥不走下面的satic｛｝，输出“blockB”。因为这里就是单纯的创建对象，创建对象只走init，只走init，只走init，【init只包含构造代码块和构造方法，不包含下面的static】所以输出““blockA”）输出“blockA”，接着走构造无惨构造，走完后，完成test1的创建，将地址值赋值给test1，至此，静态成员变量test1结束；然后接着往下，执行下面的静态代码块，输出“blockB”。至此，类加载结束，控制台上看到的是blockAblockB。
 -----------------------------------------------------------------------------------------------------------
回到原题：
    上面已经说的很清楚了，我们运行代码，开始加载类控制台上输出blockAblockB，然后创建test2对象，因为静态的东西只执行一次，所以到test2=new Test（）的时候，就不会再走静态成员变量test1和静态代码块了，直接就是init创建test2，走构造代码块，输出“blockA”，然后走构造方法，程序结束，最后控制台上就是：blockAblockBblockA；
```

```
Eclipse快捷键       
​       快速生成main alt + /
​		快速生成打印语句syso alt + /
​		复制操作:
​		向上向下复制ctrl + alt + ↑/↓
​		删除ctrl + d
​		移动操作向上向下移动alt + ↑/↓
​		联想提示,补全代码alt + /
​		添加单行注释ctrl + /
​		添加多行注释全部选中ctrl + shift + /	取消ctrl + shift + \
​		补全等号左侧局部变量,联想导包ctrl + 1
​		快速导包ctrl + shift + o
​		格式化代码ctrl + shift + f
​		查看源代码ctrl + shift + t -> 输入类名 -> 回车
​		实体类快捷方法 alt + shift + s
​		多行输入alt + shift + a
​		另起一行shift + 回车
```

## 继承

​	**目的**：提高程序代码的复用性

​	将多个类中的共同内容进行代码抽取,定义到一个共形类中；让这多个类跟共性类发生一个extends的（继承）关系，这多个类称为子类型，共性类称为父类型，由于有了继承性的支持，所有父类中的成员子类都可以使用

```
class A{

}
class B extends A{

}
```

**【结论】：**

1. Java语言中类和类之间只能满足单一继承   ==》  一个类只能有一个直接父类
2. Java语言中类和类之间可以满足多重继承  ==》  一个类可以有多个间接父类
3. Java语言中一个类可以有多个子类

### super

1. 调用父类构造方法
2. 调用父类中的属性
3. 调用父类中的方法

【**注意**】：

1. 在实例化对象的过程中，内存中一定会一路调用super(...)构造方法直到Object()构造方法为止，这个对象才会被真正的创建成功；如果这个过程中一旦出现了任何问题，对象创建一定是失败的

2. 类中定义了带参构造方法的同时，保留一个空参构造方法

3. 子父类中定义了相同名字的非静态属性，在子类方法中对其进行调用执行，默认调用的是子类中的,如果想要调用父类中的，需要显示的定义super.属性名的方式来实现

4. 子父类中定义了相同名字的非静态方法，在子类别的方法中对其进行调用执行，默认调用的是子类中的,如果想要调用父类中的，需要显示的定义super.方法名的方式来实现

4. 未被重写的方法可以直接调用

4. 子类重写父类方法后,若想调用父类中被重写的方法要用super

   【**原因**】：

   	1.可能会有新的子类出现，如果没有空参构造方法，在子类继承他的过程中，会因为隐式三步中第一步丢失super()而报错
   	2.方便使用反射技术创建对象
   	3.父类中private修饰的成员，子类不能直接使用，因为封装性的原因
   	4.在子类构造方法中使用super(...)调用父类构造，必须只能被定义在首行位置，由于上述的特点，this(...)和super(...)不可能出现在同一个构造方法中

### 重写：override/overwrite

​	父类中的方法子类需要使用它，但是父类中该方法的方法体不能满足或者完全不满足我子类的需求，此时子类就需要重写父类的该方法

【**要求**】：

1. 子类重写父类的方法，方法名必须相同
2. 子类重写父类的方法，返回值类型必须相同
3. 子类重写父类的方法，访问修饰符(同为static或非static)必须相同
4. 子类重写父类的方法，形参列表必须相同
5. 子类重写父类的方法，子类方法的权限修饰符必须大于等于父类方法的权限

### final

1. 修饰类时，表示该类不可以被继承
2. 修饰变量时，表示该属性就为一个常量
3. 修饰方法时，表示该方法不可以被重写

【**面试**】：

1. final修饰数组对象，数组对象的引用值不可变，但是数组中的元素内容是可以发生变化的
2. final修饰第三方类型(Person、Animal...)，第三方类对象的引用值不可变，但是对象中的属性内容是可以发生变化的

【**注意**】final成员变量必须满足以下其中一个条件

1. 初始化赋值
2. 在构造函数中赋值

### abstract

1. 修饰方法：抽象方法 ==> 描述不清的方法
2. 修饰类：抽象类 ==> 描述不清的类

【**注意事项**】：

1. 抽象类不能被实例化/创建对象
2. 抽象类也是类，同样拥有构造方法  **只要是类就一定有构造方法**
3. 抽象类存在的意义就是为了给子类继承的
4. 子类继承抽象父类，必须重写父类（直接、间接）中所有的抽象方法，一旦全部重写完毕，这个子类就是一个具体类，可以实例化对象，否则子类也必须被定义为抽象类
5. 抽象类中可以不定义抽象方法
6. 抽象类中可以定义一般类中所有的成员，也可以单独定义抽象方法
6. 抽象类可以实现接口,抽象类也可以继承自抽象类

## 多态

​	一种事物的多种形态

【**对象调用非静态方法**】：在编译阶段需要考虑等号左侧，在运行阶段需要考虑等号右侧

### 多态性的使用场景

1. 多态参数
2. 多态数组
3. 多态返回值

【**优点**】：代码的冗余度降低，阅读性变好，功能的拓展性变强

### 引用类型之间的类型转换

​	强制向上转型(造型)		小 -> 大
​	强制向下转型(造型)		大 -> 小		【要求】：需要定义强制类型转换符

### 三目操作符类型转换规则

1. 若两个操作数不可转换，则不做转换，返回值为Object类型
2. 若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等
3. 若两个操作数中有一个是数字S,另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型
4. 若两个操作数都是直接量数字，则返回值类型为范围较大者

### 多态性的弊端

编译阶段：

【**漏洞**】：如果需要被转换成的类型确实是右侧类型对象的子类型，编译直接就放行通过了。

运行阶段：

在jvm进行强制向下转型的过程中，如果类型不一致，就直接报类型转换异常 ==> java.lang.ClassCastException

### 避免类型转换异常的出现

​	使用instanceof关键字

```
对象名	instanceof 数据类型
//执行流程
判断对象是否属于该右侧定义的数据类型
如果属于该类型，则结果返回true
如果不属于该类型，则返回false
```

### 多态引用

|                      | 编译阶段         | 运行阶段                                     |
| -------------------- | ---------------- | -------------------------------------------- |
| 属性（静态、非静态） | 看等号左边的类型 | 看左边（使用的是左侧类型中的属性）           |
| 静态方法             | 看等号左边的类型 | 看左边(调用执行的是左侧类型中的静态方法)     |
| 非静态方法           | 看等号左边的类型 | 看右边(调用执行的是右侧对象的非静态方法展现) |

【**总结**】：

​	属性(静态、非静态)、静态方法都没有多态性的具体体现，编译和运行都是看等号左侧

​	只有非静态方法有多态性的体现，编译看等号左侧类型，运行看的是等号右侧类型的表现

​	所以之后的学习和开发环境中，**多态性只会和非静态方法**配合使用

## 接口

​	封装一组规范、标准

### 定义接口

```
interface 接口名{
	//接口的成员
}
```

【**目的**】：接口定义的目的就是为了给类所实现的

### **类实现接口**

```
interface 接口名{
	//...
}
class 类名 implements 接口名{
	//重写接口中的抽象方法
}
```

### 接口中定义成员

Java 8之前：常量和抽象方法

```
public static final 数据类型 常量名 = 常量值;
简化形式：
数据类型 常量名 = 常量值;

public abstract 返回值类型 方法名(形参列表);
简化形式：
返回值类型 方法名(形参列表);
```

Java 8之后：默认方法和静态方法

```
public default 返回值类型 方法名(形参列表){
		//方法体
	}

public static 返回值类型 方法名(形参列表){
		//方法体
	}
```

**为什么会出现默认方法**？

```
在当前项目环境下去编写代码，定义了一个接口内部有20个抽象方法，有50个类都去实现了该接口，并且都重写了这20个抽象方法；随着项目的版本的迭代(进度派生)，我们需要扩展新的功能，要追加10个行为(方法)到这个接口中，如果使用以前的技术，都定义为抽象方法的话，以前实现该接口的50个类都会在第一时间直接报错(报红线)，并且大家需要考虑到这10个新的功能，可能只对于30个类是有意义的，还有20个类不需要使用到它们；此时我们引入新的技术 ==> 默认方法，将这10个功能都使用默认方法进行定义，定义完毕后之前实现接口的50个类都不会报错！！需要关注使用这个新功能的30个类可以选择性的对其进行重写操作，还有20个类直接无视即可...
```

**静态方法和默认方法的注意事项**：

```
1.接口中定义的静态方法只能通过接口名.方法名的形式进行调用，实现类对象是不能直接调用的
2.接口和父类中都定义了相同名字的默认方法和非静态方法，类继承父类的同时实现了该接口，在外界创建子类/实现类对象，调用该方法，默认访问的是父类中的(类优化原则)，如果想要访问接口中的同名方法，须在实现类中对其进行重写操作
3.接口冲突问题：
	在多个接口中都定义了相同名字的默认方法，类同时实现这多个接口，在实现的过程中必须显示的重写该默认方法，否则编译不通过
```

【**注意事项**】：

1. 类实现接口必须重写接口中所有的抽象方法，那么这个类就是一个具体类(称为实现类)，否则该类也必须被定义成为抽象类
2. 接口不能实例化/创建对象
3. 接口不是类，没有构造方法
4. 接口和实现类之间有多态性的表现：接口类型的引用  ==>  实现类的对象
5. Java中接口和接口之间可以多继承	==>  一个接口可以有多个直接父接口
6. Java中类和接口之间可以多实现
7. 类可以在继承父类的同时去实现多个接口，这样做可以将类中的功能扩大化

```
class 类名 extends 父类名 implements 接口名1,接口名2,...{

}
```

### 抽象类和接口的区别

| 特点               | 抽象类                  | 接口                              |
| ------------------ | ----------------------- | --------------------------------- |
| 构造方法           | 有                      | 无                                |
| 普通成员变量       | 有                      | 无                                |
| 普通方法           | 可以有非抽象的          | 必须是抽象的                      |
| 抽象方法的访问类型 | public、protected和默认 | 只能是public，默认public abstract |
| 静态方法           | 可以有                  | 无                                |
| 静态成员变量       | 有                      | 有public static final的           |
| 其他类             | 只能继承一个抽象类      | 可以实现多个接口                  |
| 应用场景           | 模块之间通信契约        | 代码重用                          |

1. **普通成员变量**：抽象类中可以有普通成员变量，接口中没有普通成员变量（static final变量）
2. **方法：抽象类中可以**包含**非抽象的普通方法**，**接口**中的所有**方法必须都是抽象**的，不能有非抽象的普通方法
3. **静态成员变量**：**抽象类和接口**中都可以**包含静态成员变量**，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是**public static final**类型，并且默认即为public static final类型
4. **静态方法：抽象类**中可以**包含静态方法**，但不能是抽象静态方法；接口中不能包含静态方法（静态的方法不能被覆写）
5. **构造方法（静态的）**：抽象类可以有构造方法，接口中不能有构造方法
6. **方法访问权限**：抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但**接口**中的抽象方法只能是**public类型**的，并且默认即为public abstract类型
7. **子类实现和继承**： 一个类可以实现多个接口，但只能继承一个抽象类

### 权限修饰符

| 范围      | 本类 | 同包不同类 | 跨包子父类 | 跨包非子父类 |
| --------- | ---- | ---------- | ---------- | ------------ |
| private   | √    | ×          | ×          | ×            |
| 缺省      | √    | √          | ×          | ×            |
| protected | √    | √          | √          | ×            |
| public    | √    | √          | √          | √            |

### 比较器接口

#### 定制比较器

​	java.util.Comparator接口

#### 自然比较器

​	java.lang.Comparable接口：某些事物对于有些属性天生就可以具备比较能力，此时我们就可以使用使用Comparable接口来实现

### Object类中常用方法

#### toString

​	String toString()：返回该对象的字符串表示

#### equals

​	boolean equals(Object obj)：将此字符串与指定的对象比较。当且仅当该参数不为 null，并且是与此对象表示相同字符序列的 String 对象时，结果才为 true

#### finalize

​	protected void finalize() throws Throwable{}：JVM的垃圾回收器调用这个方法。提供一个时机，当一个java对象即将被垃圾回收器回收时，希望执行代码可以写到这里面。

### 单例设计模式

1. 私有化本类所有的构造方法
2. 在本类中创建唯一对象
3. 提供外界获取唯一对象的方式(公共的方法)

#### 饿汉式

优点：在多线程的环境下，也一定保证对象是唯一的
弊端：可能造成内存的浪费

【**解决**】使用私有静态内部类

```java
class Singleton{
    //私有化本类所有的构造方法
    private Singleton(){}
    private static class Inner{
        //在私有静态内部类中创建唯一对象
        private static final Singleton S = new Singleton();
    }
    //提供外界获取唯一对象的方式
    public static Singleton getInstance(){
        return Inner.S;
    }
}
```

#### 懒汉式

优点：内存不会浪费
弊端：在多线程的环境下，可能不能保证对象是唯一的

【**解决**】使用同步代码块/同步方法

```java
public class Singleton{
    private Singleton(){}
    private static Singleton s;
    private static Object lock = new Object();
    public static /*synchronized*/ Singleton getInstance() {//这种情况用同步方法效率低
    //外层判断的语句能够提高执行的效率,当有一个线程创建完对象返回之后,其他的线程不会再进去到同步代码块中
        if (s == null){//如果没有这句可以直接使用同步方法
            synchronized (lock){
                if (s == null) {
                    s = new Singleton();
                }
            }
        }
        return s;//return语句不能放在单个if语句块内
    }
}
```

## 基本类型包装

| 基本类型 | 包装类型  |
| -------- | --------- |
| byte     | Byte      |
| short    | Short     |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |
| boolean  | Boolean   |
| char     | Character |

### 基本类型&包装类型&字符串类型三者之间转换

#### 基本类型->包装类型

1. 使用包装类构造方法

   ```java
   Integer iObj = new Integer（i）;
   ```

2. 使用包装类的静态方法valueOf

   ```java
   Integer iObj = Integer.valueOf（i）;
   ```

#### 包装类型->基本类型

​	使用xxxValue方法

```java
Integer iObj = new Integer（100）;
int i = iObj.intValue();
```

#### 包装类型->字符串类型

​	使用包装类的toString方法

```java
Integer iObj = new Integer（100）;
String s =iObj.toString();
```

#### 字符串类型->包装类型

1. 包装类的构造方法

   ```java
   String str = “123”；
   Integer iObj = new Integer（str）；
   ```

2. 包装类的静态方法

   ```java
   String str = “3.14”；
   Double dObj = Double.valueOf(str);
   ```

#### 基本类型->字符串类型

1. +""拼接操作
2. String类的静态方法valueOf
3. 包装类的静态方法

```java
int num = 666;
String s1 = num + "";
String s2 = String.valueOf(num);
String s3 = Integer.toString(num);
```

#### 字符串类型->基本类型

包装类的静态方法parseXxx

```java
String s = "123";
int num = Integer.parseInt(s);
String s2 = "3.14";
double num2 = Double.parseDouble(s2);
```

【**注意事项**】在字符串向其他两项转换时，可能会出现数字格式化异常

### 自动拆装箱

> JDK1.5之后支持

```java
Integer iObj = Integer.valueOf(50);		
//手动装箱操作		装箱：基本类型 -> 引用类型		手动：程序员显示的定义调用valueOf方法
int num = iObj.intValue();				
//手动拆箱操作		拆箱：引用类型 -> 基本类型		手动：程序员显示的定义调用xxxValue方法
		
Integer iObj2 = 50;//自动装箱操作		装箱：基本类型 -> 引用类型		自动：jvm隐式调用valueOf方法
int num2 = iObj2;//自动拆箱操作		拆箱：引用类型 -> 基本类型		自动：jvm隐式调用xxxValue方法
```

### 包装类型的特点好处

```java
//属性、方法
		System.out.println(Byte.BYTES);				//1
		System.out.println(Byte.SIZE);				//8
		System.out.println(Integer.MIN_VALUE);		//-2147483648
		System.out.println(Integer.MAX_VALUE);		//2147483647
		
		System.out.println(Integer.toBinaryString(10));		//"1010"
		System.out.println(Integer.toOctalString(10));		//"12"
		System.out.println(Integer.toHexString(10));		//"a"
```

### 包装类型面试题

```java
		Short sObj = 30;		//自动装箱操作
		Integer iObj = 30;
		Long lObj = 30L;
		Double dObj = 30.0;
		Number nObj = 30;
		
		int i = 30;
		long l = 30L;
		
		/*
		 * 	执行流程：
		 * 		①.iObj自动拆箱得到int值
		 * 		②.将上述①得到的int 和 int进行==比较
		 */
		System.out.println(iObj == i);	//true	
```

```
	数值型包装类对象之间进行==或者!=操作：
	必须满足运算符两侧数据类型为同一类型或者子父类的关系，否则编译报错！！
	数值型包装类对象之间进行> >= < <= 操作：
	运算符两个的数据类型可以不一致，运算结果和基本类型之间的比较运算一样理解
```

```java
/*
【注意事项/结论】：
		前提条件：
			只要有new存在，直接无脑比较地址
			没有new存在，在考虑以下的结论
	
		对于整数型包装类(Byte、Short、Integer、Long)，它们内部都有一个缓存区域，维护一段数据，范围：[-128,127]之间
		如果==运算两侧的包装类型对象维护的数据在缓存区域范围内，则比较的是数据内容
		如果==运算两侧的包装类型对象维护的数据在缓存区域范围外，则比较的是两个对象的地址信息
*/
		Integer iObj1 = 100;
		Integer iObj2 = 100;
		System.out.println(iObj1.equals(iObj2));		//true
		System.out.println(iObj1 == iObj2);				//true
		
		Integer iObj3 = 200;
		Integer iObj4 = 200;
		System.out.println(iObj3 == iObj4);				//false
		
		Integer iObj5 = Integer.valueOf(50);
		Integer iObj6 = Integer.valueOf(50);
		System.out.println(iObj5 == iObj6);				//true
		
		Integer iObj7 = 50;
		Integer iObj8 = Integer.valueOf(50);
		System.out.println(iObj7 == iObj8);				//true
		
		Integer iObj9 = new Integer(-100);
		Integer iObj10 = new Integer(-100);
		System.out.println(iObj9 == iObj10);			//false
		
		Integer iObj11 = new Integer(-100);
		Integer iObj12 = -100;
		System.out.println(iObj11 == iObj12);			//false
```

### foreach

```
for(数据类型 变量名 : 容器对象){
		//循环体
}//jvm会从容器对象中得到第一个对象，将该元素给到冒号左侧的变量，立即进入到大括号执行循环体
```

### 可变参数

```
数据类型 ... 变量名
```

**特点：**

1. 可变参数的范围区间：	少到可以没有内容，多到无上限	==>	[0,无穷多)
2. 可变参数底层还是一个数组

【**注意事项**】：可变参数只能定义在形参列表的最后位置，意味着方法的形参位置最多只能定义一个可变参数

## 字符串

>  java.lang.String类型描述字符串类型

**特点：**

1. 字符串类型不可被继承

2. 字符串底层还是一个数组(字符、字节（jdk1.9以上）)

   ```java
   /*遍历字符串数据
   方式一：使用字符串原生的api方法
   	char charAt(int index):返回指定索引处的char值
   	int length():返回此字符串的长度
   */
   for(int i = 0;i <= str.length() - 1;i++){
       System.out.println(str.charAt(i));
   }
   /*方式二：
   字符串类型 -> 字符数组类型
   char[] toCharArray()：将此字符串转换为一个新的字符数组
   */
   ```

   

3. 字符串不可变：字符串的引用地址是可以发生变化的，但是字符串的数据内容是不可变的

4. 对于字符串内容的改动操作，都不会影响其原本的内容，都只是在内存中创建新对象而已

5. 字符串的常量数据被存储在字符串常量池中

6. 常量池的特点：内部存储的字符串常量不会重复内容，并且可以给多个对象所共享

7. 不可变的字符序列

【**拓展**】：

java6版本：字符串常量池位置在方法区中
java7版本：字符串常量池从方法区被挪动到了堆区
java8版本：字符串常量池又被移动到了元数据区 --> meta data区

java8版本：字符串底层是一个字符数组	-->	char[]
java9版本：字符串底层是一个字节数组	-->	byte[]

### 字符串数据拼接后做==操作

> ==操作比较的是地址值是否相同

【**结论模板**】：
 * 		常量 + 变量  	  结果：在堆中
 * 		变量 + 常量		结果：在堆中
 * 		变量 + 变量		结果：在堆中
 * 		常量 + 常量		结果：在常量池

对于上述的四种情况，只有在常量池中的==比较，结果才会为true，其它的都是flase

**String intern()：返回字符串对象的规范化表示形式**

```
jvm会去常量池中查找是否有该对象存在
如果存在，直接返回该对象在常量池的地址信息
如果不存在，就先在常量池中创建该对象，然后返回该对象在常量池的地址信息
```

### 字符串常用方法

| 类型     | 方法                                        | 描述                                                         |
| :------- | ------------------------------------------- | ------------------------------------------------------------ |
| boolean  | equals(Object Obj)                          | 将此字符串与指定对象比较                                     |
| int      | length()                                    | 返回此字符串长度                                             |
| char     | charAt(int index)                           | 返回指定索引的char值                                         |
| String   | concat(String str)                          | 将指定字符串连接到此字符串末尾                               |
| String[] | split(String regex)                         | 根据给定的regex拆分字符串                                    |
| String   | substring(int beginIndex)                   | 返回一个字符串，该字符串是此字符串的子字符串                 |
| String   | substring(int beginIndex, int endIndex)     | 返回一个字符串，该字符串是此字符串的子字符串                 |
| int      | indexOf(String str)                         | 返回指定子字符串在此字符串中第一次出现处的索引               |
| int      | indexOf(String str, int fromIndex)          | 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始 |
| int      | lastIndexOf(String str)                     | 返回指定子字符串在此字符串中最右边出现处的索引               |
| int      | lastIndexOf(String str, int fromIndex)      | 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 |
| String   | toUpperCase()                               | 使用默认语言环境的规则将此 String 中的所有字符都转换为大写   |
| String   | toLowerCase()                               | 使用默认语言环境的规则将此 String 中的所有字符都转换为小写   |
| String   | trim()                                      | 返回一个字符串，该字符串忽略前导空白和尾部空白               |
| boolean  | startsWith(String prefix)                   | 测试此字符串是否以指定前缀开头                               |
| boolean  | endsWith(String suffix)                     | 测试此字符串是否以指定后缀开头                               |
| boolean  | contains(CharSequence s)                    | 当且仅当此字符串包含指定的char值序列时，才返回true           |
| int      | compareTo(String anotherString)             | 按字典顺序比较两个字符串                                     |
| int      | compareToIgnoreCase(String str)             | 按字典比较两个字符串，不考虑大小写                           |
| String   | replaceAll(String regex,String replacement) | 根据regex替换此字符串中匹配的子字符串                        |

### 字符串缓冲区

+ java.lang.StringBuffer类

+ java.lang.StringBuilder类

【**作用**】：在实际开发中，如果需要对字符串数据内容进行频繁的改动操作（增、删、改），使用String原生的api方法来实现，会在内存中产生很多新的对象，内存这块处理不太恰当；所以我们考虑使用字符串缓冲区对象来优化上述行为

【**好处**】：对于字符串数据进行改动操作，不会产生新对象，至始至终都是一个对象

【**区别**】：StringBuffer从JDK1.0就存在了，方法中都有synchronized修饰，是线程安全的可变字符序列，但性能较低；StringBuilder从JDK1.5才出现，线程不安全，但性能高。

【**特点**】：底层是一个byte[]数组，初始化容量为16

### System类

> java.lang.System
> System类包含几个有用的类字段和方法，不能被实例化

#### 成员方法

| 类型              | 方法                    | 描述                                                     |
| ----------------- | ----------------------- | -------------------------------------------------------- |
| static Properties | getProperties()         | 确定当前的系统属性                                       |
| static String     | getProperty(String key) | 获取指定键指示的系统属性                                 |
| static long       | currentTimeMillis()     | 返回以毫秒为单位的当前时间 -->可以用来测试方法的性能优劣 |
| static void       | setOut(PrintStream out) | 重写分配**标准**输出流                                   |

### Runtime类

>  java.lang.Runtime

#### 核心方法

| 类型           | 方法          | 描述                                   |
| -------------- | ------------- | -------------------------------------- |
| static Runtime | getRuntime()  | 返回与当前Java应用程序相关的运行时对象 |
| long           | totalMemory() | 返回Java虚拟机中的内存总量             |
| long           | freeMemory()  | 返回Java虚拟机中的空闲内存量           |

## 集合体系

集合体系有两个基本接口Collection接口和Map接口，容器类的基本类型是List、Set和Map也成为集合类

【**特点**】：

1. 集合容器的长度可变 ==》可以自动扩容
2. 集合容器中只能存储引用类型数据，java5及以后版本可以直接定义存入基本类型，因为底层有一个自动装箱行为存在
3. 由于存储数据的要求各不相同，所以集合体系中也有各种类型的集合容器存在，这些集合容器底层的数据结构各不相同
4. 集合也是一款容器，所以它的设计仍然是围绕着crud操作
5. 集合体系框架在jdk1.2版本才真正确定

![集合框架体系图解](https://java-laplace.oss-cn-shanghai.aliyuncs.com/img/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%E5%9B%BE%E8%A7%A3.png)

【**注意**】由于Collection是接口，不能实例化对象，所以使用它的主要实现类ArrayList进行模拟

### 集合常用方法

| 类型               | 方法                         | 描述                                                     |
| ------------------ | ---------------------------- | -------------------------------------------------------- |
| boolean            | add(E e)                     | 确保此集合包含指定的元素                                 |
| boolean            | addAll(Collection c)         | 将指定集合中的所有元素添加到此集合中                     |
| int                | size()                       | 返回此集合中的元素数                                     |
| boolean            | remove(Object c)             | 从此集合中移除指定元素的单个实例（调用了equals）         |
| void               | clear()                      | 删除此集合中所有元素                                     |
| boolean            | isEmpty()                    | 如果此集合中不包含元素则返回true                         |
| boolean            | contains(Object o)           | 如果此集合中包含指定元素则返回true（调用了equals）       |
| boolean            | containsAll(Collection<?> c) | 如果此集合中包含指定集合中的所有元素则返回true           |
| boolean            | removeAll(Collection<?> c)   | 移除此集合中那些也包含在指定集合中的所有元素（移除交集） |
| boolean            | retainAll(Collection<?> c)   | 仅保留此集合中那些也包含在指定集合的元素（保留交集）     |
| Object[]           | toArray()                    | 返回包含此集合中所有元素的数组（集合->数组）             |
| static\<T>List\<T> | Arrays.asList(T... a)        | 返回一个受指定数组支持的固定大小的列表(数组->集合)       |

### Iterator迭代器

> java.util.Iterator	用于操作集合元素遍历	是Iterator接口的实现类对象

| 类型         | 方法                  | 描述                                 |
| ------------ | --------------------- | ------------------------------------ |
| Iterator\<E> | Collection.iterator() | 返回在此集合的元素上进行迭代的迭代器 |

【**特点**】：

+ 集合对象通过iterator方法获取对应的迭代器对象，这个迭代器对象内部就记录了这个集合对象的完整内部结构
+ 集合结构只要发生改变，迭代器必须重新获取    否则会发生java.util.ConcurrentModificationException

### 迭代器常用方法

| 类型    | 方法      | 描述                                             |
| ------- | --------- | ------------------------------------------------ |
| boolean | hasNext() | 如果仍有元素可以迭代则返回true                   |
| E       | next()    | 返回迭代的下一个元素                             |
| void    | remove()  | 从迭代器指向的集合中移除迭代器返回的最后一个元素 |

【**注意事项**】：

1. 迭代器对象不可逆，一旦遍历完成后续还想要重新遍历，只能再次得到一个新的迭代器对象来实现
	**在迭代器遍历中会出现运行时异常：没有足够元素（java.util.NoSuchElementException）**

2. hasNext和next方法配合使用可以避免NoSuchElementException异常的出现

3. 在迭代器遍历元素过程中使用集合原生的remove方法删除元素会出现运行异常并发修改异常（java.util.ConcurrentModificationException）

   因为一旦remove成功了，那么集合容器中的数据就没有了，但是迭代器中还记录维护着删除以前的数据，两方数据无法对应（不能同步），所以Java语言直接会运行报错

   使用迭代器中的remove方法可以避免异常出现

**idea快捷键**

```
生成main方法 -> psvm
打印语句 -> sout
向下复制 -> ctrl + d
另起一行 -> ctrl + enter
删除代码 -> ctrl + y
向上向下移动 -> ctrl + shift + ↑/↓
添加或者取消单行注释 -> ctrl + /
多行注释 -> ctrl + shift + /
构建代码块 -> alt + ins -> shift + ↓(getter&setter&toString&equals)
补全代码找回联想 -> ctrl + alt + 空格
流程控制结构or异常处理效果 -> ctrl + alt + t
补全标点及未完成结构 -> ctrl + shift + 回车
补全等号左侧代码 -> alt + 回车
格式化代码 -> ctrl + alt + L
for循环 -> itar
增强for循环 -> iter
```

### List集合

> 有序可重复(有下标)

#### List常用方法

| 类型     | 方法                                         | 描述                                                         |
| -------- | -------------------------------------------- | ------------------------------------------------------------ |
| void     | add(int index, E element)                    | 将指定元素插入到此列表中的指定位置                           |
| boolean  | add(E e)                                     | 将指定元素追加到此列表的末尾                                 |
| boolean  | addAll(int index, Collection<? extends E> c) | 将指定集合中的所有元素插入到指定位置的此列表中               |
| boolean  | addAll(Collection<? extends E> c)            | 将指定集合中的所有元素按指定集合的迭代器返回的顺序追加到此列表的末尾 |
| void     | clear()                                      | 删除此列表中的所有元素                                       |
| E        | remove(int index)                            | 删除此列表中指定位置的元素                                   |
| boolean  | remove(Object o)                             | 从此列表中删除指定元素的第一个匹配项                         |
| boolean  | remove(Collection<?> c)                      | 从此列表中删除指定集合中包含的所有元素                       |
| E        | set(int index, E element)                    | 用指定的元素替换此列表中指定位置的元素                       |
| E        | get(int index)                               | 返回此列表中指定位置的元素                                   |
| Object[] | toArray()                                    | 以适当的顺序（从第一个元素到最后一个元素）返回包含此列表中所有元素的数组 |
| int      | indexOf(Object o )                           | 返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-1 |
| int      | lastIndexOf(Object o)                        | 返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-1 |

【**注意事项**】：一旦定义类型为List的实现类使用接口中的remove方法会首先调用List接口中的remove方法，如果需要使用Collection中的remove方法需要将数据转化为包装类型数据

#### List接口迭代器

| 类型             | 方法                    | 描述                                                         |
| ---------------- | ----------------------- | ------------------------------------------------------------ |
| ListIterator\<E> | listIterator()          | 返回此列表中元素的列表迭代器                                 |
| ListIterator\<E> | listIterator(int index) | 从列表中指定位置开始,返回列表中元素的列表迭代器              |
| boolean          | hasPrevious()           | 如果此列表迭代器在反向遍历列表时具有更多元素则返回true(listIterator中的方法) |
| E                | previous()              | 返回列表中的上一个元素并向后移动光标位置(listIterator中的方法) |

#### ArrayList

1. ArrayList集合底层先创建一个长度为0的数组，当添加第一个元素的时候，初始化容量是10
2. ArrayList集合底层是Object类型的数组Object[]
3. ArrayList的构造方法可以传初始容量
4. ArrayList的扩容是原容量的1.5倍
5. 数组的查询效率高，随即增删元素效率低（向末尾添加效率还是高）
6. ArrayList是非线程安全的（可用集合工具类变为线程安全）
7. ArrayList的构造方法可以传Collection（比如Set），可以将Set转为List

#### LinkedList

+ 底层采用双向链表数据结构
+ 对于链表数据结构，随机增删效率较高，检索效率较低
+ 链表中的元素在空间存储上，内存地址不连续

#### Vector

+ 初始容量是10
+ 扩容之后是原容量的两倍
+ jdk1.0就存在，线程安全，都带有synchronized关键字、性能较低
+ 用Collections.synchronizedList(ArrayList)方法变为线程安全

### Set集合

> Map集合的key部分

#### HashSet

主要实现类：java.util.HashSet类	数据结构：哈希表

【**特点**】完全无序且不可重复

判断元素是否重复：

1. hashCode和equals方法的配合使用，先hashCode，在考虑是否需要比较equals
2. HashSet集合中需要存储自定义类的对象，那么该类就需要重写Object类中的hashCode和equals方法

#### LinkedHashSet

java.util.LinkedHashSet类	数据结构：链式哈希表

【**特点**】保证不可重复的前提下，维护了一层添加顺序

#### TreeSet

java.util.TreeSet类	数据结构：红黑树

【**特点**】根据大小判断，如果是相等的，就认为是重复的

【**注意事项**】：

1. 使用空参数的构造方法创建TreeSet集合，存入该集合的元素类型必须和java.lang.Comparable接口存在实现的关系
2. 存入TreeSet集合中的元素类型都必须是一致的，否则没有可比性
3. 使用带参构造方法创建TreeSet集合，参数位置传入一个定义比较器接口的实现类对象（java.util.Comarator接口），存入的元素就具备了比较的环境

【**比较**】：HashSet和LinkedHashSet

```
都保证了元素不可重复，HashSet内部元素是完全无序，而LinkedHashSet内部元素维护了一层添加顺序；
所以LinkedHashSet性能比HashSet要低(干的多了，效率就低了)；
如果在日后开发需求中，既要保证元素不可重复，又要维护一层添加顺序，就选择使用LinkedHashSet集合，
否则一律无脑选择HashSet
```

【**比较**】：HashSet和TreeSet

```
都保证了元素不可重复，HashSet内部元素是完全无序，而TreeSet内部元素维护了大小关系；
所以TreeSet性能比HashSet要低(干的多了，效率就低了)；
如果在日后开发需求中，既要保证元素不可重复，又要维护一层大小关系，就选择使用TreeSet集合，
否则一律无脑选择HashSet
```

### Map

> java.util.Map

​	在实际开发中有时我们需要将有关联的一组数据绑定式存入到集合容器中，此时单列集合明显不合适，此时就需要双列集合进行数据管理存储

【**特点**】

1. Map集合的每个元素都是一对对的组合对象，一端数据为键，英文描述key，另一端数据我们称为值，英文描述value（key和value都是存储java对象的内存地址）

2. Map中的每个元素，我们都称为键值对组合，也被称为映射关系组合

3. 键是不可以重复的（唯一性），值是可以重复的，所以整个键值对组合也是不可重复的

4. 键可以找到对应的值，但是值不能找到对应的键 ==> 值可能重复的

5. 主要实现类：

	```
	|--HashMap
		|--LinkedHashMap
	|--TreeMap
	|--Hashtable：jdk1.0退出历史，线程安全，效率低
		|--Properties：属于Hashtable的子类，仍被使用
	```

6. HashMap和LinkedHashMap都可以存储null键和null值

7. TreeMap和Hashtable不允许存储null键和null值

8. Properties只允许String作为键和值的类型

#### 常用方法

| 类型    | 方法                        | 描述                           |
| ------- | --------------------------- | ------------------------------ |
| void    | clear()                     | 清空Map集合                    |
| V       | put(K key,V value)          | 向Map集合中添加键值对          |
| boolean | containsKey(Object key)     | 判断Map中是否包含某个Key       |
| boolean | containsValue(Object value) | 判断Map中是否包含某个Value     |
| V       | get(Object key)             | 通过key获取value               |
| boolean | isEmpty()                   | 判断Map集合中的元素个数是否为0 |
| V       | remove(Object key)          | 通过key删除键值对              |
| int     | size()                      | 获取Map集合中键值对的个数      |

#### Map接口中定义了三个方法进行迭代

| 类型                                             | 方法       | 描述                                            |
| ------------------------------------------------ | ---------- | ----------------------------------------------- |
| Set\<K>                                          | keySet()   | 获取Map集合中所有的Key（所有的键是一个Set集合） |
| Collection\<V>                                   | values()   | 获取Map集合中所有的value，返回一个Collection    |
| Set<Map.Entry<K,V>>（Map.Entry是一个静态内部类） | entrySet() | 将Map集合转换成Set集合                          |

```java
Set<Map.Entry<K,V>> entrys = map.entrySet();
for(Map.Entry<K,V>entry : entrys){
    System.out.println(entry);
	System.out.println(entry.getKey() + ":" + entry.getValue());
}
```

#### HashMap

+ 底层数据结构
	+ JDK1.7：数组 + 链表
	+ JDK1.8：数组 + 链表 + 红黑树

+ 单向链表
	+ JDK1.7：Entry对象
	+ JDK1.8：Node对象

【**HashMap在JDK1.7和1.8中的不同**】：

+ **JDK1.7**：

1. HashMap里面是一个数组，然后数组中每个元素是一个单向链表

2. 单向链表由一个Entry静态内部类表示

	1. Entry包含四个属性：key，value，hash值和用于单向链表的next

3. capacity：当前数组容量，默认是16，始终保持2^n，可以扩容，扩容后数组大小为当前的2倍

4. loadFactor：负载因子（加载因子），默认为0.75，表示存入的元素占总元素的3/4时就需要扩容

5. threshold：扩容的阈值，等于capacity * loadFactor

6. HashMap中有一个数组

	```java
	transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;
	```

+ **JDK1.8**：

1. HashMap里面由数组 + 链表 + 红黑树构成
2. 链表长度（阈值/边界值）大于等于8且数组长度（数据总量）超过64会转化为红黑树O(logN)
2. 红黑树上节点数量小于6时，会重新把红黑树转换为单向链表
1. 将链表转换为红黑树之前会判断，如果当前数组的长度小于64，那么会先进行数组扩容，而不是转化为红黑树，以减少搜索时间。（如果在数组较小时出现红黑树结构，反而会降低效率，而红黑树需要左旋右旋变色来保持平衡）

+ **红黑树的性质**
	1. 每个节点要么是红的要么是黑的
	2. 根节点是黑的
	3. 如果一个节点是红的，那么它的两个字节的一定是黑的
	4. 从根节点到叶子节点或空子节点的每条路径，都包含相同数目的黑节点
	5. 每个叶节点（叶节点即指树尾端NIL指针或NULL节点）都是黑的

【**为什么设置加载因子为0.75，初始化临界值是12？**】

```
	HashMap中threshold是HashMap所能容纳的最大值。计算公式为length * LoadFactory。在数组定义好长度之后，负载因子越大，所能容纳的键值对个数也越大。
	Load Factory越趋近于1，那么数组中存放的数据（node也就越来越多），数据也就越密集，也就会有更多的链表长度处于更长的数值，查询的效率就会越低，当我们添加数据时，产生的hash冲突的概率也会更高。
	默认的LoadFactory是0.75，LoadFactory越小，越趋近于0，数组中存放的数据（node）也就越少，表现得更加稀疏
```

【**hash表底层采用何种算法计算hash值？还有哪些算法可以计算出hash值？**】

```
	hashCode方法是Object中的方法，所有的类都可以对其进行使用，首先底层通过调用hashCode方法生成初始hash值h1，然后将h1无符号右移16位得到h2，之后将h1与h2进行按位异或（^）运算得到最终hash值h3，之后将h3与(length-1)进行按位与（&）运算得到hash表索引
	其他计算hash值的方法：1）平方取中法	2）取余数	3）伪随机数法
```

【**HashMap的put方法流程**】

```
JDK1.8：
1.根据key值计算hash值，找到该元素在数组中存储的下标
2.如果数字是空的，则调用resize进行初始化
3.如果没有哈希冲突则直接放在对应的数组下标里
4.如果冲突了，且key已经存在，就覆盖掉value
5.如果冲突后是链表结构，就判断该链表是否大于8，如果大于8并且数组容量小于64，就进行扩容；如果链表节点数量大于8并且数组的容量大于	   64，则将这个结构转换成红黑树；否则，链表插入键值对，若key存在，就覆盖掉value
6.如果冲突后，发现该节点是红黑树，就将这个节点挂在树上
```

![HashMap的put流程](https://java-laplace.oss-cn-shanghai.aliyuncs.com/img/HashMap%E7%9A%84put%E6%B5%81%E7%A8%8B.png)

【**HashMap的扩容方式**】	

```
HashMap在容量超过负载因子所定义的容量之后，就会扩容。将HashMap容量扩大到原来的两倍。
```

```java
final Node<K,V>[] resize() {
        //oldTab：引用扩容前的哈希表
        Node<K,V>[] oldTab = table;
        //oldCap：表示扩容前的table数组的长度
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        //获得旧哈希表的扩容阈值
        int oldThr = threshold;
        //newCap:扩容之后table数组大小
        //newThr:扩容之后下次触发扩容的条件
        int newCap, newThr = 0;
        //条件成立说明hashMap中的散列表已经初始化过了，是一次正常扩容
        if (oldCap > 0) {
            //判断旧的容量是否大于等于最大容量，如果是，则无法扩容，并且设置扩容条件为int最大值，
            //这种情况属于非常少数的情况
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }//设置newCap新容量为oldCap旧容量的二倍（<<1）,并且<最大容量，而且>=16，则新阈值等于旧阈值的两倍
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
        }
        //如果oldCap=0并且边界值大于0，说明散列表是null，但此时oldThr>0
        //说明此时hashMap的创建是通过指定的构造方法创建的,新容量直接等于阈值
        //1.new HashMap(intitCap,loadFactor)
        //2.new HashMap(initCap)
        //3.new HashMap(map)
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        //这种情况下oldThr=0;oldCap=0，说明没经过初始化，创建hashMap
        //的时候是通过new HashMap()的方式创建的
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        //newThr为0时，通过newCap和loadFactor计算出一个newThr
        if (newThr == 0) {
            //容量*0.75
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
                //根据上面计算出的结果创建一个更长更大的数组
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        //将table指向新创建的数组
        table = newTab;
        //本次扩容之前table不为null
        if (oldTab != null) {
            //对数组中的元素进行遍历
            for (int j = 0; j < oldCap; ++j) {
                //设置e为当前node节点
                Node<K,V> e;
                //当前桶位数据不为空，但不能知道里面是单个元素，还是链表或红黑树，
                //e = oldTab[j]，先用e记录下当前元素
                if ((e = oldTab[j]) != null) {
                    //将老数组j桶位置为空，方便回收
                    oldTab[j] = null;
                    //如果e节点不存在下一个节点，说明e是单个元素，则直接放置在新数组的桶位
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    //如果e是树节点，证明该节点处于红黑树中
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    //e为链表节点，则对链表进行遍历
                    else { // preserve order
                        //低位链表：存放在扩容之后的数组的下标位置，与当前数组下标位置一致
                        //loHead：低位链表头节点
                        //loTail低位链表尾节点
                        Node<K,V> loHead = null, loTail = null;
                        //高位链表，存放扩容之后的数组的下标位置，=原索引+扩容之前数组容量
                        //hiHead:高位链表头节点
                        //hiTail:高位链表尾节点
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            //oldCap为16:10000，与e.hsah做&运算可以得到高位为1还是0
                            //高位为0，放在低位链表
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    //loHead指向e
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            //高位为1，放在高位链表
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        //低位链表已成，将头节点loHead指向在原位
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        //高位链表已成，将头节点指向新索引
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
```

```
扩容之后原位置的节点只有两种调整：
1.保持原位置不动（新bit位为0时）
2.散列原索引 + 扩容大小的位置区（新bit位为1时）
​	这样的扩容方式不仅节省了重新计算hash的时间，而且保证了当前桶中的元素总数一定小于等于原来桶中的元素数量，避免了更严重的hash冲突，均匀的把之前冲突的节点分散到新的桶中去
```

【**为什么Map桶中节点个数超过8才转为红黑树？**】

```
	树节点占用空间是普通Node的两倍，如果链表节点不够多却转换成红黑树，无疑会耗费大量的空间资源，并且在随机hash算法下的所有bin节点分布频率遵从泊松分布，链表长度达到8的概率只有0.00000006，几乎是不可能事件，所以8的计算是经过重重科学考量的
```

```
1.从平均查找长度来看，红黑树的平均查找长度是logn，如果长度为8，则logn=3，而链表的平均查找长度为n/4，长度为8时，n/2=4，所以阈值   8能大大提高搜索速度
2.当长度为6时红黑树退化为链表是因为logn=log6约等于2.6，而n/2=6/2=3，两者相差不大，而红黑树节点占用更多的内存空间，所以此时转换最为友好
```

**【HashMap为什么线程不安全？】**

```
	多线程下扩容死循环。JDK1.7中的HashMap使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题

​	多线程的put可能导致元素的丢失。多线程同时执行put操作，如果计算出来的索引位置是相同的，那会造成前一个key被后一个key覆盖，从而导致元素的丢失。此问题在JDK1.7和JDK1.8中都存在

​	put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题，此问题在JDK1.7和JDK1.8中都存在
```

### 集合工具类

| 类型                                         | 方法                                          | 描述                                       |
| -------------------------------------------- | --------------------------------------------- | ------------------------------------------ |
| static \<T> List\<T>                         | synchronizedList(List\<T> list)               | 返回由指定列表支持的同步（线程安全）列表   |
| static <T extends Comparable<? super T>>void | sort(List\<T> list)                           | 根据其元素的自然排序，将指定列表按升序排序 |
| static \<T> void                             | sort(List\<T> list, Comparator<? super  T> c) | 根据指定比较器引发的顺序对指定列表进行排序 |

### 泛型

设计一个容器类，设计者在设计的过程中并不确定将来内容会存入什么类型的对象

设计者在设计程序的过程中定义的只是泛型形参类型，只有在程序员使用的过程中可以明确泛型实参类型

#### 泛型形参

类型未知/不明确

```java
public interface Collection<E>{}
public interface List<E>{}
public class ArrayList<E>{}
public interface Comparable<T>{}
```

#### 泛型实参

类型明确

```java
public final class String implements Comparable<String>
```

【**好处**】:将问题出现的时机提前，从运行阶段提早到了编译阶段，对于数据类型进行约束，那么在运行阶段就不用在执行类型转换，数据类型统一了，安全性就提升了

【**注意事项**】：

1. java7版本后等号右侧的泛型实参可以省略(钻石表达式)
2. 泛型实参类型只能定义引用类型，不能为基本类型
3. 泛型实参类型不支持多态

#### 泛型形参的使用场景、领域

1. 泛型类/泛型接口
2. 泛型方法

#### 自定义泛型类

```
class 类名<泛型形参>{
	//...
}
```

#### 自定义泛型方法

```
方法的形参类型不明确,并且它的类型和泛型类的形参不一致,就可以使用泛型方法
修饰符 <泛型形参类型> 返回值类型 方法名(泛型形参类型 变量名){
	//方法体
}
class A<T>{
	public ... xxx(E){
	
	}
}
```

#### 自定义泛型接口

```
interface 接口名<T>{
	public abstract T func(T t);
}
```

#### 明确泛型实参的时机

1. 继承类或实现接口的过程中
2. 实例化对象的过程中

在实例化对象的过程中不明确泛型形参的类型 ==> 称为：泛型擦除，之后在使用该对象的过程中，所有的泛型形参位置都使用Object类型进行维护

#### 通配符

为了匹配各种适当的类型，做到等号左右两侧的泛型实参类型是统一的

#### 泛型的界定

```
? extends A:覆盖范围 ==> A类和其子类型
? super B:覆盖范围==> B类和其父类型
```

## 内部类

在一个class的内部又定义了一个class，外部的class我们称为外部类，内部的class被称为内部类

**为什么会有内部类**

在一个类的内部又存在一个独立完整的结构，这个结构根据需求也需要使用一个类进行描述，此时就需要定义为内部类；内部类需要依赖于外部类，单独存在没有任何意义

### 匿名内部类

当要使用一个类的子类（或接口的实现类）时，如果这个子类（或者实现类）只会使用一次，就没必要专门定义一个类出来，可以使用匿名内部类的方式调用

```java
new 类名（）｛                                            都包含了两个环节
//表示创建这个类的一个子类的对象                              1.设计匿名子类/实现类
｝                                                       2.并且创建该匿名子类/实现类的对象

new 接口名（）｛
//表示创建这个接口的一个实现类的对象
｝
```

【**面试题**】：在多态创建匿名子类对象时，子类特有方法不能被创建的对象所使用

### 非静态内部类

+ 设计外部类，权限修饰符只能使用两种：缺省、public；设计非静态内部类，权限修饰符可以使用四种

+ 设计非静态内部类中的成员：只能是非静态成员和常量

+ 非静态成员内部类中可以访问外部类的所有成员

+ 外部类的静态方法中访问非静态内部类的成员需要三个步骤

	```
	1.创建外部类对象
	2.通过外部类对象去创建非静态内部类对象
	3.通过非静态内部类对象调用它的非静态成员
	```

+ 外部类的非静态方法中访问非静态内部类的成员需要两个步骤

	```
	1.直接创建非静态内部类对象
	2.通过非静态内部类对象调用它的非静态成员
	```

+ 出了外部类在外界（测试类）想要访问内部类成员需要三个步骤

	```
	1.创建外部类对象
	2.通过外部类对象去创建非静态内部类对象
	3.通过非静态内部类对象调用它的非静态成员
	```

【**总结**】：非静态内部类依赖于外部类

### 静态内部类

#### 静态内部类

- 设计外部类，权限修饰符只能使用两种：缺省、public；设计静态内部类，权限修饰符可以使用四种

- 设计静态成员内部类中的成员：和外部类的成员保持一致

- 在静态内部类的（静态方法、非静态方法）访问外部类的非静态成员(属性、方法)需要两个步骤（静态可以直接用外部类名调用）

	```
	1.创建外部类对象
	2.通过外部类对象访问外部类的非静态成员
	```

- 在外部类的（静态方法、非静态方法）中访问静态内部类的成员：

	- 静态成员：
		- 直接类名调用
	- 非静态成员，需要如下两个步骤：
		- 创建静态内部类对象
		- 通过静态内部类对象访问非静态成员

- 在外界访问静态内部类的成员：

	- 静态成员：
		- 直接通过静态内部类名调用
	- 非静态成员，需要如下两个步骤：
		- 创建静态内部类对象
		- 通过静态内部类对象访问非静态成员

#### 私有静态内部类

​	只有使用到了类中的内容，这个类才会被触发类加载（可以用于解决饿汉式单例设计模式）

![内部类](https://java-laplace.oss-cn-shanghai.aliyuncs.com/img/%E5%86%85%E9%83%A8%E7%B1%BB.png)

### 数字格式化类

+ #：任意数字
+ ，：千分位
+ .：小数点

```java
DecimalFormat df = new DecimalFormat("###,###.##");
String s = df.format(1234.56);
DecimalFormat df = new DecimalFormat("###,###.0000");//保留四位小数，不够补零
```

### BigDecimal

> 属于大数据，精度极高。不属于基本数据类型，属于java对象（引用数据类型）

+ add()：加法
+ divide()：除法

### 日期类

#### java.util.Date类

| 构造方法        |                                                              |
| --------------- | ------------------------------------------------------------ |
| Date()          | 分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒） |
| Date(long date) | 分配 Date 对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数 |
| **常用方法**    |                                                              |
| long            | getTime()返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数 |

### 日期格式化类

#### java.text.DateFormat类

> 抽象类，不能被实例化

```
格式化操作
Date ==> String
String format(Date date)：将一个 Date 格式化为日期/时间字符串
解析操作
String ==> Date
Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期
```

##### 子类型：java.text.SimpleDateFormat类

SimpleDateFormat(String pattern) ：用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat

| 字母 | 含义   |
| ---- | ------ |
| y    | 年     |
| M    | 月     |
| d    | 天     |
| H    | 24小时 |
| h    | 12小时 |
| m    | 分     |
| s    | 秒     |

### 日历类

#### java.util.Calendar类

```
获取Calendar对象的方式
1.static Calendar getInstance()：使用默认时区和语言环境获得一个日历。 
2.使用子类GregorianCalendar的构造方法
```

| 类型           | 方法                                                         | 描述                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| void           | set(int field, int value)                                    | 将给定的日历字段设置为给定值                                 |
| void           | set(int year, int month, int date)                           | 设置日历字段 YEAR、MONTH 和 DAY_OF_MONTH 的值                |
| void           | set(int year, int month, int date, int hourOfDay, int minute) | 设置日历字段 YEAR、MONTH、DAY_OF_MONTH、HOUR_OF_DAY 和 MINUTE 的值 |
| void           | set(int year, int month, int date, int hourOfDay, int minute, int second) | 设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、MINUTE 和 SECOND 的值 |
| int            | get(int field)                                               | 返回给定日历字段的值                                         |
| abstract  void | add(int field, int amount)                                   | 根据日历的规则，为给定的日历字段添加或减去指定的时间量       |
| Date           | getTime()                                                    | 返回一个表示此 Calendar 时间值（从历元至现在的毫秒偏移量）的 Date 对象 |
| long           | getTimeInMillis()                                            | 返回此 Calendar 的时间值，以毫秒为单位                       |

# JavaSE强化

## 异常

​	程序在运行的过程中，操作了坏的数据（不存在的下标，打开一个不存在的文件...），导致程序非正常终止的现象。程序发生异常，默认处理方式：终止程序，打印异常信息。

### Throwable

>  java.lang.Throwable类是Java语言中所有**错误和异常**的超类

​	|——java.lang.Error:表示严重的问题，合理的应用程序不应该试图捕获。程序本身无法解决的问题。只能终止程序，解决错误的问题之后，重新编译运行。

​	|——java.lang.Exception:表示合理应用程序可能想要捕获的条件。程序本身可以通过捕获解决的问题。不影响程序的运行，异常解决之后（程序过程中），程序可以继续运行。

![异常体系图解](https://java-laplace.oss-cn-shanghai.aliyuncs.com/img/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE%E8%A7%A3.png)

### throw

​	抛出异常[异常对象]

```
throw new 异常对象(“异常的信息”)；
```

+ 抛出异常可以由JVM抛出，也可以由程序员抛出
	+ JVM能够识别的异常一般由JVM抛出，程序员也可以手动跑出，好处是可以更加详细的描述异常的信息。
	+ JVM无法识别的异常，一般由程序员抛出
+ 在定义方法时，只要方法中有形参，在对业务处理之前，先对形参合法范围进行判断（强壮性判断）

【**细节**】

1. throw抛出异常的语句只能写在方法内部
2. throw抛出的异常类型必须是Throwable本身或其子类类型
3. 程序执行到throw语句时会立即终止，所以它后面的语句执行不到
4. 不管程序本身，还是程序员手动抛出的异常，JVM对异常的处理都是一样的

### 自定义异常类

​	程序员根据业务的需求，自定义的异常类型

```java
public class ExceptionName extends Exception | RuntimeException{
	public ExceptionName(){}
	public ExceptionName(String message){super(message);}
}//继承Exception表示是编译时期的异常类型
//继承RuntimeException表示是运行时期的异常类型
```

### throws

​	声明异常[再次抛出]。是需要声明在方法上

```java
public static void methodName() throws 异常类型，异常类型...{
	方法体;
}
```

方法声明在当前的方法中并没有将异常解决，然后交由方法的上层调用者来解决。

+ 我们自己在定义方法时，方法中得到异常一般都是声明
+ 如果是调用方法时，方法中的异常一般都是捕获

【**注意事项**】

1. 如果方法中有多个异常，在声明时可以将多个异常都声明到方法上，使用逗号（，）隔开
2. 如果方法中抛出的多个异常之间有集成的关系，可以只声明多个异常的父类异常（不建议）
3. **如果子类在重写父类的方法时，父类方法上没有声明异常，那么子类在重写时也不能声明**
4. 子类重写父类的方法时，如果父类的方法上声明了异常，子类可以不用声明，也可以只声明父类异常的部分异常。同时也可以声明父类异常的子异常。

### 捕获异常

1. 一个方法有多个异常被声明时：

	+ 每个异常的处理方案不同时，将多个异常分别捕获
	+ 多个异常的处理方案相同时，将多个异常一次捕获

2. 一个方法的多个异常有继承关系的捕获顺序：优先捕获子类异常，最后捕获父类异常

3. 调用的多个方法中有异常

	+ 多个方法中的异常如果有业务关系，则需要一起捕获
	+ 多个方法中的异常如果没有业务关系，则需要分别捕获

4. JDK7新特性

	```java
	try{//可以使用|一次捕获多个异常
		...
	}catch(Exception1 | Exception2 e){
		...
	}
	```

### finally

​	try的子语句，无论是否发生都会执行的代码（System.exit()除外）

```java
try{												try{    						
	有可能发生异常的代码；									有可能发生异常的代码；
}catch(){											}finally{
	异常的处理；											无论是否发生都会执行的代码
}finally{											}
	无论是否发生都会执行的代码；						//在多线程中用到	释放系统资源
}//IOStream JDBC用到
```

#### 返回值问题

​	因为finally代码块无论是否发生异常都会执行，所以要尽量避免在finally中使用return返回结果，因为最后返回的一定是finally语句中的结果

```java
//java语法规则：1.方法体代码从上往下执行；2.return语句一旦执行整个方法必须结束
int i = 100;
try{
	return i;
}finally{
	i++;
}
//反编译后效果
int i = 100;
int j = i;
i++;
return j;
```

## File类

> java.io.File

​	**文件**和**目录**路径名的抽象表示

	+ 目录(文件夹)：管理目录和文件
	+ 文件：管理数据

File只能操作文件或者目录本身[创建、删除、设置...]，无法操作文件中的数据

路径名：文件或目录在计算机中的存储位置

+ 绝对路径：以盘符开始的路径
+ 相对路径：相对项目所在的路径

### 成员变量

| 变量和类型    | 字段              | 描述                                                        |
| ------------- | ----------------- | ----------------------------------------------------------- |
| static String | separator         | 与系统相关的默认名称 - 分隔符字符，以方便的方式表示为字符串 |
| static char   | separatorChar     | 与系统相关的默认名称[文件名]分隔符                          |
| static String | pathSeparator     | 与系统相关的路径分隔符字符，为方便起见，表示为字符串        |
| static char   | pathSeparatorChar | 与系统相关的路径分隔符                                      |

### 构造方法

| 构造器                            | 描述                                                        |
| --------------------------------- | ----------------------------------------------------------- |
| File(String pathname)             | 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 |
| File(File parent, String child)   | 从父抽象路径名和子路径名字符串创建新的 File实例             |
| File(String parent, String child) | 从父路径名字符串和子路径名字符串创建新的 File实例           |

【**注意事项**】

1. 路径名可以是绝对路径也可以是相对路径
2. 构造方法创建file对象时，不检测路径是否存在
3. 子父路径创建File对象时，可以独立操作父路径或子路径，父路径必须是一个目录，父路径可以是String类型或者File类型

### 获取类方法

| 类型   | 方法              | 描述                                                         |
| ------ | ----------------- | ------------------------------------------------------------ |
| String | getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串                           |
| String | getPath()         | 将此抽象路径名转换为路径名字符串：**获取构造方法中指定路径** |
| String | getName()         | 返回由此抽象路径名表示的文件或目录的名称                     |
| long   | length()          | 返回由此抽象路径名表示的文件的长度。**文件存在但是没有内容长度是0  文件不存在长度也是0  只用于获取文件长度** |
| long   | lastModified()    | 返回此抽象路径名表示的文件上次修改的时间                     |

### 判断类方法

| 类型    | 方法          | 描述                                     |
| ------- | ------------- | ---------------------------------------- |
| boolean | exists()      | 测试此抽象路径名表示的文件或目录是否存在 |
| boolean | isDirectory() | 测试此抽象路径名表示的文件是否为目录     |
| boolean | isFile()      | 测试此抽象路径名表示的文件是否为普通文件 |
| boolean | isHidden()    | 测试此抽象路径名命名的文件是否为隐藏文件 |
| boolean | isAbsolute()  | 测试这个抽象路径名是否是绝对的           |

### 创建类方法

+ 创建目录

  | 类型    | 方法     | 描述                                                       |
  | ------- | -------- | ---------------------------------------------------------- |
  | boolean | mkdir()  | 创建由此抽象路径名命名的目录                               |
  | boolean | mkdirs() | 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录 |

+ 创建文件
	
	| 类型    | 方法            | 描述                                                         |
	| ------- | --------------- | ------------------------------------------------------------ |
	| boolean | createNewFile() | 当且仅当具有该名称的文件尚不存在时，原子地创建一个由该抽象路径名命名的新的空文件。**文件所在的路径必须是存在的** |

### 删除类方法

| 类型    | 方法     | 描述                                                         |
| ------- | -------- | ------------------------------------------------------------ |
| boolean | delete() | 删除由此抽象路径名表示的文件或目录。**删除目录时，不能删除有子文件的目录，只能删除空目录** |

### 遍历列举方法

| 类型          | 方法        | 描述                                                         |
| ------------- | ----------- | ------------------------------------------------------------ |
| static File[] | listRoots() | 列出可用的文件系统根                                         |
| String[]      | list()      | 返回一个字符串数组，命名由此抽象路径名表示的目录中的文件和目录的名字 |
| File[]        | listFiles() | 返回一个抽象路径名数组，表示由该抽象路径名表示的目录中的子文件对象。**列举只能是目录，是文件则抛出空指针异常**，**列举的目录不存在，则抛出空指针异常** |

### 过滤器

​	保留需要的文件，将不需要的文件过滤出去

+ 文件名过滤器
	+ File[] listFiles(FilenameFilter filter) 返回一个抽象路径名数组，表示由此抽象路径名表示的满足指定过滤器的目录中的文件和目录
	+ java.io.FilenameFilter：用于实现此接口的类的实例用于过滤文件名
		+ boolean accept(File dir, String name) 测试指定文件是否应包含在文件列表中
			+ File dir：当前遍历的目录
			+ String name：目录下的文件名
			+ 返回值：boolean当结果为true时保留文件

```java
//创建文件名过滤对象
MyFilenameFilter mff = new MyFilenameFilter();
//列举
File[] files = file.listFiles(mff);
```

```java
public class MyFilenameFilter implements FilenameFilter {
    @Override
    public boolean accept(File dir, String name) {
        File newFile = new File(dir, name);
        return newFile.isDirectory() || newFile.isFile() && name.endsWith(".txt");
    }
}
```

+ 文件对象过滤器
  + File[] listFiles(FileFilter filter) 返回一个抽象路径名数组，表示由此抽象路径名表示的满足指定过滤器的目录中的文件和目录
  + java.io.FileFilter:抽象路径名的过滤器

```java
File[] files = file.listFiles(new java.io.FileFilter() {
    @Override
    public boolean accept(File pathname) {
        return pathname.isDirectory() || pathname.isFile() && pathname.getName().endsWith(".txt");
    }
});
```

## 递归

> 方法调用方法本身

【**注意事项**】递归要有结束的条件，并且递归的次数不能过多。**递归和循环的本质都是让某段代码重复执行**

## IO流

+ input 输入流[读操作]，从文件中读取到java应用程序中

+ output 输出流[写操作]，通过java应用程序给文件中写数据

文件中的数据，多个字节又可以组成一个中文的字符

1. 字节流：以字节为单位实现数据的读写操作
2. 字符流：以字符为单位实现数据的读写操作

+ 字节输入流： java.io.InputStream
+ 字节输出流： java.io.OutputStream
+ 字符输入流： java.io.Reader
+ 字符输出流： java.io.Writer

**输出流都是可刷新的**

ASCII编码表：一个字节表示1个字符，0xxx xxxx 
GBK编码表：两个字节表示一个字符， 110x xxxx xxxx xxxx
UTF-8编码表：三个字节表示一个字符，1110 xxxx xxxx xxxx xxxx xxxx

编码表：生活中的字符和计算机中整数编码值的对应关系表单

### OutputStream

​	java.io.OutputStream：这个抽象类是表示字节输出流的所有类的超类。输出流接收输出字节并将其发送到某个接收器

#### 成员方法

+ void write(int b) 将指定的字节写入此输出流。写出一个字节，如果超出一个字节，则写出最后的8个二进制
+ void write(byte[] b) 将 b.length字节从指定的字节数组写入此输出流
+ void write(byte[] b, int off, int len) 从指定的字节数组写入len字节，从偏移量off开始输出到此输出流
   + byte[] b：写出数据的数组
   + int off：起始下标
   + int len：写出的字节长度[个数]

+ void close() 关闭此输出流并释放与此流相关联的任何系统资源。**一定要执行的代码**  
+ void flush() 刷新此输出流并强制任何缓冲的输出字节被写出。**底层使用缓冲区时使用**

#### FileOutputStream

> java.io.FileOutputStream：文件输出流是用于将数据写入File的输出流

##### 构造方法

> 路径存在但是文件不存在时，会自动创建空文件，但是如果路径不存在则报错

| 构造器                                        | 描述                                            |
| --------------------------------------------- | ----------------------------------------------- |
| FileOutputStream(File file)                   | 创建文件输出流将数据写到指定的文件对象中        |
| FileOutputStream(String name)                 | 创建文件输出流将数据写到指定的文件路径中        |
| FileOutputStream(File file, boolean append)   | 创建文件输出流以写入由指定的 File对象表示的文件 |
| FileOutputStream(String name, boolean append) | 创建文件输出流以指定的名称写入文件              |

### InputStream

> java.io.InputStream：这个抽象类是表示输入字节流的所有类的超类

#### 成员方法

| 类型 | 方法                             | 描述                                                |
| ---- | -------------------------------- | --------------------------------------------------- |
| int  | read()                           | 从输入流读取数据的下一个字节                        |
| int  | read(byte[] b)                   | 从输入流中读取一些字节数，并将它们存储到缓冲区数组b |
| int  | read(byte[] b, int off, int len) | 从输入流读取最多 len个字节的数据到字节数组          |
| void | close()                          | 关闭此输入流并释放与流相关联的任何系统资源          |
| int  | available()                      | 返回流中剩余没有读到的字节数量                      |
| long | skip(long n)                     | 跳过几个字节不读                                    |

#### JDK9新方法

| 类型   | 方法                                   | 描述                                                         |
| ------ | -------------------------------------- | ------------------------------------------------------------ |
| int    | readNBytes(byte[] b, int off, int len) | 将所请求的字节数从输入流读入给定的字节数组                   |
| byte[] | readAllBytes()                         | 从输入流读取所有剩余字节，返回到byte数组中                   |
| long   | transferTo(OutputStream out)           | 从该输入流中读取所有字节，并按读取的顺序将字节写入给定的输出流 |

#### FileInputStream

> java.io.FileInputStream：文件字节输入流，从指定的文件中读取字节数据

##### 构造方法：路径必须存在

+ FileInputStream(File file) 创建字节输入流对象，从指定的文件对象读取字节数据
+ FileInputStream(String name) 创建字节输入流对象，从指定的文件路径读取字节数据

```java
FileInputStream fis = new FileInputStream("d:\\");
int ch = 0;
while((ch = dis.read()) != -1){
	System.out.println((char)ch)
}
	fis.close();//一次读取一个字节
```

```java
FileInputStream fis = new FileInputStream("d:\\");
byte[] bytes = new byte[8192];
int len = 0;
while((len = fis.read(bytes)) != -1){
    System.out.println(new String(bytrs,0,len));
}
	fis.close();//一次读取多个字节
```

#### 文件复制

1. 通过输入流将需要复制的文件读取到程序中
2. 通过输出流将读取的文件在写到指定的文件中

#### 文件切割

1. 切割成指定的文件碎片个数
2. 按照文件碎片的大小切割

#### SequenceInputStream

> java.io.SequenceInputStream：合并输入流，表示其他输入流的逻辑级联。它从一个有序的输入流集合开始，从第一个读取到文件的结尾，然后从第二个文件读取，依此类推，直到最后一个输入流达到文件的结尾

##### 构造方法

| 构造器                                                    | 描述                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| SequenceInputStream(Enumeration<? extends InputStream> e) | 初始化新创建 SequenceInputStream通过记住参数，它必须是一个 Enumeration产生对象，它们的运行时类型是 InputStream |

1. 创建集合（ArrayList\<InputStream>） 保存输入流对象
2. 将多个输入流保存到ArrayList集合中。
3. 根据集合通过集合类Collections工具获取 Enumeration 对象 --> static \<T> Enumeration\<T> enumeration(Collection\<T> c) 返回指定集合的枚举。
4. 创建SequenceInputStream对象 将  Enumeration 对象传递
5. 可以通过合并流读取多个文件中的数据。

### IO异常

【**模板代码**】

```java
public static void main(String[] args){
	FileInputStream fis = null;
    FileOutputStream fos = null;
    try{
        //创建字节输入输出流对象
        fis = new FileInputStream("d:\\");
        fos = new FileOutputStream("d:\\");
        //文件读写
        byte[] bytes = new byte[8192];
        int len = 0;
        while((len = fis.read(bytes)) != -1){
            fos.write(bytes,0,len);
        }
    }catch(IOException e){
        e.printStackTrace();
    }finally{
        //释放资源
        try{
            if(fos != null) {//判断是否为空，不然会出现空指针异常
                fos.close();
            }
        }catch(IOException e){
            e.printStackTrace();
        }
        try{
            if(fis != null)
            fis.close();
        }catch(IOException e){
            e.printStackTrace();
        }
    }
}
```

**JDK7 异常优化 --> IO流 需要打开物理资源**

```java
try(流对象;流对象) {
		正常读写的代码;
	}catch ( Exception e ){
		异常的处理;
	}//当try-catch语句执行结束之后，流对象会自动调用close()释放资源
```

```java
try(
		FileInputStream fis = new FileInputStream("d:\\");
		FileOutputStream fos = new FileOutputStream("d:\\");
){
	byte[] bytes = new byte[1024];//数据读写
	int len = 0;
	while ((len = fis.read(bytes)) != -1) {
		fos.write(bytes,0,len);
	}catch(Exception e){
		e.printStackTrace();
	}
}//JDK9可以把创建对象放在外面，之间在try后引用，但是在外面还要处理异常
```

### 字节缓冲流

【**高效流**】：通过底层缓冲区实现数据的高效读写		可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途

#### 字节输入缓冲流

> java.io.BufferedInputStream

##### 构造方法

+ BufferedInputStream(InputStream in) 创建一个 BufferedInputStream并保存其参数，输入流 in供以后使用
+ BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream ，并保存其参数，输入流 in供以后使用
   + InputStream in： BufferedInputStream 只提供缓冲区，InputStream用于将字节数组读取到缓冲区中。
   + int size:指定缓冲区的大小


#### 字节输出缓冲流

> java.io.BufferedOutputStream

##### 构造方法

+ BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流
+ BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以便以指定的缓冲区大小将数据写入指定的底层输出流
   + OutputStream out:  BufferedOutputStream 只提供缓冲区，OutputStream将字节数据写到缓冲区。
   + int size:指定缓冲区的大小


【**注意事项**】：在释放资源时，注意先开的后关

### Writer

> java.io.Writer:用于写入字符流的顶层抽象父类

#### 成员方法

| 类型          | 方法                                 | 描述                                                         |
| ------------- | ------------------------------------ | ------------------------------------------------------------ |
| void          | flush()                              | 刷新此输出流并强制任何缓冲的输出字节被写出，**没被写满一定要刷新** |
| void          | write(int c)                         | 写一个字符                                                   |
| void          | write(char[] cbuf)                   | 写入一个字符数组                                             |
| abstract void | write(char[] cbuf, int off, int len) | 写入字符数组的一部分                                         |
| void          | write(String str)                    | 写一个字符串                                                 |
| void          | write(String str, int off, int len)  | 写一个字符串的一部分                                         |
| abstract void | close()                              | 关闭流，先刷新                                               |

#### FileWriter

> java.io.FileWriter:文件字符输出流，给文件中写入字符数据

##### 构造方法

| 构造器                                      | 描述                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| FileWriter(File file)                       | 给一个File对象构造一个FileWriter对象                         |
| FileWriter(String fileName)                 | 构造一个给定文件名的FileWriter对象                           |
| FileWriter(File file, boolean append)       | 给一个File对象构造一个FileWriter对象                         |
| FileWriter(String fileName, boolean append) | 构造一个FileWriter对象，给出一个带有布尔值的文件名，表示是否附加写入的数据 |

### Reader

> java.io.Reader:用于读取字符流的顶层抽象父类

#### 成员方法

| 类型 | 方法                                | 描述                                 |
| ---- | ----------------------------------- | ------------------------------------ |
| int  | read()                              | 读一个字符                           |
| int  | read(char[] cbuf)                   | 将字符读入数组                       |
| int  | read(char[] cbuf, int off, int len) | 将字符读入数组的一部分               |
| void | close()                             | 关闭流并释放与之相关联的任何系统资源 |

#### FileReader

> java.io.FileReader：文件字符输入流，从文件中读取字符数据

##### 构造方法

| 构造器                      | 描述                                             |
| --------------------------- | ------------------------------------------------ |
| FileReader(File file)       | 创建一个新的 FileReader ，给出 File读取          |
| FileReader(String fileName) | 创建一个新的 FileReader ，给定要读取的文件的名称 |

**字符流只能用于操作纯字符数据，一般对于数据的读写，能够通过字节流实现的，一般都使用字节流。 万物皆字节**

### 转换流

> 通过**编码表**实现字符和字节之间的相互转换

#### InputStreamReader

> java.io.InputStreamReader：字节转字符输入流，是从字节流到字符流的桥梁，它读取字节，并使用指定的编码表将其**解码**为字符。编码表可以指定，如果不指定则使用平台默认码表

##### 构造方法

+ InputStreamReader(InputStream in, String charsetName) 创建一个使用命名字符集的InputStreamReader
	+ InputStream in：用于从文件中读取字节，然后交给转换流转换为字符数据。
	+ String charsetName：编码表的名字

#### OutputStreamWriter

> java.io.OutputStreamWriter：字符转字节输出流，是从字符流到字节流的桥梁。使用指定的编码表将写入的字符**编码**为字节。编码表可以指定，如果不指定则使用平台默认码表

##### 构造方法

| 构造器                                                   | 描述                                       |
| -------------------------------------------------------- | ------------------------------------------ |
| OutputStreamWriter(OutputStream out, String charsetName) | 创建一个使用命名字符集的OutputStreamWriter |
| OutputStream out                                         | 将转换流转换的字节数据写入到指定的文件中   |
| String charsetName                                       | 编码表的名字                               |

【**当读写数据时，使用的码表不统一时使用**】

### 字符缓冲流

【**循环结束标志为null**】

#### BufferedWriter

> java.io.BufferedWriter: 字符输出缓冲流。将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入

##### 构造方法

| 构造器                             | 描述                                                 |
| ---------------------------------- | ---------------------------------------------------- |
| BufferedWriter(Writer out)         | 创建使用默认大小的输出缓冲区的缓冲字符输出流         |
| BufferedWriter(Writer out, int sz) | 创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区 |

##### 特有成员方法

| 类型 | 方法      | 描述           |
| ---- | --------- | -------------- |
| void | newLine() | 写一行行分隔符 |

#### BufferedReader

> java.io.BufferedReader: 字符输入缓冲流。从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取

##### 构造方法

| 构造器                            | 描述                                         |
| --------------------------------- | -------------------------------------------- |
| BufferedReader(Reader in)         | 创建使用默认大小的输入缓冲区的缓冲字符输入流 |
| BufferedReader(Reader in, int sz) | 创建使用指定大小的输入缓冲区的缓冲字符输入流 |

##### 特有成员方法

| 类型   | 方法       | 描述       |
| ------ | ---------- | ---------- |
| String | readLine() | 读一行文字 |

+ 当一个流的构造方法中需要一个流的时候，被传进来的流叫做"节点流"
+ 外部负责包装的流叫做“包装流”、“处理流”
+ 对于包装流来说，只需要关闭最外层的流就行，里面的节点流会自动关闭

### Properties

​	java.util.Properties：属性集，表示一组持久的属性。实现集合的持久保存

​	Properties可以保存到流中或从流中加载。通过输出流将集合中的数据写到文件中，通过输入流将文件中的数据读取到集合中。
​	属性列表中的每个键及其对应的值都是一个字符串

#### 特有成员方法

| 类型         | 方法                                  | 描述                             |
| ------------ | ------------------------------------- | -------------------------------- |
| Object       | setProperty(String key, String value) | 调用 Hashtable 方法 put          |
| String       | getProperty(String key)               | 使用此属性列表中指定的键搜索属性 |
| Set\<String> | stringPropertyNames()                 | 相当于map集合中的keySet()方法    |

#### 和流相关的方法

| 类型 | 方法                                     | 描述                                           |
| ---- | ---------------------------------------- | ---------------------------------------------- |
| void | store(OutputStream out, String comments) | 通过指定字节输出流，将集合中的数据写到文件中   |
| void | store(Writer writer, String comments)    | 通过指定字符输出流，将集合中的数据写到文件中   |
| void | load(InputStream inStream)               | 通过指定的字节输入流将文件中的数据读取到集合中 |
| void | load(Reader reader)                      | 通过指定的字符输入流将文件中的数据读取到集合中 |

### 序列化和反序列化流

>  通过IO流实现对象的持久保持

```
序列化和反序列化
序列化：将数据结构转换称为二进制数据流或者文本流的过程。序列化后的数据方便在网络上传输和在硬盘上存储。
反序列化：与序列化相反，是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程。
```

【**注意事项**】

1. 当类实现了Serializable接口（标志性接口）之后，在类中会隐式存在一个变量SerialVersionUID	private static final long serialVersionUID = 1L;
2. serialVersionUID的值是根据类中的成员计算的
3. 当对象被序列化时，会绑定当前的serialVersionUID
4. 当反序列化时，会检测对象身上的UID变量和类中的UID变量是否一致
5. 手动赋值，就不会随着类中的成员计算结果
6. 静态和瞬态（transient）修饰的成员变量不会被序列化

#### ObjectOutputStream

> java.io.ObjectOutputStream：将Java对象的基本类型和引用类型数据，写入到 OutputStream 。

+ 可以使用ObjectInputStream读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。
+ **只有支持java.io.Serializable接口的对象才能写入流中**。每个可序列化对象的类被编码
+ java.io.Serializable:标记型接口。
+ **在序列化时，一般情况下一个文件中只会序列化一种类型的数据，方便后期对数据的反序列化操作**

##### 构造方法

| 构造器                               | 描述                                               |
| ------------------------------------ | -------------------------------------------------- |
| ObjectOutputStream(OutputStream out) | 创建一个写入指定的OutputStream的ObjectOutputStream |

##### 成员方法

| 类型 | 方法                    | 描述                               |
| ---- | ----------------------- | ---------------------------------- |
| void | writeObject(Object obj) | 将指定的对象写入ObjectOutputStream |

#### ObjectInputStream

> java.io.ObjectInputStream：ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象

##### 构造方法

| 构造器                            | 描述                                           |
| --------------------------------- | ---------------------------------------------- |
| ObjectInputStream(InputStream in) | 创建从指定的InputStream读取的ObjectInputStream |

##### 成员方法

| 类型   | 方法         | 描述                            |
| ------ | ------------ | ------------------------------- |
| Object | readObject() | 从ObjectInputStream读取一个对象 |

### 打印流

> java.io.PrintStream: 打印流中的方法没有异常

#### 构造方法

| 构造器                       | 描述                                         |
| ---------------------------- | -------------------------------------------- |
| PrintStream(String fileName) | 使用指定的文件名创建新的打印流，无需自动换行 |

### 随机流

> java.io.RandomAccessFile: 该类的实例支持**读取和写入**随机访问文件

随机访问文件的行为类似于存储在文件系统中的大量字节。 有一种游标，或索引到隐含的数组，称为文件指针 ; 输入操作读取从文件指针开始的字节

#### 构造方法

| 构造器                                     | 描述                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| RandomAccessFile(File file, String mode)   | 创建一个随机访问文件流，从File参数指定的文件读取，并可选地写入 |
| RandomAccessFile(String name, String mode) | 创建随机访问文件流，以从中指定名称的文件读取，并可选择写入文件 |

#### 成员方法

| 类型 | 方法           | 描述                                                       |
| ---- | -------------- | ---------------------------------------------------------- |
| void | seek(long pos) | 设置文件指针偏移，从该文件的开头测量，发生下一次读取或写入 |

### 字节流字符流总结

#### 字节流

```
InputStream 抽象类，输入字节流的顶层父类
	|-- FileInputStream 输入流，从系统中获取字节数据到java程序中
		|-- BufferedInputStream 缓冲输入流
	|-- ObjectInputStream 对先前使用ObjectOutputStream编写的原始数据和对象进行反序列化
	|--SequenceInputStream 按顺序读取枚举生成的输入流, 合并流
OutputStream 抽象类，输出字节流的顶层父类
	|--FileOutputStream 输出流，把字节数据通过java程序写入系统
		|--BufferedOutputStream 缓冲输出流
	|--ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream进行序列化
```

#### 字符流

```
Reader 读取字符流的顶层抽象父类
	|-- InputStreamReader (byte->char 桥梁）从字节流到字符流的桥接器
		|--FileReader 使用默认缓冲区大小从字符文件中读取文本
|-- BufferedReader 从字符输入流中读取文本，缓冲字符
Writer 用于写入字符流的顶层抽象父类
	|-- OutputStreamWriter (char->byte 桥梁）从字符流到字节流的桥接器
		|--FileWriter 使用默认缓冲区大小将文本写入字符文件
	|-- BufferedWriter 将文本写入字符输出流，缓冲字符
```

**字符流 依赖于 字节流 + 编码集**

## Thread多线程

### 基础内容

#### 并行和并发

+ 并行：多个任务在**同一个时刻点**，同时执行，效率高
+ 并发：多个任务在**同一段时间内**，分时执行，效率低

#### 进程和线程

+ 进程：内存中正在运行的应用程序。是系统进行资源分配和调度的基本单位，是操作系统结构的基础
+ 线程：进程中的独立执行单元，每一个线程就是进程中的一个子任务。是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位

#### 多线程和主线程

+ 多线程：在一个进程中，允许同时开启多个线程。提高程序的执行效率。程序执行过程中，哪个线程发生了异常，哪个线程结束，没有发生异常的线程可以正常执行
+ 主线程：负责应用程序运行入口的线程。main()是程序的运行入口，java中的主线程就是main线程

#### 线程的调度

+ 分时调度：每个任务平均分配执行时间。
+ 时间片抢占式调度：每个线程会抢夺CPU的执行权，谁抢到谁执行。

【**java中每加载一个类时，都会分配一个独立的JVM**】

### 获取类路径下文件的绝对路径

```
String path = Thread.currentThread().getContextClassLoader().getResource().getPath();
当前线程.当前线程的类加载器对象.当前线程的类加载器默认从类的根路径下加载资源

InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream();
```

### 资源绑定器

```
只能绑定xxx.properties文件并且只能在类路径下
ResourceBundle bundle = ResourceBundle.getBundle("xxx");//不用写文件扩展名  
```

### 线程

​	java.lang.Thread：是程序中执行的线程。Java虚拟机允许应用程序同时执行多个执行线程

#### 线程的细节

1. 线程都有优先级：1[低] - 10[高]，创建线程对象时，默认的优先级是5。优先级越高，被执行的几率越高
2. 线程分为：用户线程[默认]，守护线程[用于服务用户线程]
	1. 用户线程[默认]：执行完线程的任务后会自动死亡
	2. 守护线程[设置]：用于服务用户线程，当程序中没有可执行的用户线程时，守护线程自动死亡，垃圾回收线程和日志文档是守护线程
3. 线程有名字，默认名：Thread-x，x从0开始，逐一增加

【**在java中每一个线程会独立的分配一个栈内存（栈内存独立），堆内存和方法区内存被所有的线程对象共享**】

#### 构造方法

| 构造器                | 描述                   |
| --------------------- | ---------------------- |
| Thread（String name） | 分配一个新的Thread对象 |

#### 成员方法

| 类型          | 方法                         | 描述                                                         |
| ------------- | ---------------------------- | ------------------------------------------------------------ |
| void          | run()                        | 用来定义线程执行的任务，需要多线程执行的代码，都要定义在run()中 |
| void          | start()                      | 导致此线程开始执行; Java虚拟机调用此线程的run方法。**只能被调用一次** |
| String        | getName()                    | 获取此线程的名称                                             |
| void          | setName(String name)         | 设置线程名称为参数name                                       |
| static Thread | currentThread()              | 获取当前线程对象，出现在哪就获取的是哪个线程                 |
| int           | getPriority()                | 返回此线程的优先级                                           |
| void          | setPriority(int newPriority) | 更改此线程的优先级                                           |
| static void   | sleep(long millis)           | 使当前正在执行的线程停留（暂停执行）指定的毫秒数             |
| static void   | yield()                      | 对调度程序的一个暗示，即当前线程愿意让出当前处理器的执行权，然后再和其他线程抢夺执行权 |
| void          | join()                       | 等待这个线程死亡                                             |
| void          | join(long millis)            | 此线程最多等待millis毫秒                                     |
| void          | join(long millis,int nanos)  | 此线程最多等待millis毫秒加上nanos纳秒。当调用此方法的线程指定的时间内，没有执行完线程任务，那么其他线程则不再等待，开始抢夺执行权 |
| void          | setDaemon(boolean on)        | 将此线程标记为 daemon线程或用户线程                          |
| boolean       | isDaemon()                   | 测试这个线程是否是守护线程                                   |

#### 创建线程的方式

##### 继承Thread类

1. 声明一个类继承Thread
2. 子类重写run（）方法
3. 创建子类的对象
4. 启动线程

##### 实现Runnable接口

1. 声明Runnable接口实现类
2. 实现类重写run（）方法
3. 创建实现类对象
4. 创建Thread对象，传递实现类对象
5. 启动线程

##### 实现Callable接口（JDK5）

1. 创建FutureTask对象，参数给一个Callable接口实现类对象
2. 创建线程对象，传入FutureTask对象
3. 线程对象调用get（）方法

**区别：**可以获得执行结果，效率比较低，会导致当前线程阻塞

java.lang.Runnable: Runnable接口可以由任何类实现，其实例将由线程执行。**线程任务接口，通过重写run()方法来指定线程的任务，然后将任务交给Thread对象去执行**

##### 实现Runnable接口的好处

1. 打破了java的单继承性，通过实现不影响当前实现类去继承父类
2. 实现了线程任务和线程对象的解耦
3. 更有利于数据的共享操作

【**面试题**】：在创建匿名线程时同时使用两种方法，只会执行继承方法

#### 线程安全问题

多线程操作共享的数据，因为线程之间对共享数据的抢夺，造成的数据安全

**`synchronized`出现在静态方法上找类锁**

**造成多线程安全问题的必要因素**：有多条线程在操作（更新）共享的数据，且执行共享数据的操作语句不止一条

**如果加了同步之后依然有安全问题**：1.锁不唯一  2.同步代码中没有包含所有操作共享数据的代码

1. 同步代码块

	```
	synchronized（锁对象[任意且唯一]）{
		操作共享数据的代码；
	}
	```

2. 同步方法：使用同步关键字synchronized修饰的方法

	```
	public [static] synchronized 返回值 methodName(形参) {
		操作共享数据的代码；
	}//【当方法中所有的代码，都是操作共享数据的代码时，再使用同步方法】
	```

3. Lock锁接口

**解决线程安全问题**

1. 尽量使用局部变量代替实例变量和静态变量
2. 如果是实例变量，可以考虑创建多个对象
3. 以上两种都不能使用时只能选择`synchronized`

##### 同步的好处和弊端

1. 使用同步会影响程序的执行效率。每次CPU运行到同步代码时，都需要去判断有没有线程在同步代码中，如果有就只能等待同步代码中的线程执行结束
2. 保证数据安全

### 死锁

线程的任务还没有执行结束，但是线程对象基于某些特殊的原因，无法继续执行任务。导致程序出现阻塞的状态

### 线程状态

1. 新建状态：创建了线程的对象，但是没有调用start()启动线程
2. 运行状态：调用了start()并且当前线程具备CPU的执行权利
3. 阻塞状态[就绪状态]：调用了start()但是当前线程只具备CPU的执行资格，不具备执行权利
4. 睡眠状态：调用了wait(time)，时间到了之后自然从睡眠状态中退出
5. 等待状态：调用了wait()，通过其他线程调用notify或notifyAll方法唤醒
6. 死亡状态：a）线程任务结束    b）线程异常    c）调用方法结束

![多线程](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png)

### 等待和唤醒

| 类型 | 方法        | 描述                                                         |
| ---- | ----------- | ------------------------------------------------------------ |
| void | wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |
| void | notify()    | 唤醒正在等待对象监视器的单个线程                             |
| void | notifyAll() | 唤醒正在等待对象监视器的所有线程                             |

【**上述三个方法必须由锁对象来调用**】

#### 简述sleep()和wait()有什么区别

1. sleep是Thread类中的方法，可以让当前正在执行的线程休眠，休眠时间结束后会重新进入可运行状态，sleep方法在休眠时不会放开对象的互斥锁sleep()方法是在休眠指定的时间后会重新进入可运行状态(Runnable)，wait()方法是会进入阻塞状态，需要通过代码如notify()，notifyAll()来将其唤醒才能重新进入可运行状态(Runnable)
2. sleep()方法在休眠时不会放开对象的互斥锁，而wait()方法在阻塞时会放开互斥锁
3. sleep()方法来自Thread类，wait()方法是来自Object类的方法
4. 使用范围有不同，sleep()方法可以在任意地方使用，而诸如wait()、notify()、notifyAll()等方法只能用在同步代码块或同步方法里
5. sleep()必须捕获异常，而wait()无需捕获异常

### Lock接口

​	Lock锁是JDK5的新特性	

+ **Lock替代synchronized方法和语句的使用， Condition 替代了使用对象监视器方法**将代码的同步和等待唤醒机制进行了解耦

+ **当程序中使用了线程的通信时，一般使用Lock接口，如果只是为了保证代码同步，之间使用同步语句或方法**

#### Lock

​	java.util.concurrent.locks.Lock：主要负责代码的同步

##### 成员方法

| 类型      | 方法           | 描述                                    |
| --------- | -------------- | --------------------------------------- |
| void      | lock()         | 获得锁                                  |
| void      | unlock()       | 释放锁                                  |
| Condition | newCondition() | 返回一个新Condition绑定到该实例Lock实例 |

```
Lock l = ...;
l.lock();
try{
	
}finally{
	l.unlock();//放在finally代码块中保证一定会执行
}
```

#### Condition

​	java.util.concurrent.locks.Condition：主要负责线程的通信，等待和唤醒的操作

##### 成员方法

+ void await() 导致当前线程等到发信号或 interrupted 
+ void signal() 唤醒一个等待线程
+ void signalAll() 唤醒所有等待线程

### 线程池

​	保存线程对象的容器，池中的线程对象可以复用

【**好处**】：1. 降低了系统资源的消耗    2. 提高响应的速度    3. 通过线程池统一管理所有线程对象

#### 线程池的使用步骤

1. 创建线程池对象 --> 线程池中就已经存在了线程对象
	+ java.util.concurrent.Executor:线程池的顶层父接口，但是开发中一般不直接使用
	+ java.util.concurrent.ExecutorService:真正使用的线程池接口
	+ java.util.concurrent.Executors:线程池工厂类，专门用于生产线程池的工具类
		+ static ExecutorService newFixedThreadPool(int nThreads) 创建一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程
	
2. 执行线程的任务

  | 类型         | 方法                  | 描述                                                         |
  | ------------ | --------------------- | ------------------------------------------------------------ |
  | <T>Future<T> | submit(Runnable task) | 提交一个可运行的任务执行，并返回一个表示该任务的未来         |
  | void         | shutdown()            | 启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务 |

```java
ExecutorService ex = Executors.newFixedThreadPool(2);
MyRunnable mr = new MyRunnable();
ex.submit(mr);
ex.shutdown();
```

### ThreadLocal

> ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问（通过get和set方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型，用于关联线程和线程上下文

**作用：**提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。

```
1.线程并发：在多线程并发的场景下
2.传递数据：可以通过ThreadLocal在同一线程，不同组件中传递公共变量，避免参数直接传递带来的代码耦合问题
3.线程隔离：每个线程的变量都是独立的，不会相互影响，各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失
```

#### ThreadLocal和synchronized的区别

|        | synchronized                                                 | ThreadLocal                                                  |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原理   | 同步机制采用“以时间换空间”的方式，只提供一份变量，让不同的线程排队访问 | ThreadLocal采用“以空间换时间”的方式，为每一个线程都提供了一份变量的副本，从而实现同时访问而相不干扰 |
| 侧重点 | 多个线程之间访问资源的同步                                   | 多线程中让每个线程之间的数据相互隔离                         |

#### ThreadLocal的设计

1. 每个Thread线程内部都有一个Map（ThreadLocalMap）
2. Map里面存储ThreadLocal对象（key）和线程的变量副本（value）
3. Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值
4. 对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰

##### JDK8设计方案两个好处

+ 每个Map存储的Entry数量减少
+ 当Thread销毁的时候，ThreadLocalMap也会随之销毁，减少内存的使用

#### ThreadLocal核心方法

| 类型        | 方法           | 描述                         |
| ----------- | -------------- | ---------------------------- |
| protected T | initialValue() | 返回当前线程局部变量的初始值 |
| public void | set(T value)   | 设置当前线程绑定的局部变量   |
| public T    | get()          | 获取当前线程绑定的局部变量   |
| public void | remove()       | 移除当前线程绑定的局部变量   |

##### 源码执行流程

+ set
	+ 首先获取当前线程，并根据当前线程获取一个Map
	+ 如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）
	+ 如果Map为空，则给该线程创建Map，并设置初始值
+ get
	+ 首先获取当前线程，根据当前线程获取一个Map
	+ 如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的Entry e，否则转到第四步
	+ 如果e不为null，则返回e.value，否则转到第四步
	+ Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map

**总结：**先获取当前线程的ThreadLocalMap变量，如果存在则返回值，不存在则创建并返回初始值

+ remove
	+ 首先获取当前线程，并根据当前线程获取一个Map
	+ 如果获取的Map不为空，则移除当前ThreadLocal对象对应的entry

### ThreadLocalMap源码分析

ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现![ThreadLocalMap基本结构](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/ThreadLocalMap%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png)

##### 为什么使用弱引用

在ThreadLocalMap中的set/getEntry方法中，会对key为null（即ThreadLocal为null）进行判断，如果为null的话，那么是会对value置为null的。

这就意味着使用完ThreadLocal，CurrentThread依然运行的前提下，就算忘记调用remove方法，弱引用比强引用多一层保障：弱引用的ThreadLocal会被回收，对应的value会在下一次ThreadLocalMap调用set、get、remove中任一方法的时候会被清除，从而避免内存泄漏

## 网络编程

### 网络三要素

#### IP地址

给网络中的每一台终端设备分配的唯一标识，通过IP能找到网络中的某一台指定的终端设备

#### 端口号

终端设备上每一个应用程序[进程]的唯一标识。 1-65535 , 1-1024 系统占用，网址的默认端口: 80 ，MySQL: 3306

#### 协议

+ 数据之间交互的规则
	+ TCP协议: 传输控制协议是一种**面向连接的、可靠的、基于字节流**的传输层通信协议。效率低，安全
	+ UDP协议: **无连接**的传输协议，该协议称为用户数据报协议。效率高，不安全

### 域名

​	一个网址，每一个域名都会对应一个IP地址

#### 域名解析

+ 当我们使用某一个域名去访问服务器时，需要先将域名解析为IP地址之后再去访问
	+ 本地域名解析
	+ DNS服务器域名解析

### InetAddress类

​	此类表示Internet协议（IP）地址

#### 成员方法

+ static InetAddress getByName(String host) 确定主机名称的IP地址
   + String host：a)ip地址   b)域名  c)主机名

+ static InetAddress[] getAllByName(String host) 给定主机的名称，根据系统上配置的名称服务返回其IP地址数组
+ String getHostAddress() 返回文本显示中的IP地址字符串
+ String getHostName() 获取此IP地址的主机名

### UDP编程

#### DatagramSocket

​	java.net.DatagramSocket: 此类表示用于发送和接收数据报数据包的套接字

##### 构造方法

+ DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口。【系统随机分配】
+ DatagramSocket(int port) 构造数据报套接字并将其绑定到本地主机上的指定端口

##### 发送的成员方法

+ void send(DatagramPacket p) 从此套接字发送数据报包

##### 接收的成员方法

+ void receive(DatagramPacket p) 从此套接字接收数据报包

##### 成员方法

+ InetAddress getInetAddress() 返回此套接字连接到的地址

#### DatagramPacket

java.net.DatagramPacket:该类表示数据报包。用于封包和拆包的对象

##### 封包构造方法

+ DatagramPacket(byte[] buf, int length, InetAddress address, int port)：构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号
	+ byte[] buf:发送的数据
	+ int length:数据的长度
	+ InetAddress address:接收端IP对象
	+ int port:接收端的端口号

##### 拆包构造方法

+ DatagramPacket(byte[] buf, int length) 构造一个 DatagramPacket用于接收长度为 length数据包
	+ byte[] buf: 保存拆包后的数据
	+ int length: 容器的长度

##### 构造方法

+ byte[] getData() 返回数据缓冲区
+ int getLength() 返回要发送的数据的长度或接收到的数据的长度

### TCP编程

发送端：客户端，给服务端发送数据的过程叫做请求

接收端：服务端，给客户端发送数据的过程叫做响应

#### Socket

​	java.net.Socket：该类实现**客户端**套接字。 套接字是两台机器之间通讯的端点

##### 构造方法

+ Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号
	+ String host:访问的服务端的IP信息	a)IP地址	b）域名	c）主机名
	+ int port:服务端的端口号

##### 成员方法

+ OutputStream getOutputStream() 返回此套接字的输出流
+ InputStream getInputStream() 返回此套接字的输入流
+ InetAddress getInetAddress() 返回套接字所连接的地址
+ int getPort() 返回此套接字连接到的远程端口号

#### ServerSocket

java.net.ServerSocket:这个类实现了**服务器**套接字，服务器套接字等待通过网络进入的请求。它根据该请求执行一些操作，然后可能将结果返回给请求者

##### 构造方法

+ ServerSocket(int port) 创建绑定到指定端口的服务器套接字

##### 成员方法

+ Socket accept() 侦听要连接到此套接字并接受它

### 文件名重名解决方案

1. 系统时间和随机数组合实现命名

	```java
	long fileName = System.currentMillis() + new Random().nextInt();
	```

2. 使用UUID工具实现命名

	```java
	String fileName = UUID.randomUUID().toString().replace("-","");
	```

3. 使用IP实现命名

	```java
	String fileName = socket.getInetAddress().getHostAddress();//获取IP地址
	File file = new File("d:\\");//创建File对象
	int name = 1;//声明变量迭代文件名
	while(file.exists()){
		file = new File("d:\\" + fileName + "(" +name + ")");
		name++;
	}
	FileOutputStream fos = new FileOutputStream(file);
	```

#### UUID

java.util.UUID:一个表示不可变的通用唯一标识符（UUID）的类。 UUID表示128位值。

##### 成员方法

 + static UUID.randomUUID() 静态工厂检索一个类型4（伪随机生成）的UUID
 + String toString() 返回一个表示 UUID的 String对象

### URL

java.net.URL :URL代表统一资源定位符，指向互联网上**资源**的指针。资源可以是文件或目录，或者可以是对更复杂的对象的引用，例如对数据库或搜索引擎的查询

#### 构造方法

+ URL(String spec) 从 String表示中创建一个 URL 对象

#### 成员方法

+ URLConnection openConnection() 返回一个URLConnection实例表示由所引用的远程对象的连接URL

#### URLConnection

​	java.net.URLConnection：抽象类URLConnection是表示应用程序和URL之间的通信链接的所有类的超类。该类的实例可以用于从URL引用的资源中读取和写入

##### 成员方法

+ InputStream getInputStream() 返回从此打开的连接读取的输入流

## Lambda表达式

> JDK8最重要的新特性之一。可以用于优化函数式接口的**匿名内部类**使用，写出更简洁的java代码

【**本质**】：重写函数式接口中的抽象方法

【**函数式接口**】：有且仅有一个**抽象方法**的接口

### Lambda语法

```java
()->{}
():抽象方法的参数列表[形参]
->:传递
{}:重写抽象方法的方法体
```

**优化**

```java
优化Lambda表达式	::表示引用方法
对象||类名||this||super||new::方法名;
1.函数式接口中只有一个参数
2.{}中只有一条语句，且是通过方法在操作唯一参数
```

### Lambda表达式省略格式

1. ()中的数据类型可以省略
2. ()中只有一个参数时，()可以省略
3. {}中只有一条语句时，{} return ;可以省略，但是必须同时省略

### 常用的函数式接口

+ java.lang.Runnable:线程任务接口。 Thread()构造方法    Executor线程池 submit();
+ java.util.FilenameFilter:文件名过滤接口。File类 listFiles()
+ java.util.FileFilter:文件对象过滤器接口。File类 listFiles()
+ java.util.Comparator:比较器接口。 TreeSet TreeMap Arrays.sort() Collections.sort()

## Stream API

java.util.stream.Stream\<T>：支持顺序和并行聚合操作的一系列元素 ---> 数组和集合

### 常用函数式接口

#### java.util.function.Predicate\<T>判断型接口

##### 抽象方法

| 类型    | 方法      | 描述                       |
| ------- | --------- | -------------------------- |
| boolean | test(T t) | 在给定的参数上评估这个谓词 |

##### 成员方法

| 类型            | 方法                                  | 描述                               |
| --------------- | ------------------------------------- | ---------------------------------- |
| default boolean | removeIf(Predicate<? super E> filter) | 删除满足给定谓词的此集合的所有元素 |

#### java.util.function.Supplier\<T>生产型接口

##### 抽象方法

| 类型 | 方法  | 描述     |
| ---- | ----- | -------- |
| T    | get() | 获得结果 |

#### java.util.function.Consumer\<T>消费型接口

##### 抽象方法

| 类型 | 方法        | 描述                   |
| ---- | ----------- | ---------------------- |
| void | accept(T t) | 对给定的参数执行此操作 |

#### java.util.function.Function<T,R>转换型接口

##### 抽象方法

| 类型 | 方法       | 描述                                                       |
| ---- | ---------- | ---------------------------------------------------------- |
| R    | apply(T t) | 将此函数应用于给定的参数。将T类型的数据，转换为R类型的数据 |

### Stream流对象的获取

#### 集合

+ Collection单列集合可以直接获取流，双列集合需要先转化为单列集合后，再获取Stream流对象

| 类型               | 方法     | 描述                                 |
| ------------------ | -------- | ------------------------------------ |
| default Stream\<E> | stream() | 返回一个序列Stream与此集合作为其来源 |

#### 数组

**Arrays** 数组工具类

| 类型                   | 方法                                  | 描述                                     |
| ---------------------- | ------------------------------------- | ---------------------------------------- |
| static \<T> Stream\<T> | stream(T[] array)                     | 返回具有指定数组的序列Stream作为其来源   |
| static \<T> Stream\<T> | stream(T[] array, int start, int end) | 返回指定数组的指定范围作为源的顺序Stream |

#### Stream接口

| 类型                   | 方法            | 描述                           |
| ---------------------- | --------------- | ------------------------------ |
| static \<T> Stream\<T> | of(T t)         | 返回包含单个元素的序列 Stream  |
| static \<T> Stream\<T> | of(T... values) | 返回其元素是指定值的顺序排序流 |

### Stream流常用方法：终结方法和延迟方法

| 类型                   | 方法                                                 | 描述                                                         |
| ---------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| void                   | forEach(Consumer<? super T> action)                  | 对此流的每个元素执行操作                                     |
| Stream\<T>             | filter(Predicate<? super T> predicate)               | 返回由与此给定谓词匹配的此流的元素组成的流                   |
| long                   | count()                                              | 返回此流中的元素数                                           |
| Stream\<T>             | limit(long maxSize)                                  | 返回由此流的元素组成的流，截短长度不能超过 maxSize（参数大于流中的元素个数：截取所有数据；0:截取0个；负数：报错） |
| Stream\<T>             | skip(long n)                                         | 在丢弃流的第一个 n元素后，返回由该流的剩余元素组成的流（参数大于流中的元素个数: 跳过所有 0个；0: 跳过0个，获取所有；负数：报错） |
| static\<T> Stream\<T>  | concat(Stream<? extends T> a, Stream<? extends T> b) | 创建一个懒惰连接的流，其元素是第一个流的所有元素，后跟第二个流的所有元素 |
| \<R>  Stream\<R>       | map(Function<? super T,? extends R> mapper)          | 返回由给定函数应用于此流的元素的结果组成的流                 |
| Stream\<T>             | distinct()                                           | 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流【**去重**】 |
| static \<T> Stream\<T> | generate(Supplier<? extends T> s)                    | 返回无限顺序无序流，其中每个元素由提供的 Supplier生成        |
| Optional\<T>           | max(Comparator<? super T> comparator)                | 根据提供的 Comparator返回此流的最大元素                      |
| Optional\<T>           | min(Comparator<? super T> comparator)                | 根据提供的 Comparator返回此流的最小元素                      |
| Stream\<T>             | sorted()                                             | 返回由此流的元素组成的流，根据自然顺序排序                   |
| Stream\<T>             | sorted(Comparator<? super T> comparator)             | 返回由该流的元素组成的流，根据提供的 Comparator进行排序      |
| boolean                | allMatch(Predicate<? super T> predicate)             | 返回此流的所有元素是否与提供的谓词匹配                       |
| boolean                | anyMatch(Predicate<? super T> predicate)             | 返回此流的任何元素是否与提供的谓词匹配                       |
| boolean                | noneMatch(Predicate<? super T> predicate)            | 返回此流的元素是否与提供的谓词匹配                           |
| default Stream\<T>     | dropWhile(Predicate<? super T> predicate)            | 根据条件删除流中的数据，直到遇到第一个不满足条件的数据开始停止删除 |
| default Stream\<T>     | takeWhile(Predicate<? super T> predicate)            | 根据条件保留流中的数据，直到遇到第一个不满足条件的数据开始停止保留 |
| <R,A> R                | collect(Collector<? super T,A,R> collector)          | 使用 Collector对此流的元素执行 mutable reduction操作         |
| Object[]               | toArray()                                            | 返回一个包含此流的元素的数组                                 |
| \<A> A[]               | toArray(IntFunction<A[]> generator)                  | 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组 |

+ java.util.stream.Collector<T,A,R>: 收集器对象

+ java.util.stream.Collectors:收集器对象的工厂类。 toSet()   toList()

	```java
	Stream<String> stream = Stream.of("10", "20", "30", "40", "50");
	List<String> list = stream.collect(Collectors.toList());
	Set<String> set = stream.collect(Collectors.toSet());
	```

### 并发流

1. 直接获取并发流 Collection
  + default Stream\<E> **parallelStream**()返回可能并行的Stream与此集合作为其来源
2. 转换为并发流 BaseStream
	+ S **parallel**() 返回平行等效流

## 枚举

JDK5新特性，是一种特殊的类。可以优化多例设计模式

```
public enum EnumName{
	常量对象 ---> 多例类中的多个对象
	成员变量[静态/非静态]
	成员方法[静态/非静态]
	构造方法[默认私有]
	构造代码块
	静态代码块
	内部类[静态/非静态]
}
```

【**枚举对象的获取方式**】：枚举名.常量对象名

【**注意事项**】：

1. 常量对象必须声明在成员位置的第一行
2. 枚举构造方法默认私有，只能通过枚举名.成员对象名的方式获取枚举的对象
3. 枚举对象的使用方式和普通类的对象使用方式完全相同
4. 枚举类中有抽象方法时，枚举类不能声明为抽象类，只需要对象去重写抽象方法即可
5. 枚举类有一个共同的父类 --> Enum

【**经验**】：每个对象实现需求不一样

1. 让子类重写方法
2. 通过变量进行控制

【**经验**】：抽象类不能创建对象该怎么用

```
new 匿名子类对象(){}
```

### java.lang.Enum\<E>

​	这是所有Java语言枚举类型的公共基类

#### 成员方法

+ String toString() 返回声明中包含的此枚举常量的名称
+ String name() 返回此枚举常量的名称，与其枚举声明中声明的完全相同
+ int ordinal() 返回此枚举常数的序数（其枚举声明中的位置，其中初始常数的序数为零）
+ int compareTo(E o) 将此枚举与指定的对象进行比较

## 注解

JDK5新特性，是一种特殊的接口，代码级别的解释说明，给JVM看的

### 常用注解

+ @override ：声明在方法上，检测被注解的方法是否为重写的方法
+ @FunctionalInterface ： 声明在接口上,检测被注解的接口是否为函数式接口
+ @Deprecated ：标记当前方法已经过时
+ @SuppressWarnings：抑制警告，让编译器不要报出警告信息

```java
//注解定义格式
public @interface AnnotationName{
	//成员变量
    数据类型 变量名();
    数据类型 变量名() default 值;
}
```

【**注解使用格式**】：注解名（变量名 = 值，变量名 = 值...）

【**注解使用场景**】：类、接口、枚举、注解、构造方法、成员方法、成员变量、局部变量、形参...

【**注意事项**】：

1. 如果变量没有默认值，在使用时，必须赋值
2. 如果变量声明时有默认值，那么可以直接使用
3. 注解中只有一个变量且变量名叫value时，在使用时可以省略变量名
4. 注解中的数据类型：八大基本类型、String、枚举、注解、Class、以及对应的一维数组

### 元注解

+ Target：设置注解的使用目标
	+ ElementType.TYPE：类、接口、注解、枚举
	+ ElementType.FIELD
	+ ElementType.CONSTRUCTOR
	+ ElementType.METHOD

+ Retention：设置注解的生命周期
	+ SOURCE
	+ CLASS
	+ RUNTIME

## Junit

> 用于测试程序，替代main方法让程序运行

【**jar包**】：指的是java成员压缩之后产生的文件，添加后可以直接使用jar包中的java程序

+ @Test: 只能用于测试，公开的无参无返回值的方法
+ @After:在每个Test注解方法执行结束都会执行一次。[会多次执行]
+ @Before:在每个Test注解的方法执行之前，都会执行一次。[会多次执行]
+ @AfterClass:类中所有的方法执行结束之后，执行一次。[只执行一次]
+ @BeforeClass:类中的所有方法执行之前，执行一次。[只执行一次]

【**黑盒测试**】：只关注结果是否满足客户的需求，不关注实现的过程

【**白盒测试**】：只关注程序的实现过程，不关注是否满足客户的需求

## 类加载器

> 专门负责加载类的命令/工具	ClassLoader

+ 启动类加载器（父）
+ 扩展类加载器（母）
+ 应用类加载器

1. 首先通过`启动类加载器`加载，`启动类加载器`专门加载jre/lib/rt.jar，这个jar包下都是JDK最核心的类库
2. `启动类加载器`加载不到时，会通过`扩展类加载器`加载，专门加载jre/lib/ext下的所有jar包
3. `扩展类加载器`加载不到时，会通过`应用类加载器`加载，专门加载classpath中的jar包（class文件）

## 反射

在程序的运行过程中可以加载使用编译时期不知道的类型

### 反射使用步骤

1. 获取类的Class对象
2. 获取类的成员对象
3. 使用类的成员对象

**java.lang.Class\<T>**

Class类的实例表示正在运行的Java应用程序中的类和接口。枚举是一种类，注解是一种接口

每个数组也属于一个类，它被反映为具有相同元素类型和维数的所有数组共享的Class对象

原始Java类型 boolean byte char short int long float  double ，以及关键 void 也表示为Class对象

### Class 对象的获取方式

1. 通过对象的getClass()方法 --> Object 类  Class<?> getClass() 返回此 Object的运行时类
2. 通过数据类型的.class 属性获取
3. 通过Class类中forName()方法获取--> static Class<?> forName(String className) 返回与给定字符串名称的类或接口相关联的 Class对象

### 反射构造方法

| 类型             | 方法                                               | 描述                                                         |
| ---------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| Constructor\<T>  | getConstructor(Class<?>... parameterTypes)         | 返回一个 Constructor 对象，该对象反映由该 Class 对象表示的类的指定**公共构造函数** |
| Constructor<?>[] | getConstructors()                                  | 返回一个包含 Constructor 对象的数组， Constructor 对象反映了由该 Class 对象表示的类的所有**公共构造函数** |
| Constructor\<T>  | getDeclaredConstructor(Class<?>... parameterTypes) | 返回一个 Constructor 对象，该对象反映由此 Class 对象表示的类或接口的指定构造函数 |
| Constructor<?>[] | getDeclaredConstructors()                          | 返回反映由该 Class 对象表示的类声明的所有构造函数的 Constructor 对象的数组 |

**java.lang.reflect.Constructor\<T>**

Constructor 提供了一个类的单个构造函数的信息和访问权限

#### 成员方法

+ T newInstance(Object... initargs) （JDK9以后过时）
				使用由此 Constructor对象表示的构造函数，使用指定的初始化参数来创建和初始化构造函数的声明类的新实例（无参构造）

**java.lang.reflect.AccessibleObject**

所述AccessibleObject类是基础类Field， Method和Constructor对象（被称为反射的对象 ）。它可以将反射对象标记为在使用Java语言访问控制时抑制检查

#### 成员方法

+ void setAccessible(boolean flag) 将此反射对象的 accessible标志设置为指示的布尔值。 设为true可以访问私有

### 反射成员变量

| 类型    | 方法                          | 描述                                                         |
| ------- | ----------------------------- | ------------------------------------------------------------ |
| Field   | getField(String name)         | 返回一个 Field对象，该对象反映由该 Class对象表示的类或接口的**指定公共成员字段** |
| Field[] | getFields()                   | 返回一个包含 Field对象的数组， Field对象反映由该 Class对象表示的类或接口的所有可访问的公共字段 |
| Field   | getDeclaredField(String name) | 返回一个 Field对象，该对象反映由该 Class对象表示的类或接口的**指定声明字段** |
| Field[] | getDeclaredFields()           | 返回一个 Field对象的数组，反映了由该 Class对象表示的类或接口声明的所有字段 |

**java.lang.reflect.Field**

提供有关类或接口的单个字段的信息和动态访问，反射的字段可以是类（静态）字段或实例（非静态）字段。

#### 成员方法

+ void set(Object obj, Object value) 将指定的对象参数中由此 Field对象表示的字段设置为指定的新值
+ Object get(Object obj) 返回由该 Field表示的字段在指定对象上的值
	+ Object obj:当前非静态成员变量的所属对象
	+ Object value:成员变量的值

**【针对于类中静态的成员，对象的操作可以全部赋值为null】**

### 反射成员方法

| 类型     | 方法                                                       | 描述                                                         |
| -------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| Method   | getMethod(String name, Class<?>... parameterTypes)         | 返回一个 方法对象，该对象反映由该 Class对象表示的类或接口的指定公共成员方法 |
| Method[] | getMethods()                                               | 返回一个包含 Method 对象的数组， Method 对象反映由该 Class对象表示的类或接口的所有公共方法，<br/>		包括由类或接口声明的对象以及从超类和超级接口继承的方法 |
| Method   | getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回一个 方法对象，它反映此表示的类或接口的指定声明的方法 Class对象 |
| Method[] | getDeclaredMethods()                                       | 返回一个包含 Method 对象的数组，Method 对象反映由 Class对象表示的类或接口的所有声明方法，<br/>		包括public，protected，default（package）访问和私有方法，但不包括继承方法 |

**java.lang.reflect.Method**

方法在类或接口上提供有关单一方法的信息和访问权限。反映的方法可以是类方法或实例方法（包括抽象方法）

#### 成员方法

+ Object invoke(Object obj, Object... args) 在具有指定参数的指定对象上调用此 方法对象表示的基础方法
	+ 参数：
		+ Object obj：调用方法的对象
		+ Object... args：方法传递的实参
	+ 返回值：
		+ Object: 表示调用的方法，如果当前方法没有返回值，则返回null

### 反射注解步骤

1. 获取类的Class对象
2. 获取类的成员对象
3. 判断类的成员对象上是否存在指定的注解
4. 如果存在则获取注解的对象
5. 通过注解的对象访问注解的成员

**java.lang.reflect.AnnotatedElement**

​	表示当前在此JVM中运行的程序的注解元素。该接口允许反射读取注解

#### 成员方法

+ default boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)
		如果此元素上存在指定类型的注解，则返回true，否则返回false
+ \<T extends Annotation> T getAnnotation(Class\<T> annotationClass)
	    返回该元素的，如果这样的注解 ，否则返回null指定类型的注解

## Mysql数据库

+ DDL：数据定义语言 - Data Definition Language，用来定义数据库的对象，如数据表、视图、索引等。
+ DML：数据处理语言 - Data Manipulation Language，在数据库表中**更新**，增加和删除记录。
+ **DCL**：数据控制语言 – Data Control Language，指用于设置用户权限和控制事务语句。
+ DQL：数据查询语言 – Data Query Language，用于查询数据表中的数据，通过select关键字。

### 数据库操作步骤

1. 安装数据库软件

2. 开始数据库服务 --> 右击我的电脑--> 管理 --> 服务和应用程序 --> 服务 --> MySQL80 启动即可

3. 连接数据库软件 mysql -h[主机名] -P[端口] -u[用户名] -p[密码]

	+ mysql -uroot -p

4. 数据仓库操作

	+ show databases；//查看数据库软件中的所有数据仓库
	+ create database databaseName；//创建数据仓库
	+ create database databaseName character set 编码表名; // 创建数据仓库语法 指定编码信息
	+ create database databaseName character set 编码表名 collate 校对规则; // 创建数据仓库 指定编码信息校对的规则
	+ show create database databaseName; // 查看数据仓库的编码等相关信息
	+ select database(); // 查看所在的数据仓库
	+ **use databaseName;// 切换所在的数据仓库**
	+ alter database databaseName character set 编码表名;// 修改数据仓库的编码信息
	+ drop database databaseName; // 删除数据仓库

5. 数据表操作

	+ create table tableName( 列名 列类型(长度) 约束 , 列名 列类型 约束..... ); // 创建数据表
		+ 表单约束:保证表中数据的安全性和有效性。约束就是保存数据时需要遵守规则。
		+ 唯一约束: 列名 列类型 unique; //表示当前被约束列的值，唯一不能重复
		+ 非空约束: 列名 列类型 not null;//表示当前被约束列的值，不能为null
		+ 主键约束: 列名 列类型 primary key;// 效果相当于 唯一 + 非空，经常用于做多表外键。
					一般在类中添加一个和业务关联不密切的字段充当，一般为int 类型，主键名叫id。
		+ 自增长：用于整数类型，默认值1，逐一增加。每添加一个数据，结果会自动+1，一般结合主键一起使用。
					列名 列类型 auto_increment
		+ 默认值：在列类型或者约束后加上default值
	+ desc tableName; // 查看表结构
	+ show tables; // 查看所有表
	+ rename table 旧表名 to 新表名;//修改表名
	+ drop table tableName；//删除数据表（删除数据仓库也用drop）
	+ alter table 表名 add/modify/drop 列名 类型（长度） 约束 增加列/修改现有列类型、长度和约束/删除现有列
	+ alter table 表名 change 旧列名 新列名 类型（长度 ）约束  修改现有列名称

6. 表中数据的添加

	+ insert (into) tableName (列名,列名,列名...) values (值,值,值...); //当某列的值为自增长，或为null，或有默认值时可以省略
	+ insert (into) tableName values (值,值,值...)

7. 修改表中数据

	+ update tableName set 列名 = 值，列名 = 值... where 条件;【**一定要跟where子语句，给出修改的条件**】

8. 删除表中数据

	+ delete from tableName where 条件;【**一定要跟where子语句，给出修改的条件**】

		```
		【面试题】
		delete from tableName;// 删除表中的所有数据 逐行删除表中数据，效率低
		truncate table tableName;// 删除表中的所有数据 先删除表，创建一个新的空表，效率高
		```

9. 查询表中数据

	+ select * from tableName where 条件; // 查询表中的所有数据
	+ select 列名,列名.. from tableName where 条件; // 查询指定列的数据

10. 排序查询

	+ select * from 表名 order by 列名 asc|desc ;//根据列名升序降序排列

11. 别名

	+ select 列名 as 别名,列名 as 别名,列名 as 别名.... from 表名 where 条件;【**在使用别名的时候，as 关键字可以省略**】

		```
		【面试题】
		select age score from student;
		select age , score from student;
		第一个是给age起别名为score，第二个是查询age和score两列数据
		```

12. 排重查询

	+ select distinct 列名 from 表名 where 条件;

13. 截取查询

	+ select * from 表名 limit n; 	表示从0下表开始截取前N个数据
	+ select * from 表名 limit n , m;     表示从n下表开始截取m个数据，如果m超过最大下标，则返回n下标开始的所有数据。

### 运算符

+ **判断两个数据是否相等：** **相等=   不等 <>**

+ **逻辑运算：and 逻辑与&& or 逻辑或|| not 逻辑非!**

+ **区间判断：** **between ...and...** 在两者之间取值

+ **列表值取一：in(值,值,值)**

+ **模糊查询：like ' pattern'** 进行模糊查询 ，表达式有两个占位符： **%** 任意字符串 ， **_** 任意单个字符

	```
	name like '张%' 所有姓张学员    %张% 中间有张字的学员，字数不限制
	name like '张_' 所有姓张名字为两个字学员   _张_ 三字中间为张的学员
	```

+ **null空判断： is null** 判断该列值为空。  **is not null** 判断该列值不为空

+ **USING:**using等价于join中的on

	```mysql
	select a.name,b.age from test as a join test2 as b on a.id = b.id;
	#等价于
	select a.name,b.age from test as a join test2 as b using(id);
	```

### SQL中的函数

#### count函数

+ SELECT COUNT(*) FROM table；函数返回在给定的选择中被选的行数
+ SELECT COUNT(column) FROM table；COUNT 函数返回被选列中中不存在 NULL 值的行数
+ SELECT COUNT(DISTINCT column(s)) FROM table；可以一同使用 DISTINCT 和 COUNT 关键词，来计算非重复结果的数目

#### sum函数

+ SELECT SUM(column) FROM table；函数返回在给定的选择中一个列的总数，null值不统计

#### ifnull函数

- ifnull（列名，新值）；	如果为空就赋新值，新值只在sql语句中生效

#### avg函数

+ SELECT AVG(column) FROM table；函数返回被选列的平均值。NULL 值不包括在计算中

#### max、min函数

+ SELECT MAX(column) FROM table；函数返回一列中的最大值。NULL 值不包括在计算中
+ SELECT MIN(column) FROM table；函数返回一列中的最小值。NULL 值不包括在计算中

#### group by分组函数

+ SELECT column,SUM(column) FROM tableName GROUP BY column；
	把 GROUP BY 加入 SQL 的原因是，合计函数（比如 SUM）在每次被调用后会返回所有列的合计，如果没有 GROUP  BY，就无法计算每个单独列值组合的总和
+ 在 where 条件后面不可以跟聚合函数
+ select column, sum(price) from tableName group by product having sum(price) > 150;
	在 **having 条件后面可以跟聚合函数**,条件的筛选和where是一样的。

#### Round函数

> ROUND() 函数用于把数值字段舍入为指定的小数位数。

+ **SELECT** ROUND(column_name,decimals) **FROM** **TABLE_NAME**;
	+ decimals：规定要返回的小数位数

#### 其他函数

+ Charindex()返回字符或字符串在另一个字符的起始位置CHARINDEX(查找字符，被查字符，开始位置)
+ SubString()截取字符串中的一部分字符。SUBSTRING（字符串，开始位置，截取长度）
+ Stuff()删除指定长度的字符，并在指定的起点处插入另一组字符。STUFF(列名,开始位置,长度,替代字符串)
+ Soundex()返回表示字符串声音的一串字符

### 一对一关系

​	**在任何一方添加外键指向另外一方的主键**

### 一对多关系

​	**在多的一方插入外键，指向一的一方的主键**	

+ 主表：主键被引用的表
+ 从表：添加了外键的表
+ 外键约束：alter table tableName[从表] add foreign key(列名) references tableName(列名)；

#### 级联操作

​	通过主表影响主表去影响从表中的数据，需要使用级联操作。

+ 级联更新：外键约束 on update cascade
+ 级联删除：外键约束 on delete cascade
	+ alter table tableName[从表] add foreign key(列名) references tableName(列名) on update cascade on delete cascade;
+ 删除外键约束：alter table tableName drop foreign key 约束名；
+ 增加约束名：alter table tableName add constraint abc foreign key(列名) references tableName(列名)；

### 多对多关系

​	需要通过第三张表来维护关系。

【**数据库自增列**】：

```
使用mysql的insert插入语句时，当插入的列中存在外键属性，并且插入外键的值出错时（触碰到外键属性），insert会执行失败，并且表中的自增列还是会自增。
```

![表结构](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/%E8%A1%A8%E7%BB%93%E6%9E%84.png)

![自增1](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/%E8%87%AA%E5%A2%9E1.png)

![自增2](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/%E8%87%AA%E5%A2%9E2.png)

![自增3](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/%E8%87%AA%E5%A2%9E3.png)

【**数据库自增ID用完了会怎么样？**】：

```
分为两种情况：
1.有主键
	设置主键并且自增，到达上限之后会报错主键冲突。
2.没有主键
	InnoDB会自动创建一个6字节的全局的row_id，新数据会覆盖老数据
```

【**Mixed-mode inserts**】

```
混合模式插入
INSERT INTO TABLE VALUES (1,'A'),(NULL,'B'),(5,'C'),(NULL,'D');
在这种插入模式下InnoDB分配的自动增量值要多于要插入的行数
在上述插入后继续插入，ID为8
```

### 多表查询

#### 内连接查询

> 左右表都不为null才会匹配

+ ```mysql
	select * from 表名1,表名2 where 表名1.列名 = 表名2.列名;
	```

+ ```mysql
	select * from 表名 inner join 表名 on 条件;(inner可省略)
	```

#### 外连接查询

##### 左外连接

​	用左边表去右边表中查询对应记录，不管是否找到，都将显示左边表中全部记录。

```mysql
select * from 表1 left (outer) join 表2 on 条件;
```

##### 右外连接

​	用右边表去左边表查询对应记录，不管是否找到，右边表全部记录都将显示

```mysql
select * from 表1 right (outer) join 表2 on 条件;
```

##### 全外连接

​	左外连接和右外连接的结果合并，但会去掉重复的记录。

```mysql
select * from 表1 full outer join 表2 on 条件; # 但是mysql数据库不支持此语法。 

#在sql语句全连接，其实就是左外链接和右外连接之和，并且使用union去掉重复的数据。
select * from 表1 left outer join 表2 on 条件 
union all 
select * from 表1 right outer join 表2 on 条件;
#union和union all的区别在于union会删除重复记录再返回
```

#### SQL关联子查询

​	把一个SQL语句的查询结果作为另外一个SQL语句查询的参数存在。

### 索引

```mysql
index(字段名称) # 普通索引 字段的值可以重复
unique index(字段名称) #唯一索引 这个字段的值不能重复	
```

#### 组合索引

```mysql
index(字段1,字段2...)
```

**组合索引的使用：**组合索引存在最左原则，左侧的字段1如果如果在查询的时候使用则是有效索引，如果左侧的字段1没有使用，只是使用了字段2，那么索引也不会效果。

#### 表创建后创建索引

```mysql
create index 字段名 on 表名(字段名);#直接创建索引
```

​	只有根据索引字段进行查询的时候，索引才会生效

## JDBC

>  通过Java程序访问数据库

![JDBC核心关系图](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/JDBC%E6%A0%B8%E5%BF%83%E5%85%B3%E7%B3%BB%E5%9B%BE.png)

### 实现步骤

1. 注册驱动

	```
	static void registerDriver(Driver driver)使用DriverManager注册给定的驱动程序
	```

2. 建立连接

	```
	static Connection getConnection(String url, String user, String password)尝试建立与给定数据库URL的连接
	String url:数据库服务器相关协议/IP/端口信息
	```

3. 获取SQL语句发送的对象[Statement对象]

	```
	Statement createStatement();创建一个Statement对象,用于将SQL语句发送到数据库 
	```

4. 发送SQL语句,获取结果

	```
	ResultSet executeQuery(String sql)执行给定的SQL语句,返回一个ResultSet对象
	```

5. 处理结果

6. 释放资源

### DriverManager

>  java.sql.DriverManager：用于管理一组JDBC驱动程序的基本服务。

#### 成员方法

+ static void registerDriver(Driver driver)使用DriverManager注册给定的驱动程序
+ static Connection getConnection (String url,String user,String password)尝试建立与给定数据库URL的连接
	+ String url = "jdbc:mysql://localhost:3306/DatabaseName?characterEncoding=utf8&useSSL=false&serverTimezone=UTC"；
	+ jdbc：jdbc协议
	+ mysql：jdbc下的mysql子协议
	+ localhost：数据库服务器的IP信息
	+ 3306：数据库服务器端口号
	+ DatabaseName：连接的数据仓库的名字
	+ characterEncoding=utf8：设置编码信息[可选]
	+ useSSl=false：加密规则 false表示不加密
	+ serverTimezone=UTC：时区

### Connection

​	java.sql.Connection：与特定的数据库的连接（会话）。执行SQL语句并在连接的上下文中返回结果。

#### 成员方法

+ Statement createStatement（）创建一个Statement对象，用于将SQL语句发送到数据库

+ Statement createStatement(int resultSetType, int resultSetConcurrency) 
			创建一个 Statement对象，该对象将生成具有给定类型和并发性的 ResultSet对象。

	```
	int resultSetType：表示结果集的类型
		ResultSet.TYPE_FORWARD_ONLY ：只能向前，只能调用next() 不能向回滚动
		ResultSet.TYPE_SCROLL_INSENSITIVE  支持结果集向回滚动，不能查看修改结果
		ResultSet.TYPE_SCROLL_SENSITIVE    支持结果集向回滚动，查看修改结果
	int resultSetConcurrency：表示结果的并发策略
		ResultSet.CONCUR_READ_ONLY ：表示只读，不可修改
		ResultSet.CONCUR_UPDATABLE ：表示支持修改
	```

+ PreparedStatement prepareStatement(String sql)  
			创建一个 PreparedStatement对象，用于将参数化的SQL语句发送到数据库。 String sql为SQL语句框架

### Statement

​	java.sql.Statement：用于执行静态SQL语句并返回其生成的结果的对象。

#### 成员方法

+ ResultSet executeQuery（String sql）执行给定的select语句，返回一个ResultSet对象
+ int executeUpdate（String sql）执行给定的SQL语句，INSERT、UPDATE、DELETE声明，返回更新的行数

+ boolean execute(String sql)执行给定的SQL语句，这可能会返回多个结果
	+ true：发送的是查询语句
		+ ResultSet getResultSet（）以ResultSet对象获取当前结果
	+ false：发送的是更新语句
		+ int getUpdateCount（）返回更新的数据行数

### ResultSet

​	java.sql.ResultSet：表示数据库结果集，通常通过执行查询数据库的语句生成。

```
ResultSet对象维护指向其当前数据行的光标。最初，光标位于第一行之前。
next方法将光标移动到下一行，并且因为在ResultSet对象中没有更多行时返回false ,
因此可以在while循环中使用循环来遍历结果集。	
【默认的ResultSet对象不可更新，并且只有一个向前移动的光标。因此，只能从第一行到最后一行迭代一次。】
可以生成ResultSet可滚动和/或可更新的对象。
```

#### 遍历成员方法

​	**控制光标的方法**

+ boolean next() 将光标从当前位置向前移动一行。
+ boolean previous() 将光标移动到此 ResultSet对象中的上一行。
+ boolean absolute(int row) 将光标移动到此 ResultSet 对象中的给定行号。
+ void afterLast() 将光标移动到 ResultSet对象的末尾，就在最后一行之后。  
+ void beforeFirst() 将光标移动到 ResultSet对象的正面，就在第一行之前。  
+ boolean first() 将光标移动到此 ResultSet对象中的第一行。  
+ boolean last() 将光标移动到此 ResultSet对象中的最后一行。 

#### 获取成员方法

​	**获取光标所在行数据的方法**

+ String getString(int columnIndex) 检索此 ResultSet对象的当前行中指定列的值为Java编程语言中的 String 。  
+ String getString(String columnLabel) 检索此 ResultSet对象的当前行中指定列的值为Java编程语言中的 String 。  
+ int getInt(int columnIndex) 检索此 ResultSet对象的当前行中指定列的值为Java编程语言中的 int 。  
+ int getInt(String columnLabel) 以Java编程语言中的 int此 ResultSet对象的当前行中指定列的值。

### SQL注入

​	用户录入的信息当中包含了SQL语句的关键字，因此改变了SQL语句的原有含义

**解决思路：让用户录入的关键字无法生效即可。**

SQL语句框架语法: 赋值的部分使用 ? 号占位，每个?号都有下标，从1开始逐一增加。

+ select * from user where username = ? and password = ?;

SQL语句的框架需要交给预编译的对象进行预编译操作，预编译结束之后，即使在给?赋值时包含关键，也不会以关键字是形式生效。

### PreparedStatement

java.sql.PreparedStatement：表示预编译的SQL语句的对象

#### 成员方法

+ ResultSet executeQuery()  执行select语句
+ int executeUpdate() 执行insert delete update 语句
+ void setInt(int parameterIndex, int x) 将指定的参数设置为给定的Java int值。  
+ void setDouble(int parameterIndex, double x) 将指定的参数设置为给定的Java double值。 
+ void setString(int parameterIndex, String x) 将指定的参数设置为给定的Java String值。  

#### 预编译的实现过程

1. 注册驱动
2. 获取连接
3. 传递SQL语句框架，获取预编译对象PreparedStatement对象
4. 给SQL语句框架中的?号赋值
5. 执行SQL语句返回结果
6. 处理结果
7. 释放资源

### 批处理

​	同时执行一批次的SQL语句

1. 添加需要批处理的SQL语句
2. 执行批处理列表
3. 清空批处理列表

#### Statement对象实现批处理

+ void addBatch(String sql) 将给定的SQL命令添加到此 Statement 对象的当前命令列表中。
+ int[] executeBatch() 将一批命令提交到数据库以执行，并且所有命令都执行成功，返回一个更新计数的数组。  
+ void clearBatch() 清空这个 Statement对象当前的SQL命令列表。  

#### PreparedStatement对象实现批处理

+ void addBatch() 向这个 PreparedStatement对象的一批命令添加一组参数。  
+ int[] executeBatch() 将一批命令提交到数据库以执行，并且所有命令都执行成功，返回一个更新计数的数组。  
+ void clearBatch() 清空这个 Statement对象当前的SQL命令列表。 

### 事物

​	通过多条SQL语句干一件事

#### mysql实现事物控制

+ start transaction：此语句后面的所有SQL语句都处在在事务中，更改的内容不会自动提交，需要手动提交
+ commit：事务的提交，表示全部成功，事务结束，数据更改
+ rollback：事务的回滚，表示全部失败，事务结束，并且数据回复到开始之前的状态

#### JDBC实现事务管理

​	需要通过Connection对象实现控制

1. 开启控制
	+ void setAutoCommit(boolean autoCommit) 将此连接的自动提交模式设置为给定状态。--> false为手动
2. 提交事务
	+ void commit() 提交事务
3. 事务回滚
	+ void rollback() 事务回滚
	+ void rollback(Savepoint savepoint) 事物回滚到之前设置的回滚的位置

#### JDBC的回滚点设置

​	java.sql.Savepoint:一个保存点的表示，这是当前事务中可以从Connection.rollback方法引用的一个点。

​	当事物回滚到保存点时,保存点之后所做的所有更改都将被撤销。

+ Savepoint setSavepoint() Connection接口中用于获取回滚点的方法
+ void rollback(Savepoint savepoint)事物回滚到之前设置的回滚位置

## 前端

​	展示数据

+ html：专门用来制作网页的一门语言
+ css：专门用来美化页面的语言
+ js：可以让网页动起来

## HTML

### 列表标签

​	HTML 支持有序、无序和定义列表

+ 无序列表
	+ \<ul>\<li>\</li>\</ul>
+ 有序列表
	+ \<ol>\<li>\</li>\</ol>

### 表格标签

+ \<table>
	+ \<tr>\<td>\<td>\</tr>

**input标签中button类型和button标签的区别**

+ 在form表单标签中使用，<input type="button">不会提交表单，而<button type="submit"><button>会引起表单的提交
+ <button type="button"><button type="reset">不会提交表单
+ input的值需要设置在value属性中，button的值设置在标签中间

## CSS

```
选择器 {
		属性: 属性值;  // color: red;
		属性: 属性值;
		....
	}
```

1. 选择器: 选择需要设置样式的html元素。
2. 属性和属性值是一"键值对"的形式存在。
3. 属性是指元素设置的样式属性，如:字体大小，字体颜色、背景色...
4. 属性和属性值使用 ":"分离，并且要求 :号后面加上空格
5. 多个属性之间使用;号区分

### 标签选择器

​	对页面内所有和标签选择器指定的标签名相同的标签进行样式的修改

```
标签名 {
		属性: 属性值;  // color: red;
		属性: 属性值;
		....
	}
```

### 类选择器

​	在标签中添加class属性，使用class属性的值作为选择器名称。

```
.className {
		属性: 属性值;  // color: red;
		属性: 属性值;
		....
	}
```

1. 长名称或词组可以使用-为选择命名。不建议使用_
2. 不要纯数字或中文给class属性赋值
3. 不要使用标签名给class属性赋值

### id选择器

​	在标签中添加id属性，使用id属性的值作为选择器名称。

```
#idName {
		属性: 属性值;  // color: red;
		属性: 属性值;
		....
	}//id选择器不能重名
```

### 组合选择器

​	把多个选择器组合一起，设置相同的样式

```
选择器名1,选择器名2,.. {
		属性: 属性值;  // color: red;
		属性: 属性值;
		....
	}
```

### CSS复合选择器

#### 后代选择器

​	当标签出现嵌套时，内层标签就是外层标签的后代。含孙子，重孙之类。

```
选择器1 选择器2 选择器3.. {
		属性: 属性值;  // color: red;
		属性: 属性值;
		....
	}
```

#### 子元素选择器

​	只能选择某个元素的直接子元素[儿子]，不包含孙子，重孙之类。

```
父元素 > 子元素 {
		属性: 属性值;  // color: red;
		属性: 属性值;
		....
	}
```

### 块级模块分类

​	不同标签在页面中占据区域是不同的。

#### 块级标签

​	会独自占据页面的一整行或多行,可以对高度和宽度和对齐的方式进行设置，用于页面的布局。

常用块级标签：\<h1>-\<h6> \<p> \<ul> \<ol> \<li> \<div>等。

块级标签的特点：

1. 一个元素占用一行，总是会从新的一行开始。
2. 高度、宽度、内外边距可以设置控制。
3. 宽度默认是容器的100%
4. 块级标签可以嵌套其他类型的标签[块级，行内、行内块]
5. p标签和 h1 - h6 的标题标签只能用于针对文本，不能嵌套块级标签

#### 行内标签

​	不会占用网页的独自一行，范围是靠自身的大小和图像的尺寸支撑。一般无法对高度和宽度设置。

常用的行内标签： \<a> \<span> \<b> \<strong> \<i> \<em> \<del> \<u>

行内标签的特点：

1. 占用一行内文本内容支撑部分，和相邻的行内元素在同一行。
2. 高度和宽度无法设置，水平方向可以设置。
3. 默认宽度就是它本身文本内容的宽度。
4. 行内元素只能容纳文本或其他行内元素

#### 行内块标签

​		不会占用页面的一整行，但是相比较行内元素它可以设置高度和宽度。

常用的行内块标签：\<img> \<td> \<input>

行内块标签的特点:

1. 和相邻的行内元素或行内块元素在页面中的同一行，相邻的两个元素之间会有空间的间隙。
2.  可以对宽度和高度进行设置
3.  默认的宽度就是它本身内容在占用的宽度。

#### 标签元素转换：display

+ 转换为行内元素: display inline;
+ 转换为块级元素: display block;
+ 转换为行内块元素: display inline-block;

**注意事项**：

1. 行内块元素不能被转换为**行内元素**，但是可以转换为块级元素
2. 块级元素可以转换为行内元素和行内块元素。
3. 行内元素可以转换为块级元素或行内块元素

### CSS伪类

​	一般用于设置改变文档的状态，已经触发事件。结合选择器一起使用。

+ :link	伪类将应用于未被访问过的链接
+ :hover	伪类将应用于有鼠标指针悬停于其上的元素。
+ :active	伪类将应用于被激活的元素，如被点击的链接、被按下的按钮等。
+ :visited	伪类将应用于已经被访问过的链接
+ :focus	伪类将应用于拥有键盘输入焦点的元素。
+ 如果伪类用于超链接，那么在定义时有顺序要求，不能随便改变顺序位置：
		:line -> :visited -> :hover -> :active 顺序。

### CSS文本修饰：text-decoration

+ none：无修饰 ---> 用于取消a连接的默认的下划线
+ underline：下划线
+ line-through：删除线
+ overline：上划线

### CSS添加样式的方式

+ 行内样式: <标签名 style="属性: 属性值;属性: 属性值;">，代码复用性差，优先级高
+ 内部样式: 需要在head表中，使用style标签结果选择器一起设置样式。
+ 外部样式: 将CSS样式单独写到一个css文件中，然后通过link将CSS样式引入到HTML文件中。
			\<link href="css文件路径">

#### 优先级

+ !important
+ 行内样式 > 内部样式 = 外部样式
+ id选择器 > class选择器 > 标签选择器 > *通配符选择器

### CSS背景样式

+ background-color	背景颜色，可以给颜色名、十六进制、RGB颜色坐标。
+ background-image	背景图片地址
	+ none:默认没有背景图片   url(图片路径)
+ background-repeat	是否平铺
	+ repeat:默认值，背景图像在纵向和横向上平铺
	+ no-repeat:背景图片不平铺
	+ repeat-x:背景图像在横向上平铺
	+ repeat-y:背景图像在横向上平铺

+ background-position	背景位置
	+ 方位词:top center left right bottom
	+ background-position: position-x position-y；
+ background-attachment: scroll || fixed;	背景固定还是滚动
+ background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置

### 边框设置

+ border:border-width || border-style || border-color;
		如果需要将自带边框的标签的边框取消，设置为 border: 0;

#### 内边框

+ 内边距设置: 边框和内容的距离。 padding 属性设置
+ 所有的容器都有默认的内边距。	

#### 外边框

+ 标签和标签的距离。 margin 属性设置

#### 浮动设置

+ 元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中的指定位置的过程。标准流是指浏览器对页面元素按照从上到下，从左到右的顺序排列。
+ float: none || left || right;

**注意事项**：

1. 浮动的元素总是找离它最近的父级元素对齐。但是不会超出内边距的范围。
2. 浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。
3. 由上面可以推断出，一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。
4. 浮动脱离标准流，不占位置，会影响后面的标准流。浮动只有左右浮动。
5. 浮动的元素会自动转换为行内块元素

#### 定位设置

​	定位指定是将元素定位到页面的某一个位置，达到页面布局的效果。元素的定位属性主要包括定位模式和边移量两部分。

**定位模式**

+ position：定位模式指定的定位的方式，主要区别于定位的参照物。
+ static：自动定位（默认定位方式）
	默认值，指定位的元素按照标准流进行位置的摆放。
+ relative：相对定位，相对于其原文档流的位置进行定位
	相对定位，参照物是自身原有的位置，虽然自身发生了偏移，但是自身原有的位置并没有被释放。
+ absolute：绝对定位，相对于其上一个已经定位的父元素进行定位
	1. 当一个元素使用绝对定位的时候，会自动查找已经定位的父元素，使用定位的父元素的位置作为参照物。
	2. 如果父元素都没有定位，则使用窗口（body）进行定位。
	3. 失去位置，脱离标准流
+ fixed：固定定位，相对于浏览器窗口进行定位。

## JavaScript

​	用于在客户端实现数据验证。

### JS和HTML的结合方式：

+ 内部结合：在html页面的head标签中，使用script标签完成。

	```
	<script>
				// JS代码
	</script>
	```

+ 外部结合：需要将js代码写在一个JS后缀的文件中，然后引用到HTML页面中。

	```
	<script type="text/javascript" src="js文件的路径">
	</script>
	```

### JS中的变量

​	表示一个用于存储常量数据的空间。

```
var 变量名；
var 变量名 = 值；
```

### 函数

​	函数就是java中的方法，表示一段独立封装的代码，通过函数名调用执行。

#### 函数定义的第一种格式

```
function functionName（形参）{
	函数体；
}
```

**细节**

1. 在JS中函数没有重载的概念，如果在js中出现了多个同名的函数，那么后面的函数会把前面的函数覆盖掉

2. 在JS中如果函数需要接收参数，但是调用函数时没有传递参数，这时变量的结果全部都是undefined

3. JS中函数不管是否有形参，在调用的时候，都可以给其传递实参。而如果有形参，调用时也可以传递多余形参个数的实参数据。原因是：

	**在JS中的函数中有一个内置的arguments参数用于接收传递的所有数据，这个参数本身是一个数组对象。**

	后期使用JS中的函数时，需要接收参数，就在函数上定义变量，如果不需要就不定义，很少使用arguments数组操作

#### 函数定义的第二种格式

```
var functionName = new Function("形参","函数体代码;");
```

#### 函数定义的第三种格式

第三种函数定义的方式称为匿名函数。匿名函数的调用方式有两种：

1. 给匿名函数赋值函数名，然后通过函数名调用

2. 匿名函数最常用的场景，通过事件触发运行匿名函数

	```
	function(){
	    函数体;
	};
	```

### 数组

JS中的数组：可以保存多个不同类型的数据，同时长度不固定，可以把其理解成Java中的ArrayList。

#### 数组的第一种定义格式

```
var arrayName = [值,值,值...];
arrayName[index];//使用格式
```

#### 数组的第二种定义格式

​	数组的第二种定义格式需要使用到JS中的数组对象Array。和第一种方式定义的数组在使用上一样的，都是通过arrayName[index]进行操作。

```
// 创建数组对象 默认数组长度为0
var arrName  = new Array();

// 创建数组对象 并且给数组赋值
var arrName = new Array(值,值,值...);

/*
    创建数组对象
        1.传递1个值且是整数时表示数组的长度
        2.传递1个值且是小数时程序报错
        3.传递1个值且不是数值表示给数组赋1个值
*/
var arrName = new Array(值);
```

#### Array对象常用方法

+ concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 
+ join() 方法用于把数组中的所有元素放入一个字符串。
+ reverse() 方法用于颠倒数组中元素的顺序。
+ sort() 方法用于对数组的元素进行排序。对数组的引用。请注意，数组在原数组上进行排序，不生成副本。

#### for...in语句

​	for ... in 声明用于对数组或者对象的属性进行循环操作

```
for( x in arrayName ) {
    // 通过数组名结合下标操作数组元素即可
    arrayName[x];
}
```

### 消息框

#### 警告框

​	警告框主要用于在页面上弹出警示的信息。通过alert()函数实现。

```
alert("文本")
```

#### 确认框

```
confirm("文本")
```

#### 提示框

```
prompt("文本","默认值")
```

### 自定义对象

#### 定义对象(类)语法

```
function ObjectName(){}
```

#### 创建类对象语法

```
var 对象名 = new 自定义对象名();
```

#### 对象使用格式

```
对象名.变量名 = 值;
对象名.函数名 = function(形参){
	方法体;
}
```

### const、var和let的区别

1. const定义的变量不可以修改，而且必须初始化

	```
	const b = 2;//正确
	// const b;//错误，必须初始化 
	console.log('函数外const定义b：' + b);//有输出值
	// b = 5;
	// console.log('函数外修改const定义b：' + b);//无法输出 
	
	```

2. var定义的变量可以修改，如果不初始化会输出undefined，不会报错

	```
	var a = 1;
	// var a;//不会报错
	console.log('函数外var定义a：' + a);//可以输出a=1
	function change(){
	a = 4;
	console.log('函数内var定义a：' + a);//可以输出a=4
	} 
	change();
	console.log('函数调用后var定义a为函数内部修改值：' + a);//可以输出a=4
	
	```

3. let是块级作用域，函数内部使用let定义后，对函数外部无影响

	```
	let c = 3;
	console.log('函数外let定义c：' + c);//输出c=3
	function change(){
	let c = 6;
	console.log('函数内let定义c：' + c);//输出c=6
	} 
	change();
	console.log('函数调用后let定义c不受函数内部定义影响：' + c);//输出c=3
	```

### BOM对象

​	Browser Object Model 浏览器对象模型，JS把整个浏览器当做一个对象来进行处理。在整个浏览器对象中又包含N个小的组件对象，如：地址栏、页面窗口等组件对象。

#### Window对象

+ Window对象是Javascript层级中的顶层对象。

+ Window对象代表一个浏览器窗口或者一个框架。

+ Window对象会在\<body>或者\<frameset>每次出现时被自动创建。

##### 常用方法

+ setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。重复执行。
+ setTimeout() 在指定的毫秒数后调用函数或计算表达式。 执行一次
+ clearInterval() 取消由 setInterval() 设置的 timeout。 
+ clearTimeout() 取消由 setTimeout() 方法设置的 timeout。

#### History对象

+ History对象实际上是JavaScript对象，而不是HTML DOM对象。
+ History对象是window对象的一部分，可以通过window.history属性对其进行访问。

##### 常用方法

+ back（）

+ forword（）
+ go（）

#### Location对象

+ Location对象实际上是JavaScript对象，而不是HTML DOM对象。
+ Location对象是由JavaScript runtime engine自动创建的，包含有关当前URL的信息。
+ Location对象是window对象的一部分，可以通过window.location属性对其进行访问。

### DOM对象

+ Document对象代表整个HTML文档，可以用来访问页面中的所有元素。
+ Document对象是Window对象的一个部分，可以通过window.document属性来访问。

#### DOM对象常用方法

+ getElementById() 返回对拥有指定id的第一个对象的引用。 
+ getElementsByName() 返回带有指定名称的对象集合,通过name属性值获取标签对象。 
+ getElementsByClassName() 返回带有指定名称的对象集合,通过class属性值获取标签对象。 
+ getElementsByTagName() 返回带有指定标签名的对象集合。

### 事件的绑定

#### 第一种语法格式

```html
<head>
    <meta charset="UTF-8">
    <title>JavaScript演示</title>
    <script>
        function eventFunction(){
            JS事件代码;
        }
    </script>
</head>
<body>
    <tagName eventName = "eventFunction()">文本内容</tagName>
</body>
```

#### 第二种语法格式

```html
<head>
    <meta charset="UTF-8">
    <title>JavaScript演示</title>
    <script>
        // html页面加载完成后，才能获取标签对象
        window.onload = function {
            /*
                1.先获取标签对象
                2.给标签对象添加对应的事件
           */
            var tagObject = getElementBy...;
            tagObject.eventName = function() {
                JS事件;
            }
        }
    </script>
</head>
<body>
    <tagName id="" name="" class="">文本内容</tagName>
</body>
```

# JavaWeb

## jQuery

**核心特性：**独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。

### DOM和jQuery

+ js中可以用document获取html元素，这是DOM对象，DOM对象可以直接调用属性

+ jQuery是对js进行了封装，封装的第一个要素是属性私有化

+ 使用jQuery的方式得到的对象称为jQuery对象

+ jQuery对象是DOM对象的封装体，不能直接调用属性

+ 在描述jQuery对象时，一般在对象名前加上$

	```
	 var $inp = $("#uname_inp");
	```

### jQuery语法

​	jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。

​	**基础语法： $(selector).action()**

### jQuery选择器

#### 基本选择器

+ *通配符选择器
+ 标签选择器
+ .class选择器
+ #id选择器
+ ，联合选择器

#### 层级选择器

+ 选择器  选择器：匹配指定选择器的所有后代元素
+ 选择器 >选择器：匹配指定选择器的所有子元素
+ 选择器  + 选择器：匹配指定选择器的紧邻的下一个兄弟元素
+ 选择器  ~ 选择器：匹配指定选择器的后面所有的兄弟选择器

#### 简单选择器

+ ：first 获取第一个元素
+ ：last 获取最后一个元素
+ ：not（selector） 去除所有与给定选择器匹配的元素
+ ：even 匹配所有索引值为偶数的元素，从 0 开始计数
+ ：odd 匹配所有索引值为奇数的元素，从 0 开始计数
+ ：eq（index）匹配一个给定索引值的元素
+ ：gt（index）匹配所有大于给定索引值的元素
+ ：lt（index）匹配所有小于给定索引值的元素
+ [attribute]：匹配包含给定属性的元素
+ \[selector1][selector2]...：匹配含selector1属性，并且匹配selector2...

### jQuery事件

​	事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。

| 鼠标事件  | 键盘事件 | 表单事件 | 文档/窗口事件 |
| --------- | -------- | -------- | ------------- |
| click     | keypress | submit   | load          |
| dblclick  | keydown  | change   | resize        |
| mouseover | keyup    | focus    | scroll        |
| mouseout  |          | blur     | unload        |

####  jQuery 事件方法语法

在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法。
页面中指定一个点击事件：

```javascript
$("p").click();
```

下一步是定义触发事件。您可以通过一个事件函数实现：

```javascript
$("p").click(function(){
    // 动作触发后执行的代码!!
});
```

也就是说，不传参数是点击，传参数是设置事件。

**用on绑定和直接使用click的区别：**

​	click是点击事件，但是在页面加载完之后，jquery事件新添加的元素，用click的话是无法获取元素的，这个时候要用on去获取元素事件，简单的说页面加载完成时候页面显示的元素可以用on，也可以用click，但是页面加载完成之后后期再追加的元素只能用on。

**bind和on绑定的区别：**

​	用on绑定比用bind绑定多一个参数childSelector

+ bind缺点：

1. 如果子元素非常多，给每个子元素都添加一个事件会影响性能。
2. 动态添加元素时，不能动态绑定事件

+ on优缺点：

1. 解决上述两个缺点
2. 采用事件委托机制，不是直接为元素绑定事件，而是为其父元素（或者祖父元素）绑定事件，当在父元素任意元素点击时，事件会一层一层向上冒泡，直到到达绑定事件的元素
3. 调用的时候也会出现问题，如果事件目标绑定在DOM树中很深的位置，这样一层层向上冒泡查找与选择器相匹配的元素，又会影响性能。

**总结：**

+ 选择器匹配到的元素比较多时，不要用bind()迭代绑定
+ 用id选择器时，可以用bind()
+ 需要给动态添加的元素绑定时，用delegate()或者on()
+ 用delegate()和on()方法，dom树不要太深

### jQuery的属性方法

​	jQuery对象不能直接调用dom的属性，提供了调用的方法

+ val([val|fn|arr])：给jQuery对象赋值和取值

	```js
	var $inp = $("#inp1");
	var uname = $inp.val();
	//改变value值
	$inp.val("王五");
	```

+ attr(name|properties|key,value|fn)：取jQuery对象的指定属性  或给指定属性赋值

	```js
	var $inp = $("#inp2");
	var type = $inp.attr("type");
	if(type=="password"){
	    $inp.attr("type","text");
	}else{
	    $inp.attr("type","password");
	}
	```

+ prop(name|properties|key,value|fn)：取jQuery对象的指定属性  或给指定属性赋值

+ addClass(class|fn)：给指定元素添加class属性

	```js
	var $man = $("#man");
	$man.addClass("sex");
	```

+ html([val|fn])：取得第一个匹配元素的html内容。

+ text([val|fn])：取得所有匹配元素的内容。

	```js
	$(function(){
		$("#input").focus(function(){
			$("#font").prop("color","blue");
			$("#font").text("<b>账号是6-8位数字和字母的组合</b>");
			$("#font").html("<b>账号是6-8位数字和字母的组合</b>");
		});
	});
	```

**prop和attr的区别:**

+ JQuery中，prop()是操作DOM属性，attr()是操作HTML属性
	+ 对于HTML元素本身就带有的固有属性，在处理时，使用prop方法
	+ 对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法

### DOM对象和jQuery对象的转换

+ jQuery对象中的get(index)，该方法可以使得jQuery对象根据下标取值，但是取出的是DOM对象
+ jQuery对象.get(index)==jQuery[index]

```js
DOM对象==》jQuery对象
var $jQuery = $("#jQuery");
jQuery对象==》DOM对象
var jQuery = $jQuery[0];
```

### jQuery的三种循环

```js
//传统的循环
var $boxs = $("input");//这是一个js数组
for(var i=0;i<$boxs.length;i++){
    var box = $boxs[i];//dom对象
    /*alert(box);*/
    box.checked = true;
};
//forin
for(var i in $boxs){
    $boxs[i].checked = true;
}
```

返回值:each(callback)
以每一个匹配的元素作为上下文来执行一个函数。

```js
function getNo(){
    var  $boxs = $("input");//这是一个jQuery对象 但是是一个数组
    $boxs.each(function (i) {
        var box = $boxs[i];//变成dom对象
        box.checked = false;
    });
};
```

返回值:ObjectjQuery.each(object, *[callback]*)
通用例遍方法，可用于例遍对象和数组。

```js
function  getOther(){
    var  $boxs = $("input");//这是一个jQuery对象 但是是一个数组
    //object:需要遍历的数组或集合
    //function:每次遍历调用的方法
    	//i:遍历的次序
    	//node:每次遍历的赋值变量   参考增强for
    $.each($boxs,function(i,node){
       /* alert("node变量："+node);*/
        node.checked = !node.checked;
    });
};
```

### jQuery的文档处理

+ append（content|fn）：向每个匹配的元素内部追加内容。**子元素**

	```js
	$(function(){
	    $("#but1").click(function(){
	        //给指定的元素追加子内容
	        $("#div1").append("<p>这是新段落</p>")
	    });
	});
	```

+ appendTo(content) ：把所有匹配的元素追加到另一个指定的元素元素集合中
	使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。**子元素**

+ before(content|fn)：在每个匹配的元素之前插入内容。**兄弟元素**

+ after(content|fn)：在每个匹配的元素之后插入内容。**兄弟元素**

+ replaceWith(content|fn)：将所有匹配的元素替换成指定的HTML或DOM元素。

  ```js
  xxxxxxxxxx 		//用<b>Paragraph. </b>代替p标签$("p").replaceWith("<b>Paragraph. </b>");
  ```

+ replaceAll(selector) ：用匹配的元素替换掉所有 selector匹配到的元素。

  ```js
  //用<b>Paragraph. </b>代替p标签
  $("<b>Paragraph. </b>").replaceAll("p");
  ```

+ remove(*[expr]*)：从DOM中删除所有匹配的元素。

+ empty()：删除匹配的元素集合中所有的子节点。

+ css(name|pro|[,val|fn])：访问匹配元素的样式属性  key：css的通用属性

  ```js
  $("#but1").click(function(){
      $("#font1").css("color","red");
      $("#font1").css("font-family","楷体");
  });	
  ```

### jQuery效果

#### 隐藏显示

+ ***hide()***：使用 hide() 将元素隐藏

+ ***show()***：使用show()将元素显示

+ ***toggle()***：使用 toggle() 方法来切换 hide() 和 show() 方法。显示被隐藏的元素，并隐藏已显示的元素：

```javascript
$(selector).hide([speed,[easing],[fn]]);
$(selector).show([speed,[easing],[fn]]);
$(selector).toggle([speed],[easing],[fn]);
```

+ speed 参数规定隐藏/显示的速度，可以取以下值："slow"、"normal"、"fast" 或毫秒。

+ easing 参数用来指定切换效果，默认是“swing”，可用参数“linear”。

+ fn 参数是动画完成时执行的函数。

#### 淡入淡出

+ ***fadeIn() 方法：***用于淡入已隐藏的元素。

+ ***fadeOut() 方法：***淡出可见元素。

+ ***fadeToggle() 方法：***可以在 fadeIn() 与 fadeOut() 方法之间进行切换。
	如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。

+ ***fadeTo() 方法：***允许渐变为给定的不透明度（值介于 0 与 1 之间）。

```js
$(selector).fadeIn([speed],[easing],[fn]);
$(selector).fadeOut([speed],[easing],[fn]);
$(selector).fadeToggle([speed,[easing],[fn]]);
$(selector).fadeTo([[speed],opacity,[easing],[fn]]);
```

+ opacity 参数是一个0至1之间表示透明度的数字。

#### 滑动

+ ***slideDown() 方法：***用于向下滑动元素。

+ ***slideUp() 方法：***用于向上滑动元素。

+ ***slideToggle() 方法：***可以在 slideDown() 与 slideUp() 方法之间进行切换。
	如果元素向下滑动，则 slideToggle() 可向上滑动它们。如果元素向上滑动，则 slideToggle() 可向下滑动它们。

```javascript
$(selector).slideDown([speed],[easing],[fn]);
$(selector).slideUp([speed],[easing],[fn]);
$(selector).slideToggle([speed],[easing],[fn]);
```

#### 链式编程

有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。

**提示：** 这样的话，浏览器就不必多次查找相同的元素。

如需链接一个动作，只需简单地把该动作追加到之前的动作上。

下面的例子把 css()、slideUp() 和 slideDown() 链接在一起。"p1" 元素首先会变为红色，然后向上滑动，再然后向下滑动：

```javascript
$("#p1").css("color","red").slideUp(2000).slideDown(2000);
```

如果需要，我们也可以添加多个方法调用。

**提示：**当进行链接时，代码行会变得很差。不过，jQuery 语法不是很严格；可以按照希望的格式来写，包含换行和缩进。

```javascript
$("#p1").css("color","red")
  .slideUp(2000)
  .slideDown(2000);
```

### jQuery遍历

> jQuery 遍历，意为**移动**，用于根据其相对于其他元素的关系来**查找**（或选取）HTML 元素。以某项选择开始，并沿着这个选择移动，直到抵达期望的元素为止。

#### 祖先

+ parent(*[expr]*) 取得一个包含着所有匹配元素的唯一父元素的元素集合。

#### 后代

+ children(*[expr]*) 取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。
+ find(expr|obj|ele) 方法返回被选元素的后代元素，一路向下直到最后一个后代。

#### 同胞

+ siblings(*[expr]*) 取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。
+ next(*[expr]*) 取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。
+ prev(*[expr]*) 取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合。

#### 其他筛选

+ is(expr|obj|ele|fn) 根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。
+ not(expr|ele|fn) 删除与指定表达式匹配的元素

## 浏览器行为管理

> ​	在B/S通信模型中，请求由浏览器发送。服务端返回内容由浏览器来接收。可以说在一次基于B/S通信模型下的互联网通信，始于浏览器与结束与浏览器。因此对于浏览器行为控制是互联网通信中一个重要环节。

### 行为控制分类

#### 浏览器请求行为

+ 控制浏览器发送请求地址
+ 控制浏览器发送请求的行为方式
+ 控制浏览器发送请求时携带请求参数内容

#### 浏览器的接收行为

* 控制浏览器解析响应数据方式

* 控制浏览器展示数据方式

* 控制用户与浏览器中的HTML标签之间人机交互方式

### 浏览器的请求方式

> ​	浏览器向服务端计算机发送请求时，有七种请求方式可以选择。这些请求方式决定了浏览器发送请求时的行为特征。到目前为止，在Java编程世界中只考虑浏览器的两种请求方式 :
>
> GET请求方式与POST请求方式

#### get请求方式

* 要求浏览器必须将请求参数信息在地址栏展示

* 要求浏览器在发送请求时，携带的**请求参数数量**不能超过4k
* 要求浏览器必须将请求参数保存在Http请求协议中**请求体**
* 要求浏览器将服务端返回内容保存在浏览器的缓存中

#### post请求方式

* 要求浏览器必须在地址栏中屏蔽**请求参数信息**
* 不限制浏览器发送请求时，携带的**请求参数数量**
* 要求浏览器必须将**请求参数信息**保存到Http协议中**请求体**
* 禁止浏览器对服务端返回的内容进行保存

#### 超链接请求

> 超链接标签命令在执行时，要求浏览器必须以GET方式发送请求

#### location对象请求

> location对象在执行时，会修改浏览器的地址栏的内容。导致浏览器根据新地址立刻发起请求。此时浏览器必须以GET方式发送请求

#### form表单请求

> form标签中有一个method属性，通过赋值”POST/GET”，可以动态要求浏览器分别以GET方式或则POST方式发送请求

##### 表单域标签

>  表单域标签指的是一组专门在form标签声明的标签。用于辅助用户填写请求参数内容并作为请求参数的载体。

+ input
+ select
+ textarea

```
在FORM标签命令浏览器发送请求时，浏览器自动的读取FORM标签内部的表单域标签。将表单域标签的name属性的值，作为”请求参数名”。将表单域标签的value属性值，作为”请求参数内容”
```

### 响应协议

> 服务器接收到请求，做对应的处理，处理完毕，向浏览器回复信息,这就是响应

+ 200：请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中；
+ 404：请求的资源没有找到，说明客户端错误的请求了不存在的资源；
+ 500：请求资源找到了，但服务器内部出现了错误；
+ 302：重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头    Location，它指定了新请求的URL地址；

## Servlet

> Servlet：处理器	Lisenter：监听器	Filter：过滤器 

> javax被Jakarta取代

### Servlet

> Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理

1. 接收请求数据
2. 处理请求
3. 设置响应值

#### Servlet体系 

##### Servlet接口

```java
在ServletAPI中最重要的是Servlet接口，所有Servlet都会直接或间接的与该接口发生联系，或是直接实现该接口，或间接继承自实现了该接口的类。
该接口包括以下五个方法：

init(ServletConfig config)
ServletConfig getServletConfig()
service(ServletRequest req,ServletResponse res)
String getServletInfo()
destroy( )

（1）第一次访问Servlet时，服务器会创建Servlet对象，并调用init方法，再调用service方法
（2）第二次再访问时，Servlet对象已经存在，不再创建，执行service方法
（3）当服务器停止，会释放Servlet，调用destroy方法。
```

##### GenericServlet抽象类

```
它对Servlet接口中的部分方法（init和destroy）添加了实现，使得开发时只需要考虑针对service方法的业务实现即可。
```

##### HttpServlet类

```
是继承GenericServlet的基础上进一步的扩展
平时使用Servlet开发基本上就是继承该类，重写doGet和doPost方法
```

#### Servlet创建方式

> 实现Servlet接口

```java
public class HelloServlet implements Servlet{
	//重写五个方法
}
```

> 继承HttpServlet

```java
public class FirstServlet extends HttpServlet {
    //doget和dopost方法是处理对应请求的   他俩来自 service方法
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doGet(req, resp);
        System.out.println("这是处理get的");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
        System.out.println("这是处理post的");
    }
}
```

#### Servlet的生命周期

> 每个servlet都是被服务器创建的，当有请求访问某个servlet时，服务器会创建这个servlet对象，调用一次init()方法，由service()处理该请求，当服务器关闭时，servlet会被服务器杀死，调用destroy()

> servlet是单例多线程对象，懒汉式

+ **实例化**

	```
		实例化阶段是Servlet生命周期中的第一步，由Servlet容器调用Servlet的构造器创建一个具体的Servlet对象的过程。而这个创建的时机可以是在容器收到针对这个组件的请求之后，即:用了才创建；也可以在容器启动之后立刻创建实例。
	```

+ **初始化**

	```
		Servlet在被加载实例化之后，必须要初始化它。在初始化阶段，init（）方法会被调用。这个方法在javax.servlet.Servlet接口中定义。其中，方法以一个ServletConfig类型的对象作为参数。ServletConfig对象由Servlet引擎负责创建，从中可以读取到事先在web.xml文件中通过<init-param>节点配置的多个name-value名值对。ServletConfig对象还可以让Servlet接受一个ServletContext对象。
		一般情况下，init方法不需要编写，因GenericServlet已经提供了init方法的实现，并且提供了getServletConfig方法来获得ServletConfig对象。
	```

+ **就绪/服务**

	```
		Servlet被初始化以后就处于能够响应请求的就绪状态。每个对Servlet的请求由一个ServletRequest对象代表，Servlet给客户端的响应由一个ServletResponse对象代表。当客户端有一个请求时，容器就会将请求与响应对象转给Servlet，以参数的形式传给service方法。service方法由javax.servlet.Servlet定义，由具体的Servlet实现
	```

	```
		HttpServlet将service方法拆分了。doGet和doPost
	```

+ **销毁**

	```
		Servlet容器在销毁Servlet对象时会调用destroy方法来释放资源。通常情况下Servlet容器停止或者重新启动都会引起销毁Servlet对象的动作，但除此之外，Servlet容器也有自身管理Servlet对象的准则，整个生命周期并不需要人为进行干预。
	```

#### web.xml文件的配置

> web.xml是服务器的核心配置文件，服务器在启动时会读取web.xml文件中的内容

1. 不能有重名
2. url-pattern：必须写/
3. 配置初始化参数
4. 设置组件启动时机 load-on-startup

```xml
   <!--  告诉服务器 当有aaa请求访问服务器  请分发给FirstServlet-->
    <!--配置servlet请求-->
    <!-- 告诉服务器  我这有个servlet -->
    <servlet>
        <servlet-name>first</servlet-name>
        <servlet-class>com.bjpn.servlet.FirstServlet</servlet-class>
        <init-param>
        <param-name></param-name>
        <param-value></param-value>
        </init-param>
        <load-on-startup>-1</load-on-startup>负数是懒汉式(默认)正整数是饿汉式
    </servlet>
    <!--配置servlet的请求映射   -->
    <servlet-mapping>
        <servlet-name>first</servlet-name>
        <!-- url请求必须写/	/代表根路径   http://ip:port/项目名-->
        <url-pattern>/aaa</url-pattern>
    </servlet-mapping>
<welcome-file-list>
        <welcome-file>index.html</welcome-file>
</welcome-file-list>(默认index)
//listener配置
<listener>
        <listener-class>com.bjpn.listeners.AppListeners</listener-class>
</listener>
<!--配置过滤器的请求-->
    <filter>
        <filter-name>ecodFilter</filter-name>
        <filter-class>com.bjpn.filters.EncodFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>ecodFilter</filter-name>
        <!--配置过滤器的拦截范围
        /*:根目录下所有请求都拦截
        /*.do:所有带有.do的请求都拦截
        /*.jsp
        -->
        <url-pattern>/*</url-pattern>
    </filter-mapping>
```

Servlet各组件加载顺序：listener -> filter -> servlet

### Cookie

+ cookie，有时我们也用其复数形式cookies，是服务端保存在浏览器端的数据片段。以key/value的形式进行保存。每次请求的时候，请求头会自动包含本网站此目录下的cookie数据。网站经常使用这个技术来识别用户是否登陆等功能。
+ cookie就是服务端留给计算机用户浏览器端的小文件。
+ HTTP是无状态协议，服务器不能记录浏览器的访问状态，也就是说服务器不能区分中两次请求是否由一个客户端发出。这样的设计严重阻碍的Web程序的设计。
+ Cookie实际上就是服务器保存在浏览器上的一段信息。浏览器有了Cookie之后，每次向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据该信息处理请求。
+ Cookie[] cookies = request.getCookies();

【**Cookie的缺点**】

1. Cookie做为请求或响应报文发送，无形中增加了网络流量。
2. Cookie是明文传送的安全性差。
3. Cookie中保存数据是不稳定的，用户可以随时清理cookie
4. 各个浏览器对Cookie有限制，使用上有局限

![Cookie](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/Cookie.png)

​	Cookie是由服务器创建，然后通过响应发送给客户端的一个键值对。客户端会保存Cookie，并会标注出Cookie的来源（哪个服务器的Cookie）。当客户端向服务器发出请求时会把所有这个服务器Cookie包含在请求中发送给服务器，这样服务器就可以识别客户端了 。

#### Cookie的规范

+  每一个Cookie大小上限为4KB；
+ 一个服务器最多在客户端浏览器上保存20个Cookie；
+ 一个浏览器最多保存300个Cookie；
+ Cookie是通过HTTP请求和响应头在客户端和服务器端传递的：

```java
Cookie cookie = new Cookie("aaa", "123");
response.addCookie(cookie);
//转发或重定向都可以
//获取Cookie
Cookie[] cookies = request.getCookies();
```

#### Cookie的生命周期

> Cookie不只是有name和value，Cookie还是生命。所谓生命就是Cookie在客户端的有效时间，可以通过setMaxAge(int)来设置Cookie的有效时间。

+ cookie.setMaxAge(-1)：cookie的maxAge属性的默认值就是-1，表示只在浏览器内存中存活。一旦关闭浏览器窗口，那么cookie就会消失。
+ cookie.setMaxAge(60*60)：表示cookie对象可存活1小时。当生命大于0时，浏览器会把Cookie保存到硬盘上，就算关闭浏览器，就算重启客户端电脑，cookie也会存活1小时；
+ cookie.setMaxAge(0)：cookie生命等于0是一个特殊的值，也就是说，如果原来浏览器已经保存了这个Cookie，那么可以通过Cookie的setMaxAge(0)来删除这个Cookie。无论是在浏览器内存中，还是在客户端硬盘上都会删除这个Cookie

#### Cookie的中文编码

>  中文和英文字符不同，中文属于Unicode字符，在内存中占用4个字符，而英文属于ASCII字符，内存中只占2个字节。Cookie中使用Unicode字符时需要对Unicode字符进行编码，否则会出现乱码。

+ 编码可以使用java.net.URLEncoder类的encode(String str,String encoding)方法

+ 解码使用java.net.URLDecoder类的decode(String str,String encoding)方法

	```java
	//保存
	String s = URLEncoder.encode("老邢", "UTF-8"));
	//获取
	String ss = URLDecoder.decode(s, "UTF-8");
	```

#### Cookie路径

```
Cookie要是有父路径必须设置Cookie路径为根路径
cookie.setPath("/");可以在webapp文件夹下的所有应用共享cookie
```

### Session对象

+ Session用于跟踪客户的状态。
+ Session指的是在一段时间内，单个客户与Web服务器的一连串相关的交互过程。
+ 在一个Session中，客户可能会多次请求访问同一个网页，也有可能请求访问各种不同的服务器资源。
+ 访问一个服务器  只要浏览器不关闭 这个会话产生的session就存在 
+ **session是活跃在服务器端的** 
+ **session是基于cookie的。**

![Session原理图](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/Session%E5%8E%9F%E7%90%86%E5%9B%BE.png)

​	在用户第一次使用session的时候（访问jsp页面会获取session，所以一般访问index.jsp就算是第一次使用session了），服务器会为用户创建一个session域对象。使用jsessionid和这个对象关联，这个对象在整个用户会话期间使用。响应体增加set-cookie:jsessionid=xxx的项。用户下次以后的请求都会携带jsessionid这个参数，我们使用request.getSession()的时候，就会使用jsessionid取出session对象。

#### Session的常用方法

```java
//下面的方法是对session中值的操作  不能销毁session对象
session.setAttribute(String key,Object value);session的参数绑定
Object obj = session.getAttribute(String key);session取值
//session的删除
Object obj = session.remove(String key);删除指定session中的参数
//销毁session
session.invalidate();
//删除session中指定的值
session.removeAttribute("sessionKey1");
//设置生命周期
使用HttpSession的session.setMaxInactiveInterval(20*60);设置，单位秒
web.xml
//单位是分钟
<session-config>
	<session-timeout>20</session-timeout>
</session-config>
```

### HttpServletRequest对象

#### Request对象

> ​	request是Servlet.service()方法的一个参数，类型为javax.servlet.http.HttpServletRequest。
> ​	在客户端发出每个请求时，服务器都会创建一个request对象，并把请求数据封装到request中，然后在调用Servlet.service()方法时传递给service()方法，这说明在service()方法中可以通过request对象来获取请求数据。

**功能：**

+ 封装了请求头数据
+ 封装了请求正文数据，如果是GET请求，那么就没有正文
+ request是一个域对象，可以把它当成Map来添加获取数据
+ request提供了请求转发和请求包含功能

#### Request对象常用方法

##### Request的域方法

+ void setAttribute(String name, Object value)：用来存储一个对象，也可以称之为存储一个域属性
	例如：servletContext.setAttribute(“xxx”, “XXX”)，在request中保存了一个域属性，域属性名称为xxx，域属性的值为XXX。
	请注意，如果多次调用该方法，并且使用相同的name，那么会覆盖上一次的值，这一特性与Map相同
+ Object getAttribute(String name)：用来获取request中的数据，当前在获取之前需要先去存储才行
	例如：String value = (String)request.getAttribute(“xxx”);，获取名为xxx的域属性
+ void removeAttribute(String name)：用来移除request中的域属性，如果参数name指定的域属性不存在，那么本方法什么都不做
+ Enumeration getAttributeNames()：获取所有域属性的名称

##### Request请求头数据 

+ String getHeader(String name)：获取指定名称的请求头
+ Enumeration getHeaderNames()：获取所有请求头名称
+ int getIntHeader(String name)：获取值为int类型的请求头

##### Request其他方法

> request中还提供了与请求相关的其他方法，有些方法是为了我们更加便捷的方法请求头数据而设计，有些是与请求URL相关的方法。

+ int getContentLength()：获取请求体的字节数，GET请求没有请求体，因为请求参数是跟着url的，所以请求体返回-1
+ String getContentType()：获取请求类型，如果请求是GET，那么这个方法返回null；如果是POST请求，那么默认为application/x-www-form-urlencoded，表示请求体内容使用了URL编码
+ String getMethod()：返回请求方法
+ Locale getLocale()：返回当前客户端浏览器的Locale。java.util.Locale表示国家和言语，这个在国际化中很有用
+ String getCharacterEncoding()：获取请求编码，如果没有setCharacterEncoding()，那么返回null，表示使用ISO-8859-1编码
+ void **setCharacterEncoding**(String code)：设置请求编码，只对请求体有效！**注意，对于GET而言，没有请求体**，所以此方法**只能对POST请求中的参数有效**

##### 请求路径的方法

+ String getContextPath()：返回上下文路径，根路径，例如：/hello
+ String getQueryString()：返回请求URL中的参数，例如：name=zhangSan
+ String getRequestURI()：返回请求URI路径，项目路径，例如：/hello/oneServlet
+ StringBuffer getRequestURL()：返回请求URL路径，全路径，例如：http://localhost/hello/FirstServlet，即返回除了参数以外的路径信息
+ String getServletPath()：返回Servlet路径，例如：/oneServlet

##### 获取客户端的方法

+ String getRemoteAddr()：返回当前客户端的IP地址
+ String getRemoteHost()：返回当前客户端的主机名，但这个方法的实现还是获取IP地址
+ String getScheme()：返回请求协议，例如：http
+ String getServerName()：返回主机名，例如：localhost
+ int getServerPort()：返回服务器端口号，例如：8080

##### 接收参数的方法

> 参数传递时，请求中携带的参数  都符合key-value，根据key来接收value

+ String value = request.getParameter("name")

> 参数传递时，请求中携带的参数  都符合key-value，一个key有多个值

+ String[] value = request.getParameterValues("name")

**解决post请求的中文乱码问题**

```java
request.setCharacterEncoding("utf-8");
```

##### 请求转发

> 请求转发的特点：地址栏发起一次请求，地址栏不会发生改变

+ request.getRequestDispatcher(“路径”).forword(request,response)

### HttpServletResponse对象

#### Response对象

> response是Servlet.service方法的一个参数，类型为javax.servlet.http.HttpServletResponse。
> 在客户端发出每个请求时，服务器都会创建一个response对象，并传入给Servlet.service()方法。
> response对象是用来对客户端进行响应的，这说明在service()方法中使用response对象可以完成对客户端的响应工作。

**功能：**

+ 设置响应头信息
+ 发送状态码
+ 设置响应正文
+ 重定向

#### 响应对象常用方法

| 方法名称                      | 作用                 |
| ----------------------------- | -------------------- |
| setStatus(int code)           | 设置响应状态码       |
| setHeader(name,value)         | 设置响应信息头       |
| setCharacterEncoding(String); | 设置编码格式         |
| setContentType(String)        | 设置返回数据mimetype |
| getWriter()                   | 获取字符输出流       |
| getOutputStream()             | 获取字节输出流       |

#### 响应正文

+ PrintWriter out = response.getWriter()：获取字符流；给指定请求会写字符串
+ ServletOutputStream out = response.getOutputStream()：获取字节流；多用于文件下载

#### 响应乱码问题

> 在使用response.getWriter()时需要注意浏览器默认字符编码为ISO-8859-1，但是从后端传去的数据编码为UTF-8

+ response.setContentType("text/html;charset=utf-8")设置浏览器的读取和编码

#### 响应头的操作

+ response.setHeader("Refresh","5;url=")

#### 设置状态码的方法

+ response.setStatus(200)设置状态码
+ response.sendError(404, “您要查找的资源不存在”)：当发送错误状态码时，Tomcat会跳转到固定的错误页面去，但可以显示错误信息。

#### 重定向

```java
//设置状态码	302是重定向的状态码   可以通过设置响应头引起地址栏发生改变
 response.setStatus(302);
//重定向要让页面发起新的请求
response.setHeader("Location", "http://localhost:8080/javaweb004/***.html");*/
//重定向的方法	重定向 发送两次请求，地址栏会发生改变
response.sendRedirect("***.html");
```

**重定向中文乱码**

```java
String encoder = "utf-8";
String s = URLEncoder.encode(name,encoder);
response.sendRedirect(request.getContextPath()+"/xxx.action?name="+s)
```

### ServletContext对象

+ ServletContext也叫做“公共区域”，也就是同一个WEB应用程序中，所有的Servlet和JSP都可以共享同一个区域。
+ ServletContext对象随着服务器的启动创建,随着服务器的消亡而销毁

#### 全局对象的获取方式

```markdown
方式一:GenericServlet提供了getServletContext()方法。
方式二:ServletConfig提供了getServletContext()方法。
方式三:HttpSession提供了getServletContext()方法。
方式四:HttpServletRequest提供了getServletContext()方法。
```

#### 常用方法

+ getParameter()是获取POST/GET传递的参数值
+ getInitParameter获取Tomcat的server.xml中设置Context的初始化参数
+ getAttribute()是获取对象容器中的数据值
+ getRequestDispatcher()是请求转发

### 路径

![路径](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/%E8%B7%AF%E5%BE%84.png)

#### 客户端路径

超链接、表单、重定向都是客户端路径，客户端路径可以分为三种方式：

1. 绝对路径；   http://ip:port/项目名/请求
2. 以“/”开头的相对路径；  明确项目名
3. 不以“/”开头的相对路径

```jsp
<%-- http://localhost:8080/jsp03/index.jsp--%>
    <%--  客户端发起绝对路径请求 --%>
  <a href="http://localhost:8080/jsp03/login.jsp">绝对路径访问login</a>
    <%-- 客户端发起/开头的相对路径 --%>
  <a href="/jsp03/login.jsp">发起/开头的相对路径</a>
   <%-- 不以/开头--%>
  <a href="login.jsp">不以/开头</a>
```

在页面上封装根路径   java脚本版

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%
   /* http://ip:port/项目名/请求*/
    String basePath=request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+"/"+request.getContextPath()+"/";
%>
<html>
<head>
    <%--  当前页面默认基础路径是 basePath--%>
    <base href="<%=basePath%>">
```

使用el表达式版

```jsp
${pageContext.request.contextPath}/
```

#### 服务器路径

+ 服务器路径必须是相对路径,服务器的相对路径参数物取决于请求路径
+ sevlet的请求路径取决于:web.xml中servlet的请求配置

##### ServletContext获取资源

+ 必须是相对路径，可以“/”开头，也可以不使用“/”开头，但无论是否使用“/”开头都是相对当前应用路径

##### 重定向获取根路径

+ 使用request.getContextPath()来获取应用名称

```java
response.sendRedirect(request.getContextPath() + "/page");
```

## 监听器

> 监听器用于监听web应用中三大域对象、信息的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理。当范围对象的状态发生变化的时候，服务器自动调用监听器对象中的方法。常用于统计在线人数和在线用户，系统加载时进行信息初始化，统计网站的访问量等等。

### 三大域

+ ServletContext  全局作用域

	```
	•	生命周期监听：ServletContextListener，它有两个方法，一个在出生时调用，一个在死亡时调用；
		void contextInitialized(ServletContextEvent sce)：创建SErvletcontext时
		void contextDestroyed(ServletContextEvent sce)：销毁Servletcontext时
	•	属性监听：ServletContextAttributeListener，它有三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个是在移除属性时调用。
		void attributeAdded(ServletContextAttributeEvent event)：添加属性时；
		void attributeReplaced(ServletContextAttributeEvent event)：替换属性时；
		void attributeRemoved(ServletContextAttributeEvent event)：移除属性时；
	```

+ HttpSession

	```
	•	生命周期监听：HttpSessionListener，它有两个方法，一个在出生时调用，一个在死亡时调用；
		void sessionCreated(HttpSessionEvent se)：创建session时
		void sessionDestroyed(HttpSessionEvent se)：销毁session时
	•	属性监听：HttpSessioniAttributeListener，它有三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个是在移除属性时调用。
		void attributeAdded(HttpSessionBindingEvent event)：添加属性时；
		void attributeReplaced(HttpSessionBindingEvent event)：替换属性时
		void attributeRemoved(HttpSessionBindingEvent event)：移除属性时
	```

+ ServletRequest

	```
	•	生命周期监听：ServletRequestListener，它有两个方法，一个在出生时调用，一个在死亡时调用；
		void requestInitialized(ServletRequestEvent sre)：创建request时
		void requestDestroyed(ServletRequestEvent sre)：销毁request时
	•	属性监听：ServletRequestAttributeListener，它有三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个是在移除属性时调用。
		void attributeAdded(ServletRequestAttributeEvent srae)：添加属性时
		void attributeReplaced(ServletRequestAttributeEvent srae)：替换属性时
		void attributeRemoved(ServletRequestAttributeEvent srae)：移除属性时
	```

**实现接口**

```java
public class AppListeners implements ServletContextListener {}
```

## 过滤器

> 过滤器是用来拦截请求的，而不是处理请求的。 

### 过滤器的编写

```
1、编写java类实现Filter接口
2、重写doFilter方法
3、设置拦截的url
```

### 过滤器的请求顺序

> 一个目标资源可以指定多个过滤器，过滤器的执行顺序是在web.xml文件中的部署顺序

```
其实过滤器有四种拦截方式！分别是：REQUEST、FORWARD、INCLUDE、ERROR。
	REQUEST：直接访问目标资源时执行过滤器。包括：在地址栏中直接访问、表单提交、超链接、重定向，只要在地址栏中可以看到目标资源的路径，就是REQUEST；
	FORWARD：转发访问执行过滤器。包括RequestDispatcher#forward()方法、<jsp:forward>标签都是转发访问；
	INCLUDE：包含访问执行过滤器。包括RequestDispatcher#include()方法、<jsp:include>标签都是包含访问；
	ERROR：当目标资源在web.xml中配置为<error-page>中时，并且真的出现了异常，转发到目标资源时，会执行过滤器。
```

```xml
<filter-mapping>
        <filter-name>loginFilter</filter-name>
        <url-pattern>/*</url-pattern>
        <!--配置过滤器的拦截范围
            /*:根目录下所有请求都拦截
            /*.do:所有带有.do的请求都拦截
            /*.jsp
        -->
        <!--拦截器的四种拦截
            REQUEST:当前过滤器拦截直接请求
            FORWARD:当前过滤器拦截转发请求
            INCLUDE:当前过滤器拦截包含请求
            ERROR:当前过滤器拦截错误请求
        -->
        <dispatcher>REQUEST</dispatcher>
        <dispatcher>FORWARD</dispatcher>
        <dispatcher>INCLUDE</dispatcher>
        <dispatcher>ERROR</dispatcher>
    </filter-mapping>
    <error-page>
        <error-code>500</error-code>
        <location>/login.jsp</location>
    </error-page>
```

## 简单的MVC分层

```
m:model   模型  一般存放实体类    bean  dao    提供对象的

v:view  视图   页面  能看到的

c:controller  处理器	Servlet     业务逻辑层
```

**项目分包**

+ bean|entity|domain：放实体类
+ dao（data access object）：操作数据库的包
+ controller|servlet：放servlet
+ service：主要实现操作
+ util：工具类

## JSP

> java Server page   java的服务页面技术

1. JSP的本质是一个Servlet，Servlet能做的事情JSP都能做。
2. JSP能够以HTML页面的方式呈现数据，是一个可以嵌入Java代码的HTML。
3. JSP不同于HTML，不能使用浏览器直接打开，而必须运行在Servlet容器中。

**JSP运行流程：**

![jsp运行流程](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/jsp%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png)

### JSP的基本语法

+ <%...%>：Java语句； java片段  在一个页面中 所有的片段相通
+ <%= java表达式%>  主要作用是输出  >=  <% out.write("...");%>（out只能输出字符串类型，而=可以输出任意类型）
+ <%!...%>：Java定义类成员；一般不在jsp上定义类成员

### JSP指令

> JSP指令（directive）是为JSP引擎而设计的，它们并不直接产生任何可见输出，而只是告诉引擎如何处理JSP页面中的其余部分。

+ <%@ 指令名 属性名="值" %>

#### page指令

> page指令用于定义JSP页面的各种属性，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面。为了保持程序的可读性和遵循良好的编程习惯，**page指令最好是放在整个JSP页面的起始位置**

```jsp
JSP 2.0规范中定义的page指令的完整语法：
<%@ page 
	[ language="java" ] 
	[ extends="package.class" ] 
	[ import="{package.class | package.*}, ..." ] 
	[ session="true | false" ] 
	[ buffer="none | 8kb | sizekb" ] 
	[ autoFlush="true | false" ] 
	[ isThreadSafe="true | false" ] 
	[ info="text" ] 
	[ errorPage="relative_url" ] 
	[ isErrorPage="true | false" ] 
	[contentType="mimeType [ ;charset=characterSet ]" | "text/html ; charset=ISO-8859-1" ]
	[ pageEncoding="characterSet | ISO-8859-1" ] 
	[ isELIgnored="true | false" ] 
%>
```

```
[1]import属性：指定 JSP 页面转换成 Servlet时应该导入的包。

[2]pageEncoding属性：设置JSP页面翻译成Servlet源文件时使用的字符集。

[3]contentType属性：设置 Content-Type 响应报头，标明即将发送到客户程序的文档的 MIME 类型以及浏览器对  			    响应内容的解码字符集。 

[4]errorPage属性：指定当前JSP抛出异常时的转发页面。

[5]isErrorPage属性：指定当前页面是不是一个显示错误消息的页面，如果是，则会自动创建exception对象，否则就					不会创建exception对象。

[6]session属性：控制页面是否参与HTTP会话，其本质是要不要自动创建session隐含对象以供使用。

[7]isELIgnored属性：指定当前页面是否忽略EL表达式，如果忽略，EL表达式的内容将会原封不动的输出到浏览器						端。
```

#### include指令

> **include指令用于通知JSP引擎在翻译当前JSP页面时**将其他文件中的内容合并进当前JSP页面转换成的Servlet源文件中，这种在源文件级别进行引入的方式称之为静态引入，当前JSP页面与静态引入的页面紧密结合为一个Servlet。

+ <%@ include file="relativeURL"%>	其中的file属性用于指定被引入文件的**相对路径**。  

**细节：**

+ 被引入的文件必须遵循JSP语法，其中的内容可以包含静态HTML、JSP脚本元素、JSP指令和JSP行为元素等普通JSP页面所具有的一切内容。
+ 被引入的文件可以使用任意的扩展名，即使其扩展名是html，JSP引擎也会按照处理JSP页面的方式处理它里面的内容，为了见明知意，JSP规范建议使用.jspf（JSP fragments）作为静态引入文件的扩展名。
+ 在将JSP文件翻译成Servlet源文件时，JSP引擎将合并被引入的文件与当前JSP页面中的指令元素（**设置pageEncoding属性的page指令除外**），所以，**除了import和pageEncoding属性之外，page指令的其他属性不能在这两个页面中有不同的设置值。** 

#### taglib指令

> taglib指令用来引用标签库并设置标签库的前缀。这个指令允许JSP页面使用用户自定义的标签。

+ <%@ tagliburi="标签库URI"   prefix="自定义标签前缀" %>
	uri：用来指定标签文件或标签库的存放位置；prefix：用来指定该标签库使用的前缀。

### JSP的九大内置对象

> jsp是对servlet进行了一定程度的封装，服务器给jsp提供了9个隐式对象，可以直接使用

| 对象名          | 类型                                   | 说明                        | 作用                                       |
| --------------- | -------------------------------------- | --------------------------- | ------------------------------------------ |
| request         | javax.servlet.http.HttpServletRequest  |                             | 请求对象，封装了客户端向服务器发送的数据   |
| response        | javax.servlet.http.HttpServletResponse |                             | 响应对象，封装了服务器向客户端发送的数据   |
| session         | javax.servlet.http.HttpSession         | 由session=“true”开关        | 会话对象                                   |
| application     | javax.servlet.ServletContext           | Servlet中的ServletContext   | 应用程序对象                               |
| config          | javax.servlet.ServletConfig            | Servlet中的ServletConfig    | 配置对象                                   |
| exception       | java.lang.Throwable                    | 由isErrorPage=“false”开关   | 异常 报错                                  |
| out             | javax.servlet.jsp.JspWriter            | javax.servlet.jsp.JspWriter | 输出流，向客户端浏览器输出的流对象。 <%=%> |
| **pageContext** | javax.servlet.jsp.PageContext          | 域对象，获取其他八大对象    | 页面上下文对象                             |
| page            | java.lang.Object当前对象this           | 当前servlet实例             | 页面，当前页面对象                         |

#### 隐式对象的获取

> 在普通类中可以通过PageContext获取其它JSP隐式对象

```
getException方法返回exception隐式对象 
getPage方法返回page隐式对象
getRequest方法返回request隐式对象 
getResponse方法返回response隐式对象 
getServletConfig方法返回config隐式对象
getServletContext方法返回application隐式对象
getSession方法返回session隐式对象 
getOut方法返回out隐式对象
```

### JSP的四大域对象

| 域对象      | 作用范围    | 起始时间    | 结束时间    |
| ----------- | ----------- | ----------- | ----------- |
| pageContext | 当前JSP页面 | 页面加载    | 离开页面    |
| request     | 同一个请求  | 收到请求    | 响应        |
| session     | 同一个会话  | 开始会话    | 结束会话    |
| application | 当前Web应用 | Web应用加载 | Web应用卸载 |

**域对象，可以存取属性值，用来在域中共享。**

+ 四大域对象是我们传递参数的容器
+ 在JavaWeb中一共四个域对象，其中Servlet中可以使用的是request、session、application三个对象，而在JSP中可以使用pageContext、request、session、application四个域对象。 
+ 域对象有各自的传值范围：域对象的生命周期

#### 域对象的使用

> 作用域对象都是基于MAP格式（key-value）的容器。

1. void setAttribute(String key , Object value) ：保存数据
2. Object getAttribute(String key) ： 获取数据；getAttribute方法只能获取使用setAttribute方法放入的数据
3. void removeAttribute(String name)：删除指定的数据

**注意：**

+ 在同一个域中出现相同key，后来的value会覆盖之前的value  参照map集合
+ 在不同域中出现同名key，会取出最小域中的key
+ el表达式默认从最小域中取值，我们可以声明从哪个域中取值$（域对象名Scope）

### EL表达式

> JSP2.0要把html和css分离、要把html和javascript分离、要把Java脚本替换成标签。标签的好处是非Java人员都可以使用。
>
> EL（Expression Language）是一门表达式语言，它对应<%=…%>。在JSP中，表达式会被输出，所以EL表达式也会被输出。

#### el表达式格式：${}

>  ${}:表示输出数据    用来替代<%=%>

```
核心功能:取域对象的值  
格式如： ${EL表达式} 等价于getAttribute(name)
```

#### 关闭EL表达式

如果希望整个JSP忽略EL表达式，需要在page指令中指定isELIgnored=”true”。

#### EL表达式的运算符

| 运算符   | 说明     | 范例                                                         | 结果  |
| -------- | -------- | ------------------------------------------------------------ | ----- |
| +        | 加       | ${17+5}                                                      | 22    |
| -        | 减       | ${17-5}                                                      | 12    |
| *        | 乘       | ${17*5}                                                      | 85    |
| /或div   | 除       | ${17/5}或{17 div 5}                                          | 3     |
| %或mod   | 取余     | ${17%5}或{17 mod 5}                                          | 2     |
| ==或eq   | 等于     | ${5==5}或{5 eq 5}                                            | true  |
| !=或ne   | 不等于   | ${5!=5}或{5 ne 5}                                            | false |
| <或lt    | 小于     | ${3<5}或{3 lt 5}                                             | true  |
| >或gt    | 大于     | ${3>5}或{3 gt 5}                                             | false |
| <=或le   | 小于等于 | ${3<=5}或{3 le 5}                                            | true  |
| >=或ge   | 大于等于 | ${3>=5}或​{3 ge 5}                                            | false |
| &&或and  | 并且     | ${true&&false}或{true and false}                             | false |
| !或not   | 非       | ${!true}或{not true}                                         | false |
| \|\|或or | 或者     | ${true\|\|false}或${true or false}                           | true  |
| empty    | 是否为空 | ${empty “”}，可以判断字符串、数据、集合的长度是否为0，为0返回true。empty还可以与not或!一起使用。${not empty “”} | true  |

**注：**

+ +加号  在el表达式中只有一个功能，进行加法运算。不支持字符串的连接。
+ / 除法  在el表达式中可以进行正常的除法计算的。${10/4} --- 2.5
+ 当EL表达式的值为null时，会在页面上显示空白，即什么都不显示。

#### EL表达式的应用

+ 操作bean的属性：${person.name}、${person[‘name’]}，对应person.getName()方法；

+ 操作List和数组：${list[0]}、${arr[0]}；

+ 操作Map的值：${map.key}、${map[‘key’]}，对应map.get(key)。

+ 使用EL表达式的empty关键字：为空即为true

	```
	${empty s1}
	```

#### EL表达式的内置对象

> EL一共11个内置对象，无需创建即可以使用。这11个内置对象中有10个是Map类型的，最后一个是pageContext对象。 

| pageScope        | page域        |
| ---------------- | ------------- |
| requestScope     | request域     |
| sessionScope     | session域     |
| applicationScope | appliaction域 |
| param；          |               |
| paramValues；    |               |
| header；         |               |
| headerValues；   |               |
| initParam；      |               |
| cookie；         | 会话管理对象  |
| pageContext；    | 上下文        |

+ pageScope：${pageScope.name}等同与pageContext.getAttribute(“name”)；
+ requestScope：${requestScope.name}等同与request.getAttribute(“name”)；
+ sessionScoep： ${sessionScope.name}等同与session.getAttribute(“name”)；
+ applicationScope：${applicationScope.name}等同与application.getAttribute(“name”)；

### JSTL标签库

> Java Server Pages Standard Tag Library——JSP标准标签库。

+ JSTL是一个标准的、已制定好的标签库，可以应用于各种领域，如：**基本输入输出**、**流程控制**（**分支**、**迭代**）、XML文件剖析、数据库查询及**国际化**和文字格式标准化的应用等。
+ JSTL所提供的标签函数库主要分为五大类：
	1. **核心标签库**（Core tag library）
	2. **I18N格式标签库**（I18N-capable formatting tag library）  低版本的jdk和Tomcat需要
	3. SQL标签库（SQL tag library）
	4. XML标签库（XML tag library）
	5. **函数标签库**（Functions tag library）

**操作步骤：**

```java
导入jar：
	jstl核心包
	standard辅助包
在jsp上引入jstl标签库：
	<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
```

#### 常用的标签

| **标签名称** | 功能分类   |
| ------------ | ---------- |
| out          | 表达式操作 |
| set          |            |
| remove       |            |
| if           | 流程控制   |
| choose       |            |
| when         |            |
| otherwise    |            |
| forEach      |            |
| forTokens    |            |
| param        | URL操作    |
| url          |            |
| redirect     |            |

```jsp
c:out
输出域对象指定属性名所对应的属性值, 如果为null, 显示默认值
<c:out value="${name}" default="defaultValue"/>
c:set
①向域对象中保存指定的属性名和属性值
<c:set value="${person.name}" var="myName"/>
②修改域对象中JavaBean的属性值
<c:set target="${person}" property="name" value="Jack"/>
c:remove
删除域对象中的指定属性
<c:remove var="myName"/>
```

+ if标签的test属性必须是一个boolean类型的值，如果test的值为true，那么执行if标签的内容，否则不执行。

```jsp
一重条件判断[c:if]
多个c:if之间是没有任何关系的
<% pageContext.setAttribute("age", "25"); %>
<c:if test="${age < 18 }">祖国的花骨朵</c:if>
<c:if test="${age >= 18 && age < 25 }">2B青年</c:if>
<c:if test="${age >= 25 && age < 40 }">苦B青年</c:if>
<c:if test="${age >= 40 && age < 50 }">年富力强</c:if>
<c:if test="${age >= 50 && age < 65 }">享受成功</c:if>
<c:if test="${age >= 65 }">退休生活</c:if>
```

+ choose标签对应Java中的if/else if/else结构。when标签的test为true时，会执行这个when的内容。当所有when标签的test都为false时，才会执行otherwise标签的内容。

```jsp
多重条件判断[c:choos/c:when/c:otherwise]
程序执行时，按照从上往下的顺序执行c:when，一旦找到满足条件的c:when就不再继续执行了，如果没有任何满足的c:when则执行c:otherwise。
<c:choose>
	<c:when test="${age < 18 }">祖国的花骨朵</c:when>
	<c:when test="${age < 25 }">2B青年</c:when>
	<c:when test="${age < 40 }">苦B青年</c:when>
	<c:when test="${age < 50 }">年富力强</c:when>
	<c:when test="${age < 65 }">享受成功</c:when>
	<c:otherwise>退休生活</c:otherwise>
</c:choose>
```

forEach当前就是循环标签了，forEach标签有多种两种使用方式：

+ 使用循环变量，指定开始和结束值，类似for(int i = 1; i <= 10; i++) {}；

```jsp
 <%--  这种方式  for(int i=0;i<10;i++){}--%>
<c:forEach begin="1" end="10" var="i">
    ${i}<br/>
</c:forEach>
```

+ 循环遍历集合，类似for(Object o : 集合)；

```jsp
<%--  增强for  for(数据类型 变量 : 集合){}--%>
<c:forEach items="${集合}" var="变量" varStatus="index">
    ${变量}
</c:forEach>
```

+ 重定向

```jsp
<%-- 使用context属性指定项目虚拟路径，使用url属性指定重定向的目标位置 --%>
<c:redirect
 context="${pageContext.request.contextPath }"//根路径
 url="/target2.jsp" />
```

+ 传递请求参数

```jsp
<%-- 使用context属性指定项目虚拟路径，使用url属性指定重定向的目标位置 --%>
<c:redirect
 context="${pageContext.request.contextPath }"
 url="/target2.jsp">
	<%-- 使用name属性指定请求参数名，使用value属性指定请求参数值 --%>
	<c:param name="sayHi" value="hi..."></c:param>
</c:redirect>
```

## Servlet3.0的注解配置

> tomcat6.0的servlet版本是2.5  没有注解，tomcat7.0及以后的版本   servlet3.0有了注解方式

### @WebServlet 

![WebServlet](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/WebServlet.png)

```java
//servlet  需要由服务器分发请求
//我们需要提前告知服务器  那个请求是访问当前servlet
//用注解的方式  配置当前servlet请求
//一个servlet 可以配置多个请求
//loadOnStartup servlet的加载顺序   默认是-1   请求过来才加载当前servlet
//@WebServlet(name="first",value={"/first.do","/firstDemo.do"},loadOnStartup = 1)
//注解  提供简化写法  配置单个请求  省略name   不用value   其它都是默认
//@WebServlet("/first.action")
public class FirstServlet extends HttpServlet {}
```

### @WebFilter

<img src="https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/WebFilter.png" alt="WebFilter" style="zoom:150%;" />



```java
//@WebFilter(filterName = "EncodeFilter",value="/*")
@WebFilter("/*")
public class FirstFilter implements Filter {}
```

### @WebListener

> 监听器  是不需要请求的  服务器一启动  监听器就准备就绪,监听所有  在特定事件触发时做反应

```java
@WebListener
public class AttrListener implements HttpSessionAttributeListener {}
```

## 功能模块

### 文件上传

**导入commons-fileupload.jar和commons-io.jar包**

1. form表单的method属性必须是post
1. 在要上传的form标签中添加enctype="multipart/form-data"属性
2. 在接受form表单的服务器上添加@MultipartConfig表示开启该服务器可以识别Multipart属性
3. 在属性为file的input标签中设置multiple属性可以上传多文件

```java
//Servlet3.0版  文件上传的处理
//接收文件	从请求中读取字节
Part part = request.getPart("unFile");
//上传文件的大小
long size = part.getSize();
//input输入项的name
String inputFileName = part.getName();
//上传文件名
String fileName = part.getSubmittedFileName();
//存放到指定位置
part.write("D:/.."+filename);
```

### 多文件上传

```java
Collection<Part> parts = request.getParts();
for(Part part : parts){
    String fileName = part.getSubmittedFileName();
    if(fileName!=null && !"".equals(fileName)){
        part.write("D:/"+fileName);
    }
}
```

#### 路径

```java
//先修改war所在的输出路径	获取web下的指定路径
request.getServletContext().getRealPath("/fileuploa");
```

### 文件下载

```java
//获取文件名
String fileName = request.getParameter("fileName");
//获取指定文件名字的文件
String path = request.getServletContext().getRealPath("/fileupload");
File file = new File(path + "/" + fileName);
//验证文件是否存在
if(!file.exists()){
    System.out.println("文件不存在!")
    return;
}
//文件存在 开始下载
String hz = fileName.substring(fileName.lastIndexOf("."));
response.setHeader("content-disposition",
                "attachment;filename=" + 文件名 + hz);
//利用io流传递文件
FileInputStream fis = new FileInputStream(file);
//创建输出流
OutputStream os = response.getOutputStream();//字节流
byte[] bytes = new byte[1024];
int len = 0;
while((len = fis.read(bytes))!=-1){
    os.write(bytes,0,len);
}
fis.close;
os.close;
```

### 分页

> 在展示数据时，每次查询一定量的数据

+ 减轻对数据库访问的压力
+ 减少内存的压力
+ 提高展示效率

### 图片验证码

> 导入validatecode.jar

```java
public class CodeServlet extends HttpServlet {
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1.设置生成规则
		/**
		 * width：验证码的宽度  px 像素
		 * height: px
		 * codeCount:生成验证码有几个数
		 * lineCount:有几根线
		 */
        //200高，50宽，6个数字，20干扰线
		ValidateCode code = new ValidateCode(200, 50, 6, 20);
		//2.获取生成的验证码的字符串值
		System.out.println(code.getCode()); //获取正确值
		//3.响应写回验证图片
		code.write(response.getOutputStream());
	}
} 
```

## AJAX

> ajax是异步、局部刷新技术

> AJAX = 异步 JavaScript 和 XML(Asynchronized JavaScript And  XML)

+ 同步提交：当前页面整体发生改变   页面整体跳转到其它页面
+ 异步提交：当前页面不会发生页面的跳转   页面的局部位置发起请求

### 1. 异步请求对象（XMLHttpRequest）

```javascript
//封装获取异步对象的方法
function getXMLHttpRequest(){
    var xmlHttpRequest;
    if (window.XMLHttpRequest)
    {// code for IE7+, Firefox, Chrome, Opera, Safari
        xmlHttpRequest=new XMLHttpRequest();
    }
    else {// code for IE6, IE5
        xmlHttpRequest=new ActiveXObject("Microsoft.XMLHTTP");
    }
    return  xmlHttpRequest;
}
```

### 2. 发送异步请求

| 方法                         | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| open(*method*,*url*,*async*) | 规定请求的类型、URL 以及是否异步处理请求。*method*：请求的类型；GET 或 POST*url*：文件在服务器上的位置*async*：true（异步）或 false（同步） |
| send(*string*)               | 将请求发送到服务器。*string*：仅用于 POST 请求               |

```js
//获取异步对象
var  xmlHttpRequest = getXMLHttpRequest();
//设置异步对象的请求
/*
       *  open方法的三个参数
       *  method:请求方式   get/post
       *  url:异步请求地址
       *  async:是否异步   true异步(默认)   false同步
       * */
xmlHttpRequest.open("get","url",true);
//发送请求
xmlHttpRequest.send();
```

### 3. 等待响应

| 属性               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| onreadystatechange | 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 |
| readyState         | 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 |
| status             | 200: "OK"404: 未找到页面                                     |

```js
//等待服务器做出响应
//我们让异步对象监听服务器的状态码
xmlHttpRequest.onreadystatechange=function(){
    alert("状态码:"+xmlHttpRequest.readyState);
    //判断到状态码为4
    if(xmlHttpRequest.readyState==4){
        //说明服务器请求处理完毕  且响应成功
        //我们需要判断响应码  200  404  500 304  302
        if(xmlHttpRequest.status==200){
            //接收到信息
            alert("响应成功");
        }
    }
}
```

### 4. 接收响应信息

| 属性         | 描述                       |
| ------------ | -------------------------- |
| responseText | 获得字符串形式的响应数据。 |

```js
//Servlet中输出
response.getWriter().write("ok");
```

```js
//js中接收到信息
var str = xmlHttpRequest.responseText;
alert("服务器的响应信息为:"+str);
```

### Jquery的AjAx

```js
//jQuery对ajax的封装
$.ajax({
    //{}以数组类型进行参数配置   每组值用逗号隔开  最后一个不需要逗号
    //用key-value方式  进行参数配置
    //type==method  请求方式
    type:"get",
    //url 是请求路径
    url:"",
    //async  是否异步 默认异步
    async:true,
    //cache  是否在浏览器中产生缓存  默认false
    cache:false,
    //contentType  (默认: "application/x-www-form-urlencoded") 发送信息至服务器时内容编码类型
    contentType:"application/x-www-form-urlencoded",
    //data  是发送给服务器的参数
    data:"uname=zs&upwd=123",
    //dataType  服务器响应值的预期数据类型  text  xml  json	html	JavaScript
    dataType:"",
    //enctype  异步文件上传时的操作
    enctype:"multipart/form-data",
    //success  服务器成功响应  状态码和响应码的判断都在这
    //成功得到的是一个回调函数
    success:function(aaa){
        //成功的回调函数中的形参  会自动接收服务器的回值
    },
    //失败时的回调函数
    error:function(bbb){}
});
```

### jQuery的get和post请求

```js
$(function(){
    $("#but1").click(function () {
        $.ajax({
            type:"get",
            url:"${pageContext.request.contextPath}/ajax.action",
            async:true,
            success:function(data){
            }
        });
    });
    $("#but2").click(function(){
        $.ajax({
            type:"post",
            url:"${pageContext.request.contextPath}/ajax.do",
            data:"uname=zs&upwd=123",
            async:true,
            success:function(data){
            }
        });
    });
});
```

**简化：**

```js
$(function(){
    $.get("url",[data],[function(回执){}],[回执格式])[]可写可不写
	$.post("${pageContext.request.contextPath}/ajax.do","uname="+uname,[function(回执){
        alert(回执);
    }],"text")
});
```

## JSON

> JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。易于机器解析和生成，并有效地提升网络传输效率。

```js
 //json
//简单的json
var person = {"name":"zs","age":18,"sex":true};
alert(person+"---"+typeof(person));
alert(person.name);
//复杂的json
var persons =[
    {"name":"zs","age":18,"sex":true},
    {"name":"李四","age":18,"sex":false},
    {"name":"王五","age":18,"sex":true}
]
$.each(persons,function(i,n){
    alert(n.name);
});
//更复杂的json
var persons1 =[
    {"name":"zs","age":18,"sex":true,"hobbys":[{"hobby":"游泳"},{"hobby":"看书"}]},
    {"name":"李四","age":18,"sex":false,"hobbys":[{"hobby":"游泳"},{"hobby":"看书"}]},
    {"name":"王五","age":18,"sex":true}
]
for(var i=0;i<persons1.length;i++){
    var person = persons1[i];
    alert(person.name+"---"+person.sex);
    $.each(person.hobbys,function(i,n){
        alert(n.hobby);
    });
}
```

### Java传递json

```java
//回值是json串
//json对象的用法  和map集合一样
JSONObject json = new JSONObject();
json.put("id", 1);
json.put("name", "亚索");
json.put("age", 18);
response.getWriter().write(json.toString());
```

### 接受json

由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。

eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：

```js
var obj = eval ("(" + data + ")");
```

### 把java对象直接转换成json对象

#### 单个对象

```java
User user = new User(1, "锐雯", 21, "女");
String json = JsonUtil.fromObject(user);
response.getWriter().write(json);
```

#### List

```java
List<User> users = new ArrayList();
User user1 = new User(1, "亚索", 18, "男");
User user2 = new User(2, "锐雯", 19, "女");
User user3 = new User(3, "佐伊", 17, "女");
users.add(user1);
users.add(user2);
users.add(user3);
String json = JsonUtil.fromObject(users);
response.getWriter().write(json);
```

```js
$.each(data,function (i,n){
	alert(n.id + n.name + n.age + n.sex);
})
```

#### Map

```java
HashMap<String, User> map = new HashMap<>();
User user1 = new User(1, "亚索", 18, "男");
User user2 = new User(2, "锐雯", 19, "女");
User user3 = new User(3, "佐伊", 17, "女");
map.put("user1", user1);
map.put("user2", user2);
map.put("user3", user3);
String json = JsonUtil.fromObject(map);
response.getWriter().write(json);
```

```js
for (var key in data){
	var a = data[key];
	for (var k in a){
		var b = a[k]
		alert(b.id + b.name + b.sex + b.age);
	}
}
```

## Selenium

> Selenium是一个用于Web应用程序测试的工具

+ 浏览器驱动chromeDriver

+ 准备Maven依赖

	```xml
	<dependency>
		<groupId>org.seleniumhq.selenium</groupId>
		<artifactId>selenium-java</artifactId>
		<version>4.0.0</version>
	</dependency>
	```

+ ```java
	System.getProperties().setProperty("webdriver.chrome.driver", "D:\\Java\\chromedriver.exe");
	WebDriver driver = new ChromeDriver();
	driver.get(url);
	```


https://blog.csdn.net/qq_22003641/article/details/79137327?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79137327-blog-123590369.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-79137327-blog-123590369.pc_relevant_default&utm_relevant_index=2

## Maven

> Maven 可以把 jar 包所依赖的其它 jar 包自动下载并引入项目。

### 构建

>  构建（build），是面向过程的(从开始到结尾的多个步骤)，涉及到多个环节的协同工作。

1. 清理：删除以前的编译结果，为重新编译做好准备。
2. 编译：将Java源程序编译为字节码文件。 
3. 测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。 
4. 报告：在每一次测试后以标准的格式记录和展示测试结果。 
5. 打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web工程对应war包。 
6. 安装：在Maven环境下特指将打包的结果——jar包或war包安装到本地仓库中。 
7. 部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行

### Maven实现自动化过程

1. POM  

2. 约定的目录结构 
3. 坐标 
4. 依赖管理 
5. 仓库管理 
6. 生命周期 
7. 插件和目标 
8. 继承 
9. 聚合 

### settings.xml

```xml
<!--本地仓库位置-->
<localRepository>E:\javatools\repository</localRepository>
配置maven插件
<pluginGroups>
    <!-- pluginGroup
     | Specifies a further group identifier to use for plugin lookup.
    <pluginGroup>com.your.plugins</pluginGroup>
    -->
	<!--加入插件组，解决idea的maven项目tomcat插件debug无法运行的问题-->
	<pluginGroup>org.apache.tomcat.maven</pluginGroup>
  </pluginGroups>
  镜像文件   提高maven工程的构建和jar包的引入
  <mirrors>
		<!-- 阿里镜像 -->
		<mirror>
			<id>alimaven</id>
			<mirrorOf>central</mirrorOf>
			<name>aliyun maven</name>
			<url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
		</mirror>
    <mirror>
			<id>alimaven</id>
			<name>aliyun maven</name>
			<url>http://maven.aliyun.com/nexus/content/groups/public/</url>
			<mirrorOf>central</mirrorOf>
		</mirror>
		<mirror>
			<id>central</id>
			<name>Maven Repository Switchboard</name>
			<url>http://repo1.maven.org/maven2/</url>
			<mirrorOf>central</mirrorOf>
		</mirror>
		<mirror>
			<id>repo2</id>
			<mirrorOf>central</mirrorOf>
			<name>Human Readable Name for this Mirror.</name>
			<url>http://repo2.maven.org/maven2/</url>
		</mirror>
		<mirror>
			<id>ibiblio</id>
			<mirrorOf>central</mirrorOf>
			<name>Human Readable Name for this Mirror.</name>
			<url>http://mirrors.ibiblio.org/pub/mirrors/maven2/</url>
		</mirror>
		<mirror>
			<id>jboss-public-repository-group</id>
			<mirrorOf>central</mirrorOf>
			<name>JBoss Public Repository Group</name>
			<url>http://repository.jboss.org/nexus/content/groups/public</url>
		</mirror>
		<mirror>
			<id>google-maven-central</id>
			<name>Google Maven Central</name>
			<url>https://maven-central.storage.googleapis.com
			</url>
			<mirrorOf>central</mirrorOf>
		</mirror>
		<!-- 中央仓库在中国的镜像 -->
		<mirror>
			<id>maven.net.cn</id>
			<name>oneof the central mirrors in china</name>
			<url>http://maven.net.cn/content/groups/public/</url>
			<mirrorOf>central</mirrorOf>
		</mirror>
  </mirrors>
  <!--更改默认的JDK-->
	    <profile>
        <id>jdk-1.8</id>  
        <activation>  
          <activeByDefault>true</activeByDefault>  
          <jdk>1.8</jdk>  
        </activation>  
        <properties>  
          <maven.compiler.source>1.8</maven.compiler.source>  
          <maven.compiler.target>1.8</maven.compiler.target>  
          <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>  
        </properties>  
      </profile>
```

**创建maven的web工程要注意文件缺省**

**Maven** **工程约定目录结构** 

| src/main/java          | application library sources - java源代码文件                 |
| ---------------------- | ------------------------------------------------------------ |
| **src/main/resources** | application library resources - 资源库，会自动复制到classes文件夹下 |
| **src/main/webapp**    | web application sources - web应用的目录，WEB-INF,js,css等    |
| **src/test/java**      | 单元测试java源代码文件                                       |
| **src/test/resources** | 测试需要的资源库                                             |
| **target/**            | 存放项目构建后的文件和目录，jar包,war包，编译的class文件等；Maven构建时生成的 |
| **pom.xml**            | 工程描述文件                                                 |

![maven仓库](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/maven%E4%BB%93%E5%BA%93.png)

### pom.xml

> 即 Project Object Model 项目对象模型。Maven 把一个项目的结构和内容抽象成一个模型，在 xml 文件中

| modelVersion | Maven 模型的版本，对于 Maven2 和 Maven3 来说，它只能是 4.0.0 |
| ------------ | ------------------------------------------------------------ |
| groupId      | 组织 id，一般是公司域名的倒写。 格式可以为： 1. 域名倒写。 例如 com.baidu 2. 域名倒写+项目名。例如 com.baidu.app |
| version      | 项目的版本号。如果项目还在开发中，是不稳定版本， 通常在版本后带-SNAPSHOT version 使用三位数字标识，例如 1.1.0 |
| packaging    | 项目打包的类型，可以使 jar、war、rar、ear、pom，默认是 jar   |

**groupId 、 artifactId 、 version 三个元素组成了当前maven项目的坐标**

+ 在众多的 maven 项目中可以唯一定位到某一个项目。坐标也决定着将来项目在仓库中的路径及名称

```xml
 <modelVersion>4.0.0</modelVersion>
  <!--当前工程的打包性质  默认是打成jar包   web工程需要指定是war-->
  <packaging>war</packaging>
 <!--当前工程的三要素
  groupId：包名
  artifactId：工程名
  version：版本号
  groupId 、 artifactId 、 version 三个元素 组成了当前maven项目的坐标
在众多的 maven 项目中可以唯一定位到某一个项目。坐标也决 定着将来项目在仓 库 中 的 路 径 及 名 称。
 -->
  <name>maven002</name>
  <groupId>com.bjpn</groupId>
  <artifactId>maven002</artifactId>
  <version>1.0-SNAPSHOT</version>
```

```xml
<!--全局设置-->
    <properties>
      <!--源码编译 jdk 版本-->
      <maven.compiler.source>1.8</maven.compiler.source>
      <!--运行代码的 jdk 版本-->
      <maven.compiler.target>1.8</maven.compiler.target>
      <!--项目构建使用的编码，避免中文乱码-->
      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
      <!--生成报告的编码-->
      <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    </properties>
```

```xml
<!--  dependencies：依赖管理  管理当前项目的第三方依赖
相当于引入第三方jar文件  通过jar的三要素  maven坐标  从maven仓库中引入该依赖
-->
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
<!--scope      对待依赖的处理方式-->
      <scope>test</scope>
    </dependency>
  </dependencies>
```

```xml
<!-- 项目构建时  扫描主程序下的 配置文件-->
<build>
<!--配置资源扫描-->
  <resources>
    <resource>
      <directory>src/main/java</directory><!--所在的目录-->
      <includes><!--包括目录下的.properties,.xml 文件都会扫描到-->
        <include>**/*.properties</include>
        <include>**/*.xml</include>
      </includes>
      <!-- filtering 选项 false 不启用过滤器， *.property 已经起到过滤的作用了 -->
      <filtering>false</filtering>
    </resource>
  </resources>
</build>
```

```
构建
build 
表示与构建相关的配置，例如设置编译插件的 jdk 版本
继承
parent 
在 Maven 中，如果多个模块都需要声明相同的配置，例如：groupId、
version、有相同的依赖、或者相同的组件配置等，也有类似 Java 的继承机
制，用 parent 声明要继承的父工程的 pom 配置。
聚合
modules 在 Maven 的多模块开发中，为了统一构建整个项目的所有模块，可以提供一
个额外的模块，该模块打包方式为 pom，并且在其中使用 modules 聚合的
其它模块，这样通过本模块就可以一键自动识别模块间的依赖关系来构建所有
模块，叫 Maven 的聚合。
```

### maven的生命周期

![maven生命周期](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

- **compile**

	```
	compile 是 maven 工程的编译命令，作用是将 src/main/java 下的文件编译为 class 文件输出到 target目录下。
	```

- **test**

	```
	test 是 maven 工程的测试命令 mvn test，会执行 src/test/java 下的单元测试类。
	```

- **clean**

	```
	clean 是 maven 工程的清理命令，执行 clean 会删除 target 目录及内容。
	```

- **package**

	```
	package 是 maven 工程的打包命令，对于 java 工程执行 package 打成 jar 包，对于 web 工程打成 war包。
	```

- **install**

	```
	install 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。
	```


**每一个步骤都会把前面的步骤再执行一遍**

```
- Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 
- Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。 
- Site Lifecycle 生成项目报告，站点，发布站点。 
```

### jar包依赖管理的生命周期

![maven依赖管理生命周期](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

+ compile

	```
	编译范围，指 A 在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。
	```

- provided

	```
	provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用， provided 依 赖在编译和测试时需要，在运行时不需要，比如：servlet api 被 tomcat 容器提供。
	```

- runtime

	```
	依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。
	```

- test

	```
	test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以 test范围依赖不会被打包。
	```

- system

	```
	system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR文件的路径，需要指定 systemPath 磁盘路径，system依赖不推荐使用。
	```

### 本地jar包导入本地maven仓库

```
mvn install:install-file -Dfile=D:\Test\Java\03-JavaWeb\03\ValidateCode.jar -DgroupId=cn.dsna -DartifactId=ValidateCode -Dversion=1.0.0 -Dpackaging=jar
```

```
mvn install:install-file 
-Dfile:  jar包所在本地路径，不能有中文
-DgroupId: 项目组织唯一的标识符，实际对应JAVA的包的结构
-DartifactId:	项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称
-Dversion:		版本号
-Dpackaging:	打包的类型  jar   war
```



## 框架

> 框架是基于某种思想对某个或某些功能的封装

### 三层架构

+ 界面层（User Interface Layer）：接受用户的数据，显示请求的处理结果
+ 业务逻辑层（Business Logic Layer）：接收表示传递过来的数据，检查数据，计算业务逻辑，调用数据访问层获取数据
+ 数据访问层（Data Access Layer）：实现对数据的增、删、改、查。将存储在数据库中的数据提交给业务层，同时将业务层处理的数据保存到数据库

### 三层的处理请求的交互：

![三层处理请求的交互](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/%E4%B8%89%E5%B1%82%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BA%A4%E4%BA%92.png)

**优点：**

+ 结构清晰、耦合度低，各层分工明确
+ 可维护性高，可扩展性高
+ 有利于标准化
+ 开发人员可以只关注整个结构中的其中某一层的功能实现
+ 有利于各层逻辑的复用

### 常用的框架

```
MyBatis 框架：
MyBatis 是一个优秀的基于 java 的持久层框架，内部封装了 jdbc，开发者只需要关注 sql 语句
本身，而不需要处理加载驱动、创建连接、创建 statement、关闭连接，资源等繁杂的过程。
MyBatis 通过 xml 或注解两种方式将要执行的各种 sql 语句配置起来，并通过 java 对象和 sql 的
动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 
对象并返回。
```

```
Spring 框架：
Spring 框架为了解决软件开发的复杂性而创建的。Spring 使用的是基本的 JavaBean 来完成以前
非常复杂的企业级开发。Spring 解决了业务对象，功能模块之间的耦合，不仅在 javase,web 中使用，
大部分 Java 应用都可以从 Spring 中受益。
Spring 是一个轻量级控制反转(IoC)和面向切面(AOP)的容器。
```

```
SpringMVC 框架
Spring MVC 属于 SpringFrameWork 3.0 版本加入的一个模块，为 Spring 框架提供了构建 Web 
应用程序的能力。现在可以 Spring 框架提供的 SpringMVC 模块实现 web 应用开发，在 web 项目中
可以无缝使用 Spring 和 Spring MVC 框架。
```

## mybatis

> 数据访问层框架	

```
mybatis的核心思想：orm思想   对象关系映射

数据库中的表的字段和java中的类属性建立映射关系，每次操作由orm自动提供相互的赋值动作

mybatis是一个轻量级的提供半自动化SQL语句的持久层框架，对JDBC进行封装
```

### mybatis的使用

> mybatis的官方网站：https://mybatis.org/mybatis-3/

1. 引入jar包

	```xml
	<!--mybatis的核心包-->
	<dependency>
	    <groupId>org.mybatis</groupId>
	    <artifactId>mybatis</artifactId>
	    <version>3.5.1</version>
	</dependency>
	<!--mysql的驱动包-->
	<dependency>
	    <groupId>mysql</groupId>
	    <artifactId>mysql-connector-java</artifactId>
	    <version>8.0.19</version>
	</dependency>
	```

2. 创建mybatis的核心配置文件

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration
          PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
          "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <!--当前xml文件的约束  约束了当前xml文件中只能出现规定的标签-->
  <!--根标签-->
  <configuration>
  <!--    1.读取配置文件-->
  <!--    <properties></properties>-->
  <!--    2.设置全局配置-->
      <settings>
          <!-- 打印sql日志   控制台中打印sql-->
          <setting name="logImpl" value="STDOUT_LOGGING" />
      </settings>
  <!--    3.数据源信息-->
      <environments default="connMysql">
  <!--        配置多组数据源
              id:这组数据源的唯一标识
  -->
          <environment id="connMysql">
  <!--            事务管理器-->
              <transactionManager type="JDBC"></transactionManager>
  <!--            数据源信息
                  type：数据库的连接类型   POOLED数据库连接池
  -->
              <dataSource type="POOLED">
  <!--            提供连接数据库的四大参数-->
                  <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                  <property name="url" value="jdbc:mysql://localhost:3306/dljd1?serverTimezone=UTC"/>
                  <property name="username" value="root"/>
                  <property name="password" value="root"/>
              </dataSource>
          </environment>
          <!--可以配置多个-->
          <environment id="connOracle">
              <transactionManager type=""></transactionManager>
              <dataSource type=""></dataSource>
          </environment>
      </environments>
  <!--    4.mapper    写sql语句的地方-->
  <!--    我们会把sql语句写在xml文件中    由mybatis的主配置文件去读取所有的sql-->
      <mappers>
          <!--        sql配置文件路径-->
          <mapper resource="mapper/AdminMapper.xml" />
      </mappers>
  </configuration>
  ```

3. mapper.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper
          PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
          "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <!--根标签    namespace是当前sql文件的唯一标识-->
  <!--mapper的细节    所有的sql语句不需要写;-->
  <mapper namespace="adminDao">
      <!--    id:这个添加语句的唯一标识    相当于之前在dao里面写的方法名
              parameterType:参数类型    当前这个sql语句需要有参数拼接
              一个参数：直接写参数类型    java.lang.String
              多个参数：传递对象
      -->
      <!--    mybatis封装的PreparedStatement和Statement
              #{} ==》代表?占位符表示要预编译的对象
              ${} ==》简单的字符串替换		拼接单个参数的时候  变量名只能是value
      -->
      <insert id="addAdmin" parameterType="com.bjpn.bean.Admin">
          insert
          lols(name,money) values(
          #{name},
          #{money}
          )
      </insert>
      <select id="findAdmin" resultType="com.bjpn.bean.Admin">
          select id, name, money from lols
      </select>
      <select id="findAllAdmin" resultType="com.bjpn.bean.Admin">
          select *
          from lols
      </select>
      <delete id="delAdmin">
          delete from lols where money > 5
      </delete>
      <update id="updateAdmin" parameterType="com.bjpn.bean.Admin">
          update lols set money = #{money} where name = '库里'
      </update>
  </mapper>
  ```

4. mybatis的运行![mybatis的运行流程](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/mybatis%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png)

	**详细过程：**![mybatis运行详细过程](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/mybatis%E8%BF%90%E8%A1%8C%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.png)

	```
	每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。
	```

	```java
	//        1.读取主配置文件     加载连接信息和mapper.xml
	InputStream is = Resources.getResourceAsStream("mybatis.xml");
	//        2.生成sqlSessionFactory   这是sqlSession工厂
	SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
	//        3.获取sqlSession
	SqlSession sqlSession = sqlSessionFactory.openSession();
	//        4.使用sqlSession执行要操作的sql语句     String:需要操作的方法      Object：这个方法是否需要传参
	//        5.关闭sqlSession
	```

### 动态代理

动态代理：代理类对象在程序运行时由 JVM 根据反射机制动态生成的。动态代理不需要定义代理类的.java 源文件。 **在编译阶段不存在，运行时才动态生成的代理称为动态代理**

动态代理的实现方式常用的有两种：使用 JDK 代理代理，与通过 CGLIB 动态代理

### 基于Mapper映射开发

+ **原理：**持久层采用接口开发，没有实现类，采用代理方式创建接口的实现类
+ **要求规范：**
	+ mapper.xml映射文件名要和mapper接口名要一致
	+ namespace必须是mapper接口全路径名
	+ sql标签中的id号必须和mapper中对应方法的名字要一致
	+ sql标签中的parameterType必须和mapper中对应方法的参数类型要一致(不写paramerType，由接口默认提供  只能接收单个值或对象)
	+ sql标签中的resultType必须和mapper中对应方法的返回值类型要一致

![Mapper对应规则](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/Mapper%E5%AF%B9%E5%BA%94%E8%A7%84%E5%88%99.png)

1. 提供mapper的接口
2. 针对mapper接口的.xml文件
3. 动态代理的实现
4. 扫描主程序的资源文件

### mybatis的参数信息

#### parameterType

> 接口中方法参数的类型， 类型的完全限定名或别名

#### myBatis传递参数

1. 传递一个参数

2. 传递多个参数

	```
	@Param
	```

3. 传递多个参数使用对象

4. 传递多个参数使用 Map

#### mybatis返回值

+ 字段名和属性名不一致，对更新操作没有影响

+ 字段名和属性名不一致 ，对查询操作有两种解决办法

1. 别名

2. 手动关系映射 resultMap

	```xml
	<!-- mybatis 提供orm手动关系映射  resultMap
	        id:唯一标示  是名字
	        type:java的映射实体类
	    -->
	<resultMap id="stuResultMap" type="com.bjpn.bean.Student">
	        <!-- id:主键
	            column：数据库字段   property：java实体类对应的属性
	        -->
	        <id column="stu_id" property="stuId" javaType="int"/>
	        <result column="stu_name" property="stuName" javaType="java.lang.String"/>
	        <result column="stu_sex" property="stuSex"/>
	        <result column="stu_phone" property="stuPhone"/>
	    </resultMap>
	```

### 动态sql

#### mapper.xml的包名配置

```xml
<mappers>
    <!--配置mapper.xml所在的包名  会自动扫描包下所有的 mapper文件-->
    <package name="com.bjpn.dao"/>
</mappers>
```

#### sql片段

```
在 mapper 的动态 SQL 中若出现大于号（>）、小于号（<）、大于等于号（>=），小于等于号（<=）等符号，最好将其转换为实体符号。否则，XML 可能会出现解析出错问题。特别是对于小于号（<），在 XML 中是绝不能出现的。否则解析 mapper 文件会出错。 
```

```xml
<sql id="baseColumn">
        goods_id,goods_name,goods_price,goods_img,type_id
</sql>
<insert id="addGoods" parameterType="com.bjpn.bean.Goods">
    insert into goods (
	<include refid="baseColumn"/>
    ) values(null,#{goodsName},#{goodsPrice},#{goodsImg},#{typeId})
</insert>
```

#### if和set

```xml
 <if test="id !=null">
    id=#{id},
</if>
```

```
<!--set标签的作用:1  会自动去掉最后一个参数的，
    2  给sql语句拼接set关键字
-->
```

```xml
<!--set标签的作用:1  会自动去掉最后一个参数的，
    2  给sql语句拼接set关键字--> 
<set>
    <if test="goodsName != null">
        goods_name=#{goodsName},
    </if>
    <if test="typeId != 0">
        type_id=#{typeId},
    </if>
</set>
```

#### where

```xml
<!--    1 自动拼装where 关键字
        2 自动去掉第一个条件的and-->
<select id="getByActivity" parameterType="com.bjpn.bean.Goods" resultMap="goodsResultMap">
    select *  from  goods
    <where>
        <if test="goodsName != null">
         	and goods_name = #{goodsName}
        </if>
        <if test="typeId != 0">
            and type_id =#{typeId}
        </if>
    </where>
</select>
```

#### trim

> 所有场合均能使用，**既能去除逗号,又能去除and**

| 属性            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| prefix          | 给sql语句拼接的前缀                                          |
| suffix          | 给sql语句拼接的后缀                                          |
| prefixOverrides | 去除sql语句前面的关键字或者字符，该关键字或者字符由prefixOverrides属性指定，假设该属性指定为"AND"，当sql语句的开头为"AND"，trim标签将会去除该"AND" |
| suffixOverrides | 去除sql语句后面的关键字或者字符，该关键字或者字符由suffixOverrides属性指定 |

#### foreach

```xml
<!--
    collection:指参数类型
        集合:list、map
        数组:array
参数类型需要是List 如果接口中使用了 @Param(“pay”) 来指定参数名称，则Mapper文件中使用时collection属性就不能使用 list，必须要使用指定的名称"pay"
    item:每次的中间变量
    separator:中间的分隔符
    open:前缀
    close:后缀
-->
<select id="getByList" parameterType="java.util.List" resultMap="goodsResultMap">
    select *  from  goods  where goods_id in
        <foreach collection="list" open="(" close=")" item="goodsId" separator=",">
            #{goodsId}
        </foreach>
</select>
```

## SpringMVC

> 从控制器的历史发展来看，第一代控制器是Servlet，第二代是Struts（同期还有WebWork），第三代是Struts2(Struts+WebWork合并而来)，第四代是SpringMVC。业务层框架，可以理解为是对servlet的封装。SpringMVC是Spring框架的一部分,Spring3.0以后提出的技术

### SpringMVC基础

#### SpringMVC的执行流程

![SpringMVC的执行流程](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png)

**面试**

```
1. 用户发送请求到前端控制器（DispatcherServlet）。
2. 前端控制器请求处理器映射器（HandlerMapping）去查找处理器（Handler）。
3. 找到以后处理器映射器（HandlerMappering）向前端控制器返回执行链（HandlerExecutionChain）。
4. 前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler）。
5. 处理器适配器去执行Handler。
6. 处理器执行完给处理器适配器返回ModelAndView。
7. 处理器适配器向前端控制器返回ModelAndView。
8. 前端控制器请求视图解析器（ViewResolver）去进行视图解析。
9. 视图解析器向前端控制器返回View。
10. 前端控制器对视图进行渲染。
11. 前端控制器向用户响应结果。
```

#### SpringMVC基本配置

##### 1. 非注解版

+ 配置前端控制器web.xml

	```xml
	<?xml version="1.0" encoding="UTF-8"?>
	<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	         xmlns="http://xmlns.jcp.org/xml/ns/javaee"
	         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
	         id="WebApp_ID" version="4.0">
	  <!--注意web.xml的版本  SpringMVC是spring3.0之后的产物  web.xml文件的版本要高于3.0-->
	  <servlet>
	    <servlet-name>dispatcherservlet</servlet-name>
	    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	    <!--前端控制器在启动时需要识别处理器适配器、处理器映射器、处理器、视图解析器-->
	    <init-param><!--contextConfigLocation：配置文件的本地地址-->
	      <param-name>contextConfigLocation</param-name>
	      <!--classpath：文件路径-->
	      <param-value>classpath:springmvc.xml</param-value>
	    </init-param>
	    <!--第一时间启动前端控制器-->
	    <load-on-startup>1</load-on-startup>
	  </servlet>
	  <servlet-mapping>
	    <servlet-name>dispatcherservlet</servlet-name>
	    <!--请求配置的路径
	    第一种方案：/ 任何请求都要走前端控制器  html  css js  images
	    第二种方案：*.后缀  *.action  *.do  *.jsp
	    -->
	    <url-pattern>/</url-pattern>
	  </servlet-mapping>
	</web-app>
	```

+ 配置springMVC.xml

	```xml
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
	       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	       xmlns:p="http://www.springframework.org/schema/p"
	       xmlns:context="http://www.springframework.org/schema/context"
	       xmlns:mvc="http://www.springframework.org/schema/mvc"
	       xsi:schemaLocation="http://www.springframework.org/schema/beans
	  http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
	  http://www.springframework.org/schema/context
	  http://www.springframework.org/schema/context/spring-context-3.1.xsd
	  http://www.springframework.org/schema/mvc
	  http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd">
	    <!--非注解版的SpringMVC-->
	    <!--处理器映射器-->
	    <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>
	    <!--处理器适配器-->
	    <bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/>
	    <!--处理器
	    id/name:唯一标识    访问处理器的路径
	    -->
	    <bean id="/firstDemo.action" class="com.bjpn.controller.FirstController"/>
	    <!--视图解析器-->
	    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"/>
	</beans>
	```

+ 实现处理器

	```java
	public class FirstController implements Controller {
	    @Override
	    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
	        return null;
	    }
	}
	```

##### 2. 注解版

+ 配置web.xml

+ 配置springMVC.xml

	```xml
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
	       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	       xmlns:p="http://www.springframework.org/schema/p"
	       xmlns:context="http://www.springframework.org/schema/context"
	       xmlns:mvc="http://www.springframework.org/schema/mvc"
	       xsi:schemaLocation="http://www.springframework.org/schema/beans
	  http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
	  http://www.springframework.org/schema/context
	  http://www.springframework.org/schema/context/spring-context-3.1.xsd
	  http://www.springframework.org/schema/mvc
	  http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd">
	    <!--注解版的SpringMVC-->
	    <!--处理器适配器、处理器映射器、视图解析器 用驱动扫描直接加载-->
	    <mvc:annotation-driven/>
	    <!--使用注解加载处理器类  需要开启注解扫描-->
	    <context:component-scan base-package="com.bjpn.controller"/>
	</beans>
	```

+ 处理器

	```java
	/*
	    @Controller:放在类上
	    1.表示当前是处理器类
	    2.会被Spring扫描并加入spring容器
	 */
	/*
	    @RequesyMapping:请求映射
	    1.出现在类上    给当前类中的所有的处理方法提供前置路径
	    2.value:前置路径
	     */
	@Controller
	@RequestMapping("/second")
	public class SecondController {
	    //在一个处理器中可以写很多处理方法
	    /*
	    @RequesyMapping:请求映射
	    1.出现在方法上    该方法可以被请求访问
	    2.value:请求路径
	      method:请求方式   默认所有
	     */
	    @RequestMapping("/handlerMethodDemo1.action")
	    public ModelAndView handlerMethodDemo1(){
	        return null;
	    }
	}
	```

#### SpringMVC常用的注解

```
@Controller           标示该类是处理器类
@RequestMapping       映射url路径
@Resource			  J2EE的注解（作用类似@Autowired）
@ModelAttribute
@SessionAttributes 
@PathVariable         接收动态参数  参数值写在请求中
@RequestParam         配置不同名参数
@ResponseBody         异步ajax的json格式
@RequestBody          接收前端异步请求参数
```

#### SpringMVC的处理器

+ 使用ModelAndView方式
+ 使用String方式
+ 使用void方式

#### 处理器适配器的使用

+ 读取当前工程中所有对象
+ 接收请求中携带参数

##### 参数绑定

1. 使用servlet-api
2. 从适配器中接收同名参数
3. 用对象去接收参数
	+ 适配器绑定对象，传参时参数名和对象属性名一致即可
4. 传递的参数名和处理器方法的绑定参数名不一致
	+ @requestParam         配置不同名参数
5. restful风格的请求   参数在请求路径中
	+ @PathVariable         接收动态参数  参数值写在请求路径中

#### SpringMVC的乱码问题

```
tomcat6   tomcat7：get请求也会出现中文乱码
改tomcat的配置文件  8080端口处   加Encoding="utf-8"
```

```xml
tomcat8之后只有post中文乱码	SpringMVC提供了编码过滤器	在web.xml中直接配置即可
<!--解决post中文乱码问题-->
<filter>
  <filter-name>CharacterEncodingFilter</filter-name>
  <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
  <init-param>
    <param-name>encoding</param-name>
    <param-value>utf-8</param-value>
  </init-param>
  <!--这两个可以不写-->
  <!--强制开启request字符集-->
  <init-param>
    <param-name>forceRequestEncoding</param-name>
    <param-value>true</param-value>
  </init-param>
  <!--强制开启response字符集-->
  <init-param>
    <param-name>forceResponseEncoding</param-name>
    <param-value>true</param-value>
  </init-param>
</filter>
<filter-mapping>
  <filter-name>CharacterEncodingFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>
```

#### SpringMVC转发与重定向

```
SpringMVC处理器的返回，无论是ModelAndView还是String  默认调用请求转发	不写关键字默认是转发

forward:表示转发，实现 request.getRequestDispatcher("xx.jsp").forward()

redirect:表示重定向，实现 response.sendRedirect("xxx.jsp") 

转发和重定向都需要明确根路径: /
```

#### 域对象传值

+ ModelAndView对象：可以当做域对象使用，但是只能在返回类型为ModelAndView的方法中用
	+ 转发时：效果和request对象一致
	+ 重定向是：会把key-value直接拼接到重定向的请求中，作为参数传递
		重定向访问处理器时key-value拼接在请求中，多用在跳转其它处理器
+ Model对象，是ModelAndView的域对象简化写法，可以在返回值为String的方法中用
	+ 重定向时会把key-value拼接在请求中  多用在跳转其它处理器

#### 静态资源访问

>  静态资源主要包括：html、js、image、css等在webapp下不需要action的请求或文件。

```
前端控制器的请求方式有两种：/和*.后缀

写/的情况，因为 DispatcherServlet 会将向静态资源的获取请求，例如.css、.js、.jpg、.png 等资源的获取请求，当作是一个普通的Controller 请求。中央调度器会调用处理器映射器为其查找相应的处理器。当然也是找不到的，所以在这种情况下，所有的静态资源获取请求也均会报 404 错误。

静态资源：不需要处理器处理的
动态资源：必须被处理器处理的
```

##### 使用default Servlet处理静态文件

在web.xml当中加入以下内容：

```xml
<!-- 使用default Servlet处理以下请求 -->
<servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>/images/*</url-pattern>
    <url-pattern>*.js</url-pattern>
    <url-pattern>*.css</url-pattern>
</servlet-mapping>
```

```
原理：我们是有两个servlet的，一个叫做default，一个叫做dispatcher,当图片,js,css这几个请求进来以后，到底是哪个servlet处理这些请求呢？肯定是default，因为它的**url-pattern**更精确一些，dispatcher的**url-pattern**是/更抽象一些，精确的规则是要优先到抽象规则的。

所以我们会看到控制台日志空空如也。它根本没有走SpringMVC。

这种配置的优点在于效率很高，直接把请求从SpringMVC手中抢夺走了（完全不走SpringMVC的那11个执行流程）。

缺点是不同的Web容器不通用，default这个servlet是tomcat自带的，它是在apache-tomcat-9.0.30\conf\web.xml当中进行注册的，只是没有mapping而已，如果更换了Web容器的话，这个default Servlet也需要更换，例如在WebLogic下面这个Servlet被叫做FileServlet。
```

##### 在SpringMVC中配置静态资源的路径

在SpringMVC的核心配置文件中

```xml
<!-- 以下路径不会被当控制器拦截，当静态资源处理 -->
<mvc:resources mapping="/images/*" location="/images/" />
<mvc:resources mapping="/css/*" location="/css/" />
<mvc:resources mapping="/js/*" location="/js/" />
```

##### SpringMVC交还default Servlet处理

在SpringMVC的核心配置文件中

```xml
<!-- 由springmvc对请求进行分类，如果是静态资源，则交给DefaultServlet处理 -->
<mvc:default-servlet-handler/>
```

```
声明了<mvc:default-servlet-handler/>后，springmvc框架会在容器中创建

DefaultServletHttpRequestHandler处理器对象。它会像一个检查员，对进入DispatcherServlet的URL进行筛查，如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的

Servlet 处理。一般的服务器都有默认的 Servlet。 在 Tomcat 中，有一个专门用于处理静态资源访问的 Servlet 名叫 DefaultServlet。其<servlet-name/>为 default。可以处理各种静态资源访问请求。该 Servlet 注册在 Tomcat 服务器的 web.xml 中。在 Tomcat 安装目录/conf/web.xml。

在没有特殊要求的情况下，SpringMVC 的中央调度器 DispatcherServlet 的<url-pattern/> 常使用后辍匹配方式，如写为*.do 或者 *.action, *.mvc 等。 
```

### SpringMVC核心

#### 使用jackson来处理json数据

```xml
<!--导入jackson-->
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-core</artifactId>
  <version>2.9.0</version>
</dependency>
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.9.0</version>
</dependency>
```

```
@RequestBody	接受json数据
@ResponseBody	返回json数据	必须符合key-value这种形式的返回值：java对象、集合
@RestController    相当于@Controller和@ResponseBody合在一起的作用	如果使用@RestController注解Controller层的话，则返回的是return里面的内容，无法返回到指定的页面
```

#### 配置前置后置路径

避免地址栏发起对页面的直接请求，把页面放在WEB-INF下  WEB-INF不接受直接请求  需要使用处理器转发过来

```xml
<!--配置视图解析器-->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!--在视图解析器中配置前缀和后缀  所有访问页面的代码可以自动拼装-->
        <!--前缀-->
        <property name="prefix" value="/WEB-INF/"/>
        <!--后缀-->
        <property name="suffix" value=".jsp"/>
    </bean>
```

```xml
<mvc:view-resolvers>
        <mvc:jsp view-class="org.springframework.web.servlet.view.InternalResourceView"/>
        <mvc:jsp prefix="/WEB-INF/pages/"/>
        <mvc:jsp suffix=".jsp"/>
</mvc:view-resolvers>
```

#### 文件上传

+ post请求
+ 在要上传的form标签中添加enctype="multipart/form-data"属性
+ 接收参数名和input标签的name属性一致

```xml
<!--导入commons-fileupload   commons-io-->
<dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>1.3.1</version>
</dependency>
```

```xml
<!-- 配置文件上传解析器 id:必须是multipartResolver-->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <property name="maxUploadSize" value="#{1024*1024*80}"/>
    <property name="defaultEncoding" value="utf-8"/>
</bean>
```

**上传路径：**

1. 利用webapp路径![webapp路径](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/webapp%E8%B7%AF%E5%BE%84.png)

	```java
	//我们要把文件上传在 web下的fileUpload文件夹中
	// 不能直接写磁盘路径   项目在服务器中部署   服务器会部署我们的项目
	//随着服务器的改变  我们的路径会发生改变
	//通过服务器的部署路径  去访问web下的内容
	String  path = request.getServletContext().getRealPath("/fileUpload");
	System.out.println("真实路径:"+path);
	```

2. 配置虚拟路径![虚拟路径](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/虚拟路径.png)

![](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/%E8%99%9A%E6%8B%9F%E8%B7%AF%E5%BE%842.png)

#### 拦截器

SpringMVC 中的 Interceptor 拦截器是非常重要和相当有用的，它的主要作用是拦截指定的用户请求，并进行相应的预处理与后处理。其拦截的时间点在“处理器映射器根据用户提 交的请求映射出了所要执行的处理器类，并且也找到了要执行该处理器类的处理器适配器， 在处理器适配器执行处理器之前”。当然，在处理器映射器映射出所要执行的处理器类时， 已经将拦截器与处理器组合为了一个处理器执行链，并返回给了中央调度器。 

SpringMVC的拦截器(Interceptor)跟Servlet的Filter用法上是差不多的，区别在于Filter的拦截范围更大，可拦截任意地址。SpringMVC的拦截器能拦截的只是已经进入到SpringMVC的请求。

```xml
 <!-- 拦截器配置 -->
    <mvc:interceptors>
        <!-- 多个拦截器将顺序执行 -->
        <mvc:interceptor>
            <mvc:mapping path="/**"/> <!-- 拦截路径  **代表着多层路径 -->
            <mvc:exclude-mapping path="/loginAndReg/*"/><!-- 不拦截路径 -->
            <bean class="com.bjpn.interceptor.LoginInterceptor"></bean>
        </mvc:interceptor>
    </mvc:interceptors>
```

+ **preHandle(request,response, Object handler)**

	```markdown
	该方法在处理器方法执行之前执行。其返回值为 boolean，若为 true，则紧接着会执行处理器方法，且会将 afterCompletion()方法放入到一个专门的方法栈中等待执行。
	```

+ **postHandle(request,response, Object handler,modelAndView)**

	```
	该方法在处理器方法执行之后执行。处理器方法若最终未被执行，则该方法不会执行。 
	由于该方法是在处理器方法执行完后执行，且该方法参数中包含 ModelAndView，所以该方法可以修改处理器方法的处理结果数据，且可以修改跳转方向。
	```

+ **afterCompletion(request,response, Object handler, Exception ex)**

	```
	当 preHandle()方法返回 true 时，会将该方法放到专门的方法栈中，等到对请求进行响应的所有 工作完成之后才执行该方法。即该方法是在中央调度器渲染（数据填充）了响应页面之后执行的，此时对 ModelAndView 再操作也对响应无济于事。 
	```

	**afterCompletion最后执行的方法，关闭资源**

## Spring

> Spring 的核心是控制反转（IoC：Inverse of Control）和面向切面编程（AOP：Aspect Oriented Programming）

内部实现机制：框架写了自己的工厂类，读用户的配置文件，然后反射出配置文件中配置的各种对象

### 主要作用

```
Spring的主要作用就是为代码“解耦”，降低代码间的耦合度。就是让对象和对象（模块和模块）之间关系不是使用代码关联，而是通过配置来说明。即在Spring中说明对象（模块）的关系。 

Spring根据代码的功能特点，使用 Ioc 降低业务对象之间耦合度。IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring容器统一管理，自动“注入”,注入即赋值。 而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成“织入”。 
```

### Spring的优点

```
Spring 是一个框架，是一个半成品的软件。有 20 个模块组成。它是一个容器管理对象，容器是装东西的，Spring 容器不装文本，数字。装的是对象。Spring 是存储对象的容器。
```

1. **轻量**

	```
	Spring 框架使用的 jar 都比较小，一般在 1M 以下或者几百 kb。Spring 核心功能的所需的 jar 总共在 3M 左右。 
	Spring 框架运行占用的资源少，运行效率高。不依赖其他 jar 
	```

2. **针对接口编程，解耦合** 

	```
	Spring 提供了 Ioc 控制反转，由容器管理对象，对象的依赖关系。原来在程序代码中的对象创建方式，现在由容器完成。对象之间的依赖解耦合。 
	
	Spring 是于 2003 年兴起的一个轻量级的 Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。Spring 的核心是控制反转（IoC）和面向切面编程（AOP）。Spring 是可以在 Java SE/EE 中使用的轻量级开源框架。
	```

3. **AOP编程的支持** 

	```
	通过 Spring 提供的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松应付 在 Spring 中，开发人员可以从繁杂的事务管理代码中解脱出来，通过声明式方式灵活地 进行事务的管理，提高开发效率和质量。 
	```

4. **方便集成各种优秀框架** 

	```
	Spring 不排斥各种优秀的开源框架，相反 Spring 可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如 Struts,Hibernate、MyBatis）等的直接支持。简化框架的使用。Spring 像插线板一样，其他框架是插头，可以容易的组合到一起。需要使用哪个框架，就把这个插头放入插线板。不需要可以轻易的移除
	```

### Spring体系结构

![Spring体系结构](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/Spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)

Spring 由 20 多个模块组成，它们可以分为数据访问/集成（Data Access/Integration）、 Web、面向切面编程（AOP, Aspects）、提供JVM的代理（Instrumentation）、消息发送（Messaging）、 核心容器（Core Container）和测试（Test）。

### Spring的核心：IOC

```
控制反转（IoC，Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。通过容器实现对象的创建，属性赋值，依赖的管理。 
```

```
IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式是依赖注入
```

#### 什么是控制反转：

```
以前我们主动new对象,控制权在我们自己手中Spring提供对象管理容器,创建对象的过程由Spring完成,我们没有权利创建对象了我们把创建的对象的权利交给了Spring容器，这个过程叫做控制反转
```

#### 控制反转的作用

```
解除代码间的耦合
```

**Spring.xml的头文件**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans-4.1.xsd">
    <!--beans  就是对象容器-->
</beans>
```

**Spring.xml文件中配置**

```xml
 <!--配置要被容器管理的类
        user类交给了Spring容器   在这个容器中的唯一名称名字:u
        id:唯一标示
    -->
    <bean id="u" class="com.bjpn.bean.User"/>
```

**从Spring容器中获取对象**

```java
 //从Spring容器中获取对象
//首先需要获取Spring容器   被容器管理的对象 可以从容器中获取
ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext("Spring.xml");
//我需要容器中  id= u的对象   容器会帮我们创建对象
Object obj = ioc.getBean("u");
User user = (User)obj;
System.out.println(user);
```

**Spring容器创建对象的方式：默认调用无参构造创建对象**

+ 调用有参构造

	```xml
	<bean id="user" class="com.bjpn.bean.User">
	    <!--如果只有有参构造  需要告诉容器创建对象的属性值-->
	    <constructor-arg name="id" value="1001"/>
	    <constructor-arg name="name" value="亚索"/>
	</bean>
	```

+ 调用set方法

	```xml
	<!--  通过set方法-->
	<bean id="user" class="com.bjpn.bean.User">
	    <property name="id" value="1002"/>
	    <property name="name" value="锐雯"/>
	</bean>
	```

#### Spring的两种加载方式

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml");
```

ClassPathXmlApplicationContext 默认会去 classPath 路径下找。classPath 路径指的就是编译后的 classes 目录。

```java
FileSystemXmlApplicationContext applicationContext = new FileSystemXmlApplicationContext("classpath:spring-config.xml");
```

FileSystemXmlApplicationContext 默认是去项目的路径下加载，可以是相对路径，也可以是绝对路径，若是绝对路径，“file:” 前缀可以缺省。

#### 从IOC容器获取Bean的两种常用方式

```java
UserController userController = (UserController)applicationContext.getBean("userController");
```

```java
UserController userController = applicationContext.getBean(UserController.class);
```

#### DI	依赖注入（Dependency Injection）

依赖：classA 中含有 classB 的实例，在 classA 中调用 classB 的方法完成功能，即 classA 对 classB 有依赖。 

```
依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。
Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持对象之间依赖关系的管理。 
```

```xml
<!--依赖注入	容器需要管理两个类-->
<bean id="ud" class="com.bjpn.dao.UserDao" 	scope="singleton"/><!--scope默认是单例，可设置prototype为多例-->
<bean id="us" class="com.bjpn.service.UserService">
    <property name="ud"  ref="ud"/>
</bean>
```

DI：依赖注入，将对象所依赖的对象注入到对象的属性中。 就是IOC的具体实现方法。

1. IOC就是一个容器
2. IOC容器中包括spring管理的所有bean。
3. IOC容器负责对bean进行实例化
4. IOC容器对bean进行实例化时候，检查有哪些依赖的属性，将依赖的属性注入到实例化的bean的属性中。

#### 基于注解的DI开发

实体类的注解：每个bean注解都有name属性  不写默认是类名的驼峰式

```
@controller:当前类为处理器类
@Service:当前类为业务层
@Repository:当前类为持久层
@Component :普通类

依赖注入的注解：
@Autowired:可以标识在属性上，根据属性类型去spring容器中找同类型的bean，找到则将bean注入到属性中
@Qualifier:是Autowired的辅助注解  标明注入的是那个类
```

```
@Repository和@Mapper的区别：
1.@Repository 是 Spring 的注解	@Mapper是mybatis的注解	
2.使用@Mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中。
3.也可以不再每个Mapper类上加@Mapper，只在启动类上加@MapperScan(指定包名)即可
4.@repository则需要在Spring中配置扫描包地址，然后生成dao层的bean，之后被注入到ServiceImpl中
```

```
@Autowired和@Resource的区别：
1.@Autowired是Spring的，@Resource是javax包下的。
2.@Autowired默认按类型byType匹配，@Resource默认按名称byN匹配
```



### Spring的核心：AOP 

AOP（Aspect Orient Programming），面向切面编程。面向切面编程是从动态角度考虑程序运行过程。 AOP 底层，就是采用动态代理模式实现的。一个类实现了接口时，Spring默认使用JDK动态代理实现AOP，一个类没有实现接口时，Spring默认使用CGLIB实现AOP。

#### AOP编程的好处

1. 减少重复
2. **专注于业务功能增强的实现**，就是OOP编程的一个完美补充

#### AOP编程术语

1. 切面：Aspect

	```
	切面泛指交叉业务逻辑。常用的切面是通知（Advice）。实际就是对主业务逻辑的一种增强
	切面指的是辅助业务类，实际就是对主业务逻辑的一种增强管理的类
	```

2. 连接点：JoinPoint

	```
	连接点指可以被切面织入的具体方法。通常业务接口中的方法均为连接点
	```

3. 切入点：Pointcut

	```
	切入点指声明的一个或多个连接点的集合。通过切入点指定一组方法
	被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改的，不能被增强的。
	```

4. 目标对象：Target

	```
	目标对象指将要被增强的对象。即包含主业务逻辑的类的对象
	```

5. 通知：Advice

	```
	通知定义了增强代码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。切入点定义切入的位置，通知定义切入的时间
	```

6. 织入：Weaving

	```
	织入是将增强添加对目标类具体连接点上的过程。AOP像一台织布机，将目标类、增强或引介通过AOP	这台织布机天衣无缝地编织到一起
	```

#### AspectJ 对 AOP 的实现

**引入依赖**

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>5.3.19</version>
</dependency>
```

##### AspectJ 五种通知类型

1. 前置通知   @Before
2. 后置通知   @AfterReturning	返回通知, 在方法返回结果之后执行
3. 环绕通知   @Around 	环绕通知, 围绕着方法执行
4. 异常通知   @AfterThrowing	异常通知, 在方法抛出异常之后
5. 最终通知  @After

**执行顺序：**

正常情况下执行顺序：`Around start` -> `Before` -> `Around end` -> `After` -> `AfterReturning`
有异常情况下执行顺序：`Around start` -> `Before` -> `After` -> `AfterThrowing` ，有异常时，`Around end` 逻辑不会执行

##### AspectJ 的切入点表达式

```
execution(modifiers-pattern? ret-type-pattern 
          declaring-type-pattern?name-pattern(param-pattern)
          throws-pattern?)

modifiers-pattern 访问权限类型 

ret-type-pattern 返回值类型 

declaring-type-pattern 包名类名 

name-pattern(param-pattern) 方法名(参数类型和参数个数) 

throws-pattern 抛出异常类型 

？表示可选的部分
```

**execution(访问权限 方法返回值 方法声明(参数) 异常类型) **

![execution表达式](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/execution%E8%A1%A8%E8%BE%BE%E5%BC%8F.png)

```
execution(public * *(..))
指定切入点为：任意公共方法。
execution(* set*(..))
指定切入点为：任何一个以“set”开始的方法。
execution(* com.xyz.service.*.*(..))
指定切入点为：定义在 service 包里的任意类的任意方法。
execution(* com.xyz.service..*.*(..))
指定切入点为：定义在 service 包或者子包里的任意类的任意方法。“..”出现在类名中时，后面必须跟“*”，表示包、子包下的所有类。
execution(* *..service.*.*(..))
指定所有包下的 serivce 子包下所有类（接口）中所有方法为切入点
```

##### AspectJ 的 AOP 实现

```xml
<!--非注解版的aop
        1、目标类和增强类都需要被spring容器管理
        2,在目标类上设置切点
    -->
<!--让Spring通过aop调用动态代理的方式  来给目标类设置切点-->
<aop:config>
    <!--面向切面  需要指明这个切面的增强类是谁-->
    <aop:aspect ref="active">
        <!--明确切面所处的位置  通知  前置 后置 环绕  异常 最终-->
        <!--pointcut:切点
                id：这个切点的名字
                expression：切点所处的位置
                    execution:(public * *(..))切点作用在当前工程中所有类上的公开方法上
            -->
        <!--设置了一个切点  跟Q有关-->
        <aop:pointcut id="qBefer" expression="execution(* com.bjpn.aop.*.Q(..))"/>
        <!--设置通知  在Q方法之前 调用增强类中的方法 只要方法名
                调用哪个切点
            -->
        <aop:before method="sayHi" pointcut-ref="qBefer"/>
    </aop:aspect>
</aop:config>
```

```xml
<!--使用注解配置切面编程-->
<!--声明自动代理生成器，创建代理-->
<aop:aspectj-autoproxy/>
```

```
对同一个切点配置5种通知发现，这个切点表达式写了5遍，如果发生变动修改很麻烦。我们对它进行优化：
在切面类当中定义一个空方法, 后面所有的通知，引用这个空方法的切点就可以了。
```

### Spring利用aop实现事务管理

#### Spring和Mybatis的整合

+ mybatis环境
	+ mysql-connector-java
	+ mybatis
	+ 数据库连接池druid
+ Spring环境
	+ spring-context
+ Spring整合mybatis
	+ mybatis-spring
+ spring事务体系
	+ spring-jdbc
	+ spring-aspects
	+ spring-tx

```xml
<!--mybatis的配置-->
    <!--mybatis连接数据库的动作交给了spring  -->
    <!--读取连接数据库的配置文件  -->
    <!-- 读取工程下面的properties文件 -->
<!--1.读取数据源参数的配置文件-->
    <context:property-placeholder location="classpath:JDBCUtil.properties" />
<!--2.数据源   datasource-->
    <!--配置四大参数
        数据路连接池  c3p0  dbcp   druid
        Spring管理数据库连接池   以对象的方式
    -->
   <!-- <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
           destroy-method="close">
            <property name="driverClassName" value="${jdbcDriver}" />
           <property name="url" value="${jdbcUrl}" />
           <property name="username" value="${jdbcUname}" />
           <property name="password" value="${jdbcUpwd}" />

    </bean>-->
 <!-- 声明数据源DataSource, 作用是连接数据库的 druid-->
    <bean id="myDataSource" class="com.alibaba.druid.pool.DruidDataSource"
          init-method="init" destroy-method="close">
       <!-- set注入给DruidDataSource提供连接数据库信息
            使用属性配置文件中的数据，语法 ${key}
            druid:提供的数据库连接池会自动扫描当前mysql的jar
            -->
        <property name="url" value="${jdbcUrl}" />
        <property name="username" value="${jdbcUname}"/>
        <property name="password" value="${jdbcUpwd}" />
        <!--<property name="maxActive" value="${jdbc.max}" />-->
        <!--<property name="driverClassName" value="${jdbcDriver}"/>-->
    </bean>
    <!-- sqlSessinFactory在mybatis单独使用的时候
   咱们封装了一个工具类来获取该单例，但是和spring整合之后
   完全交给spring的ioc容器来实例化该对象,j交由ioc管理sqlSessionFactory，
   只能使用mybtias-spring整合包中的类
   -->
<!--3.sqlSessionFactory工厂-->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!-- 加载mybatis的核心配置文件 -->
        <property name="configLocation" value="classpath:mybatis.xml" />
        <!-- 数据源，是SqlSessionFactoryBean的依赖对象 -->
        <property name="dataSource" ref="myDataSource"/>
        <!-- 映射文件位置 -->
        <property name="mapperLocations" value="classpath:mapper/*.xml"></property>
    </bean>
    <!--mapper.xml原来是用动态代理的方式生成，现在需要交给ioc容器管理  -->
    <!-- mybatis-spring-1.3.0.jar,提供了
    自动生成mapper代理对象的机制，
    只需要配置mapper接口的包路径
    和sqlsessionfactory
    -->
<!--4.根据工程生成的sqlSession 生成mapper扫描器     就是使用sqlSession动态代理得到的每一个mapper接口的实现类
        以前会用sqlSession的动态代理方式   自己去生成mapper接口的实现类
        Spring通过mapper扫描器，加载所有的mapper接口和mapper.xml文件
        直接借助SqlSessionFactory，生成sqlSession  动态代理生成mapper接口的实现类  直接放在spring容器中
    -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <!--mapper接口的所在的包  -->
        <property name="basePackage" value="com.bjpn.mapper"/>
        <!--得到sqlSessionFactory自动生成sqlSession  -->
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
    </bean>
<!--5.spring的配置
        mapper不需要扫描了    mapper扫描器已经扫描了所有的mapper接口和mapper.xml
        mapper接口的实现类已经在Spring容器中了
    -->
    <context:annotation-config/>
    <context:component-scan base-package="com"/>
```

#### Spring提供的事务

| **事务行为**              | **说明**                                                     |
| ------------------------- | ------------------------------------------------------------ |
| **PROPAGATION_REQUIRED**  | 支持当前事务，假设当前没有事务。就新建一个事务   最常用 增删改 |
| **PROPAGATION_SUPPORTS**  | 支持当前事务，假设当前没有事务，就以非事务方式运行  查询     |
| PROPAGATION_MANDATORY     | 支持当前事务，假设当前没有事务，就抛出异常                   |
| PROPAGATION_REQUIRES_NEW  | 新建事务，假设当前存在事务。把当前事务挂起                   |
| PROPAGATION_NOT_SUPPORTED | 以非事务方式运行操作。假设当前存在事务，就把当前事务挂起     |
| PROPAGATION_NEVER         | 以非事务方式运行，假设当前存在事务，则抛出异常               |
| PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |

PROPAGATION_REQUIRED:一定会提供事务  如果有多个操作会自动合并事务  多用于增删改

PROPAGATION_SUPPORTS:有事务就有  没有 就没有  多用于查询操作

**非注解版的事务管理**

```xml
 <!--第二种方案  使用aop  切面-->
    <!--配置事务管理器 jdk的事务管理  在spring中 引入事务管理器类-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>
<!--配置事务 在需要事务的地方设置切点   所有的service方法都需要事务  在所有的service方法上设置切点-->
<aop:config>
    <aop:pointcut expression="execution(* com.bjpn..service.*.*(..))" id="allMethodPointcut"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="allMethodPointcut"/>
</aop:config>
<!--spring根据不同的方法 或不同的增删改查操作 提供不同的事务行为-->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <tx:method name="add*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="save*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="edit*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="update*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="delete*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="remove*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="modify*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="get*" propagation="SUPPORTS" read-only="true"/>
        <tx:method name="find*" propagation="SUPPORTS" read-only="true"/>
    </tx:attributes>
</tx:advice>
```

**注解版的事务管理**

```xml
<bean id="transactionManager"
      class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="myDataSource" />
</bean>
<!-- 开启注解控制事务 -->
<tx:annotation-driven transaction-manager="transactionManager" />
```

## SSM整合

```xml
spring整合时   spring-web这个包会出现web片段会导致web的地址排序变成相对排序
会导致contextConfigLocation第一时间不读xml文件		而是去找webspring-web下的web片段不找webapp 
<!--配置web片段的绝对地址排序-->
<absolute-ordering/>
```

[ssm整合]: D:\Test\Java\03-JavaWeb\01-讲义\day35-ssm整合\ssm.md
[ssm整合2]: D:\Test\Java\03-JavaWeb\01-讲义\day35-ssm整合\ssm整合第二版.md

## mybatis的逆向工程

> 使用逆向工程插件，根据数据库表和orm思想，自动生成对应实体类、通用的mapper接口和mapper.xml

1. 引入mybatis逆向工程的插件

	```xml
	<build>
	    <plugins>
	        <!--myBatis逆向工程插件-->
	        <plugin>
	            <groupId>org.mybatis.generator</groupId>
	            <artifactId>mybatis-generator-maven-plugin</artifactId>
	            <version>1.3.2</version>
	            <configuration>
	                <verbose>true</verbose>
	                <overwrite>true</overwrite>
	            </configuration>
	        </plugin>
	    </plugins>
	</build>
	```

2. 配置逆向工程的配置文件

	generator.properties

	```xml
	jdbc.driverLocation=D:/Java/Maven_repository/mysql/mysql-connector-java/8.0.19/mysql-connector-java-8.0.19.jar
	jdbc.driverClass=com.mysql.cj.jdbc.Driver
	jdbc.connectionURL=jdbc:mysql://localhost:3306/dljd3?serverTimezone=UTC&nullCatalogMeansCurrent=true
	jdbc.userId=root
	jdbc.password=root
	```

	generatorConfig.xml

	```xml
	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE generatorConfiguration
	        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
	        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
	
	<generatorConfiguration>
	
	    <!--指定mysql数据库驱动-->
	    <!--<classPathEntry location="D:/Java/Maven_repository/mysql/mysql-connector-java/8.0.25/mysql-connector-java-8.0.25.jar"/>-->
	
	    <!--导入属性配置-->
	    <properties resource="generator.properties"></properties>
	
	    <!--指定特定数据库的jdbc驱动jar包的位置-->
	    <classPathEntry location="${jdbc.driverLocation}"/>
	
	    <context id="default" targetRuntime="MyBatis3">
	
	        <!-- optional，旨在创建class时，对注释进行控制，false生成注释,true无注释 -->
	        <commentGenerator>
	            <property name="suppressDate" value="false"/>
	            <property name="suppressAllComments" value="false"/>
	        </commentGenerator>
	
	        <!--jdbc的数据库连接 -->
	        <jdbcConnection
	                driverClass="${jdbc.driverClass}"
	                connectionURL="${jdbc.connectionURL}"
	                userId="${jdbc.userId}"
	                password="${jdbc.password}">
	        </jdbcConnection>
	
	
	        <!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制-->
	        <javaTypeResolver>
	            <property name="forceBigDecimals" value="false"/>
	        </javaTypeResolver>
	    <!--根据数据库生成      bean    mapper  mapper.xml-->
	
	        <!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类
	            targetPackage     指定生成的model生成所在的包名
	            targetProject     指定在该项目下所在的路径|指定生成到的工程名称
	        -->
	        <!--根据表中字段生成实体类-->
	        <javaModelGenerator targetPackage="com.bjpn.settings.bean"
	                            targetProject="D:/Test/JavaProjects/crm/src/main/java">
	
	            <!-- 是否允许子包，即targetPackage.schemaName.tableName -->
	            <property name="enableSubPackages" value="false"/>
	            <!-- 是否对model添加 构造函数 true添加，false不添加-->
	            <property name="constructorBased" value="false"/>
	            <!-- 是否对类CHAR类型的列的数据进行trim操作 -->
	            <property name="trimStrings" value="true"/>
	            <!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 -->
	            <property name="immutable" value="false"/>
	        </javaModelGenerator>
	        <!--生成对应的mapper.xml文件   只生成基本的增删改查-->
	        <!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 -->
	        <sqlMapGenerator targetPackage="com.bjpn.settings.mapper"
	                         targetProject="D:/Test/JavaProjects/crm/src/main/java">
	            <property name="enableSubPackages" value="false"/>
	        </sqlMapGenerator>
	
	        <!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码
	                type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象
	                type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象
	                type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口
	        -->
	        <!--对应的mapper的接口文件-->
	        <javaClientGenerator targetPackage="com.bjpn.settings.mapper"
	                             targetProject="D:/Test/JavaProjects/crm/src/main/java" type="XMLMAPPER">
	            <property name="enableSubPackages" value="true"/>
	        </javaClientGenerator>
	
	        <!--映射的数据库表-->
	        <table tableName="tbl_user" domainObjectName="User"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	
	        <!--
	        <table tableName="tbl_user" domainObjectName="User"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	
	
	        <table tableName="tbl_clue" domainObjectName="Clue"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	
	        <table tableName="tbl_clue_activity_relation" domainObjectName="ClueActivityRelation"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	
	        <table tableName="tbl_clue_remark" domainObjectName="ClueRemark"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	        -->
	        <!--
	        <table tableName="tbl_contacts" domainObjectName="Contacts"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	        <table tableName="tbl_contacts_activity_relation" domainObjectName="ContactsActivityRelation"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	        <table tableName="tbl_contacts_remark" domainObjectName="ContactsRemark"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	        -->
	        <!--
	        <table tableName="tbl_customer" domainObjectName="Customer"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	
	        <table tableName="tbl_customer_remark" domainObjectName="CustomerRemark"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	        -->
	        <!--
	                <table tableName="tbl_dictionary_type" domainObjectName="DictionaryType"
	                       enableCountByExample="false" enableUpdateByExample="false"
	                       enableDeleteByExample="false" enableSelectByExample="false"
	                       selectByExampleQueryId="false">
	                </table>
	
	
	                <table tableName="tbl_dictionary_value" domainObjectName="DictionaryValue"
	                       enableCountByExample="false" enableUpdateByExample="false"
	                       enableDeleteByExample="false" enableSelectByExample="false"
	                       selectByExampleQueryId="false">
	                </table>
	
	
	                <table tableName="tbl_marketing_activities" domainObjectName="MarketingActivities"
	                       enableCountByExample="false" enableUpdateByExample="false"
	                       enableDeleteByExample="false" enableSelectByExample="false"
	                       selectByExampleQueryId="false">
	                </table>
	
	
	                <table tableName="tbl_marketing_activities_remark" domainObjectName="MarketingActivitiesRemark"
	                       enableCountByExample="false" enableUpdateByExample="false"
	                       enableDeleteByExample="false" enableSelectByExample="false"
	                       selectByExampleQueryId="false">
	                </table>
	                 -->
	
	        <!--<table tableName="tbl_transaction" domainObjectName="Transaction"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	        <table tableName="tbl_transaction_history" domainObjectName="TransactionHistory"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>
	        <table tableName="tbl_transaction_remark" domainObjectName="TransactionRemark"
	               enableCountByExample="false" enableUpdateByExample="false"
	               enableDeleteByExample="false" enableSelectByExample="false"
	               selectByExampleQueryId="false">
	        </table>-->
	
	    </context>
	</generatorConfiguration>
	```

## Mybatis 的分页插件 pageHelper 的配置和使用

### 配置maven依赖

```xml
<!-- 添加分布插件的包pagehelper -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>5.2.0</version>
</dependency>
```

### 配置分页插件

+ 在Spring中的配置分页插件

	```xml
	<!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 -->
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
	    <property name="dataSource" ref="dataSource"/>
	    <property name="plugins">
	        <array>
	            <bean class="com.github.pagehelper.PageInterceptor">
	                <property name="properties">
	                    <!--使用下面的方式配置参数，一行配置一个 -->
	                    <value>
	                        offsetAsPageNum=true
	                        rowBoundsWithCount=true
	                        pageSizeZero=true
	                        reasonable=true
	                    </value>
	                </property>
	            </bean>
	        </array>
	    </property>
	</bean>
	<!-- #offset作为PageNum使用
	  offset-as-page-num: true
	  #RowBounds方式是否做count查询
	  row-bounds-with-count: true
	  #分页合理化，true开启，如果分页参数不合理会自动修正。默认false不启用（当该参数设置为 true 时，
	  #pageNum<=0 时会查询第一页pageNum>pages（超过总数时），会查询最后一页。默认false 时，直接根据
	  #参数进行查询。）
	  reasonable: true
	  #pageSizeZero   //当设置为true的时候，如果pagesize设置为0（或RowBounds的limit=0），就不执行分页
	-->
	```

+ 在 Mybatis 中配置分页插件（不常用）

	```xml
	<plugins>
	    <plugin interceptor="com.github.pagehelper.PageInterceptor">
	        <property name="helperDialect" value="mysql"/>
	    </plugin>
	</plugins>	
	```

### 使用 

+ serviceImpl层

	```java
	 @Resource
	    ActivityMapper activityMapper;
	    //查询所有活动    分页查询
	    @Override
	    public List<Activity> getAllActivity(int pageNum,int pageSize) {
	        //分页信息必须写在需要分页查询的上一行
	        PageHelper.startPage(pageNum, pageSize);
	        List<Activity> list = activityMapper.getAllActivity();//紧跟上一行
	        return list;
	//        return activityMapper.getAllActivity();
	    }
	```

+ controller层

	```java
	@RequestMapping("/toWorkbenchActivityIndex.action")
	    public String toWorkbenchActivityIndex(HttpServletRequest request, @RequestParam(defaultValue = "1") int pageNum) {
	        //分页查询
	        int pageSize = 10;
	        List<Activity> activityList = activityService.getAllActivity(pageNum,pageSize);
	        PageInfo pageInfo = new PageInfo(activityList);
	        request.setAttribute("pageInfo", pageInfo);
	        return "workbench/activity/index";
	    }
	```

### pageInfo的参数含义

```
pageNum：当前页   pageSize：步长   total：总条数    pages：总页数
list：查询的数据库数据
prePage：上一页页码              nextPage:下一页页码
isFristPage:是否是第一页         isLastPage:是否是最后一页
hasPreviousPage：是否有上一页    hasNextPage：是否有下一页
navigatePages导航页码数         navigatepageNums所有导航页号
navigateFirstPage导航第一页     navigateLastPage导航最后一页
firstPage第一页       lastPage最后一页
```

## Lombok

lombok给类里面的字段，自动的加上属性，构造器，ToString方法，Equals方法，编译自动生成，比较方便的一点是，你在更改字段的时候，lombok会立即发生改变以保持和你代码的一致性

```java
@Getter
@Setter
@ToString
@EqualsAndHashCode
@Data=@Getter + @Setter + @ToString + @EqualsAndHashCode + @RequiredArgsConstructor //常用注解
@AllArgsConstructor //全参数构造器
@NoArgsConstructor //无参数构造器
@TableName("表名") //能够和底层的数据库表明进行对应
@RequiredArgsConstructor //只包含final和@NonNull注解的成员变量的私有构造器
@NonNull //用在类的属性上，限定属性不能为空，否则抛出空指针异常
@Value = @Getter + @ToString + @EqualsAndHashCode + @RequiredArgsConstructor
```

## Git

### 安装完成后进行配置

```nginx
指定用户信息设置
$ git config  user.name "Your Name"
$ git config  user.email "email@example.com"
```

```nginx
全局用户信息设置
$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"
<!--上述配置是为了标识自己，让其他人知道是谁提交的代码，git规定用名字和邮箱来标识-->
```

### 本地仓库

+ `git init `初始化版本库：当前目录变成Git可以管理的仓库

+ `git add`告诉Git，把文件添加到**暂存区**

	```nginx
	$ git add readme.md
	```

+ `git commit`告诉Git，把文件提交到**仓库**,`-m`后面输入的是本次提交的说明，最好写的内容和本次提交有关系

	```nginx
	$ git commit -m "first commit"
	```

+ `git status`：查看仓库当前的状态

+ `git diff`：查看差异.即修改后未添加和已添加的区别

	```nginx
	$ git diff hello.txt
	```

+ `git reflog`：用来查看你每次的操作历史记录，即使误操作,也可以恢复你想要的版本

### 远程仓库

+ `git remote`: 将本地仓库和远程仓库链接起来 origin是远程仓库的名称，git的默认，可以理解为给远程仓库起了个别名

	```nginx
	git remote add origin https://gitee.com/mszlu/ms-git.git
	```

+ `git push`：将本地仓库的内容变更 提交到远程仓库 origin就代表远程仓库，master代表分支 ,第一次提交需要加上`-u`参数，git会将本地仓库的master分支和远程仓库的master分支做一个关联

	```
	git push -u origin "master"
	```

### 版本回退

`git log`：查看历史的提交日志（--pretty =oneline）

`git reset`：git reset 命令用于回退版本，可以指定退回某一次提交的版本

**reset** 有三个参数：

1. **--mixed**

	默认，可以不用带该参数，用于重置暂存区的文件与指定的回退的版本的提交(commit)保持一致，工作区文件内容保持不变。

	示例：

	```bash
	git reset HEAD^
	```

2. **--soft**

	参数用于回退到某个版本，暂存区不会重置，工作区也不会改，版本回退（git log 版本截止到回退的版本）

	示例：

	```bash
	git reset --soft HEAD~3
	```

3. **--hard**

	参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到指定的回退版本，并删除之前的所有信息提交

	示例：

	```bash
	git reset --hard origin/master    # 将本地的状态回退到和远程的一样 
	```

	**注意：**谨慎使用 --hard 参数，它会删除回退点之前的所有信息，一定要在使用--hard之前 先把本地的代码提交到远程仓库

### 克隆

`git clone 远程仓库地址`： 从远程仓库拉取最新的代码到本地

### 分支的创建和合并

+ **创建`dev`分支，然后切换到`dev`分支**

	```nginx
	$ git checkout -b dev
	或者
	$ git branch dev
	$ git switch dev/$ git checkout dev
	或者
	$ git switch -c dev
	```

+ **查看当前分支**

	```nginx
	$ git branch
	```

+ **分支合并**

	```nginx
	$ git merge dev
	```

+ **删除分支**

	```nginx
	$ git branch -d dev
	强制删除使用-D
	```

## GitHub

s聚焦到搜索框

t搜索仓库内文件

l跳转导某行

b查看文件改动记录

ctrl+k命令面板

代码在vscode打开 仓库页按。

项目地址前加上gitpod.io/#/

# 高级框架

## Redis

+ redis-benchmark：性能测试工具
+ redis-check-aof：修复有问题的AOF文件
+ redis-check-dump：修复有问题的dump.rdb文件
+ redis-wentinel：redis集群使用
+ redis-server：redis服务器启动命令
+ redis-cil：客户端，操作入口

### Redis基本操作命令

| 语法               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| ping               | 沟通命令，查看状态                                           |
| dbsize             | 查看当前数据库中key的数目                                    |
| select db          | 切换数据库                                                   |
| flushdb            | 删除当前数据库数据                                           |
| exit或quit         | 退出当前redis连接                                            |
| keys pattern       | 查找所有符合模式 pattern 的 key 可以使用通配符（*代表多个字符，？代表一个字符） |
| exists key [key…]  | 判断key是否存在                                              |
| expire key seconds | 设置 key 的生存时间，超过时间，key 自动删除。单位是秒        |
| ttl key            | 以秒为单位，返回 key 的剩余生存时间（ttl: time to live）返回值（-1表示key永不过期，-2表示key不存在） |
| type key           | 查看 key 所存储值的数据类型返回值                            |
| del key [key…]     | 删除存在的 key ，不存在的 key 忽略                           |

### Redis的五种数据类型

+ **字符串类型string**

	```
	--等同于java中String
	字符串类型是 Redis 中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据，序列化后的数据，JSON 化的对象甚至是一张图片。最大 512M
	```

	| 语法                        | 说明                                                         |
	| --------------------------- | ------------------------------------------------------------ |
	| set key value               | 将字符串值 value 设置到 key 中                               |
	| get key                     | 获取 key 中设置的字符串值                                    |
	| incr key                    | 将 key 中储存的数字值加 1，如果 key 不存在，则 key 的值先被初始化为 0 再执行 incr 操作（只能对数字类型的字符串数据操作） |
	| decr key                    | 将 key 中储存的数字值减1，如果 key 不存在，则么 key 的值先被初始化为 0 再执行 decr 操作（只能对数字类型的字符串数据操作） |
	| append key value            | 如果 key 存在， 则将 value 追加到 key 原来旧值的末尾，如果key 不存在， 则将 key 设置值为 value |
	| strlen key                  | 返回 key 所储存的字符串值的长度返回值                        |
	| getrange key start end      | 获取 key 中字符串值从 start 开始 到 end 结束 的子字符串,包括 start 和 end, 负数表示从字符串的末尾开始， -1 表示最后一个字符 |
	| setrange key offset value   | 用 value 覆盖（替换）key 的存储的值从 offset 开始,不存在的 key 做空白字符串 |
	| mset key value [key value…] | 同时设置一个或多个 key-value 对返回值                        |
	| mget key [key …]            | 获取所有(一个或多个)给定 key 的值返回值：包含所有 key 的列表 |

+ **哈希类型hash**

	```
	-–等同于java对象
	Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象 
	```

	| 语法                                 | 说明                                                         |
	| ------------------------------------ | ------------------------------------------------------------ |
	| hset hash 表的 key field value       | 将哈希表 key 中的域 field 的值设为 value ，如果 key 不存在，则新建 hash 表，执行赋值，如果有 field ,则覆盖值 |
	| hget key field                       | 获取哈希表 key 中给定域 field 的值                           |
	| hmset key field value [field value…] | 同时将多个 field-value (域-值)设置到哈希表 key 中，此命令会覆盖已经存在的 field， hash 表 key 不存在，创建空的 hash 表，执行 hmset |
	| hmget key field [field…]             | 获取哈希表 key 中一个或多个给定域的值                        |
	| hgetall key                          | 获取哈希表 key 中所有的域和值                                |
	| hdel key field [field…]              | 删除哈希表 key 中的一个或多个指定域 field，不存在 field 直接忽略 |
	| hkeys key                            | 查看哈希表 key 中的所有 field 域                             |
	| hvals key                            | 返回哈希表 中所有域的值                                      |
	| hexists key field                    | 查看哈希表 key 中，给定域 field 是否存在                     |

+ **列表类型list**

	```
	--java list array
	Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 
	```

	| 语法                                  | 说明                                                         |
	| ------------------------------------- | ------------------------------------------------------------ |
	| lpush key value [value…]              | 将一个或多个值 value 插入到列表 key 的表头（最左边），从左边开始加入值，从左到右的顺序依次插入到表头 |
	| rpush key value [value…]              | 将一个或多个值 value 插入到列表 key 的表尾（最右边），各个 value 值按从左到右的顺序依次插入到表尾 |
	| lrange key start stop                 | 获取列表 key 中指定区间内的元素，0 表示列表的第一个元素，以 1 表示列表的第二个元素；start , stop 是列表的下标值，也可以负数的下标， -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 start ，stop 超出列表的范围不会出现错误 |
	| lindex key index                      | 获取列表 key 中下标为指定 index 的元素，列表元素不删除，只是查询。0 表示列表的第一个元素，以 1 表示列表的第二个元素；start , stop 是列表的下标值，也可以负数的下标， -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推 |
	| llen key                              | 获取列表 key 的长度                                          |
	| lrem key count value                  | 根据参数 count 的值，移除列表中与参数 value 相等的元素， count >0 ，从列表的左侧向右开始移除； count < 0 从列表的尾部开始移除；count = 0 移除表中所有与 value 相等的值 |
	| lset key index value                  | 将列表 key 下标为 index 的元素的值设置为 value               |
	| linsert key BEFORE\|AFTER pivot value | 将值 value 插入到列表 key 当中位于值 pivot 之前或之后的位置。key 不存在，pivot 不在列表中，不执行任何操作 |

+ **集合类型 set**

	```
	--hashset
	Redis 的 Set 是 string 类型的无序集合，集合成员是唯一的，即集合中不能出现重复的数据
	```

	| 语法                      | 说明                                                         |
	| ------------------------- | ------------------------------------------------------------ |
	| sadd key member [member…] | 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略，不会再加入 |
	| smembers key              | 获取集合 key 中的所有成员元素，不存在的 key 视为空集合       |
	| sismember key member      | 判断 member 元素是否是集合 key 的成员                        |
	| scard key                 | 获取集合里面的元素个数                                       |
	| srem key member [member…] | 删除集合 key 中的一个或多个 member 元素，不存在的元素被忽略  |
	| srandmember key [count]   | 只提供 key，随机返回集合中一个元素，元素不删除，依然在集合中；提供了 count 时，count 正数, 返回包含 count 个数元素的集合， 集合元素各不相同。count 是负数，返回一个 count 绝对值的长度的集合， 集合中元素可能会重复多次 |
	| spop key [count]          | 随机从集合中删除一个元素, count 是删除的元素个数             |

+ **有序集合类型 zset**

	```
	--treeset
	Redis 有序集合 zset 和集合 set 一样也是 string 类型元素的集合，且不允许重复的成员。不同的是 zset 的每个元素都会关联一个分数（分数可以重复），redis 通过分数来为集合中的成员进行从小到大的排序
	```

	| 语法                                                         | 说明                                                         |
	| ------------------------------------------------------------ | ------------------------------------------------------------ |
	| zadd key score member [score member…]                        | 将一个或多个 member 元素及其 score 值加入到有序集合 key 中，如果 member 存在集合中，则更新值；score 可以是整数或浮点数 |
	| zrange key start stop [WITHSCORES]                           | 查询有序集合，指定区间的内的元素。集合成员按 score 值从小到大来排序。 start， stop 都是从 0 开始。0 是第一个元素，1 是第二个元素，依次类推。以 -1 表示最后一个成员，-2 表示倒数第二个成员。WITHSCORES 选项让 score 和 value 一同返回 |
	| zrevrange key start stop [WITHSCORES]                        | 返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小) 来排列。其它同 zrange 命令 |
	| zrem key member [member…]                                    | 删除有序集合 key 中的一个或多个成员，不存在的成员被忽略      |
	| zcard key                                                    | 获取有序集 key 的元素成员的个数                              |
	| zrangebyscore key min max [WITHSCORES ] [LIMIT offset count] | 获取有序集 key 中，所有 score 值介于 min 和 max 之间（包括 min 和 max）的成员，有序成员是按递增（从小到大）排序 |
	| zrevrangebyscore key max min [WITHSCORES ] [LIMIT offset count] | 返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。其他同 zrangebyscore |
	| zcount key min max                                           | 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max ) 的成员的数量 |

### Redis事务

| 语法                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| multi               | 标记一个事务的开始。事务内的多条命令会按照先后顺序被放进一个队列当中 |
| exec                | 执行所有事务块内的命令                                       |
| discard             | 取消事务，放弃执行事务块内的所有命令                         |
| watch key [key ...] | 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断 |
| unwatch             | 取消**WATCH**命令对所有 key 的监视。如果在执行**WATCH**命令之后，**EXEC**命令或**DISCARD**命令先被执行了的话，那么就不需要再执行**UNWATCH**了 |

### Redis的持久化

#### RDB

> Redis Database（RDB），就是在指定的时间间隔内将内存中的数据集快照写入磁盘，数据恢复时将快照文件直接再读到内存

```
RDB 保存了在某个时间点的数据集（全部数据）。存储在一个二进制文件中，只有一个文件。默认是 dump.rdb。RDB 技术非常适合做备份，可以保存最近一个小时，一天，一个月的全部数据。保存数据是在单独的进程中写文件，不影响 Redis 的正常使用。RDB 恢复数据时比其他 AOF 速度快。
```

```
在配置文件 redis.conf 中搜索 SNAPSHOTTING
①：配置执行 RDB 生成快照文件的时间策略
配置格式：save  <seconds>  <changes> 
②：dbfilename：设置 RDB 的文件名，默认文件名为 dump.rdb 
③：dir：指定 RDB 文件的存储位置，默认是 ./ 当前目录
```

**优点：**

+ 由于存储的是数据快照文件，恢复数据很方便，也比较快 ，**容灾备份**

**缺点：**

+ 会丢失最后一次快照以后更改的数据。如果你的应用能容忍一定数据的丢失，那么使用 rdb 是不错的选择；如果你不能容忍一定数据的丢失，使用 rdb 就不是一个很好的选择
+ 由于需要经常操作磁盘，RDB 会分出一个子进程。如果你的 redis 数据库很大的话，子进程占用比较多的时间，并且可能会影响 Redis 暂停服务一段时间（millisecond 级别），如果你的数据库超级大并且你的服务器 CPU 比较弱，有可能是会达到一秒

#### AOF

> Append-only File（AOF），Redis 每次接收到一条改变数据的命令时，它将把该命令写到一个 AOF 文件中（只记录写操作，读操作不记录），当 Redis 重启时，它通过执行 AOF 文件中所有的命令来恢复数据  **回放**

```
①：appendonly：默认是 no，改成 yes 即开启了 aof 持久化 
②：appendfilename：指定 AOF 文件名，默认文件名为 appendonly.aof 
③：dir : 指定 RDB 和 AOF 文件存放的目录，默认是 ./  
④：appendfsync：配置向 aof 文件写命令数据的策略： 
no：不主动进行同步操作，而是完全交由操作系统来做（即每 30 秒一次），比较快但不是很安全。 
always：每次执行写入都会执行同步，慢一些但是比较安全。 
everysec：每秒执行一次同步操作，比较平衡，介于速度和安全之间。这是默认项。 
⑤：auto-aof-rewrite-min-size：允许重写的最小 AOF 文件大小，默认是 64M 。当 aof 文件大于 64M 时，开始整理 aof文件， 去掉无用的操作命令。缩小 aof文件	瘦身计划
```

**总结：**

```
1）append-only 文件是另一个可以提供完全数据保障的方案； 
2）AOF 文件会在操作过程中变得越来越大。比如，如果你做一百次加法计算，最后你只会在数据库里面得到最终的数值，但是在你的 AOF 里面会存在 100 次记录，其中 99 条记录对最终的结果是无用的；但 Redis 支持在不影响服务的前提下在后台重构 AOF 文件，让文件得以整理变小 
3）可以同时使用这两种方式，redis默认优先加载aof文件（aof数据最完整）
```

### 主从复制

#### 读写分离

> 为了避免单点故障，我们需要将数据复制多份部署在多台不同的服务器上，即使有一台服务器出现故障其他服务器依然可以继续提供服务

```
修改配置文件，启动时，服务器读取配置文件，并自动成为指定服务器的从服务器，从而构成主从复制的关系
```

##### 编辑 **Master** 配置文件

```
include /usr/local/redis-3.2.9/redis.conf 
daemonize yes 
port 6380 
pidfile /var/run/redis_6380.pid 
logfile 6380.log 
dbfilename dump6380.rdb

include ： 包含原来的配置文件内容。
/usr/local/redis-3.2.9/redis.conf 按照自己的目录设置。 
daemonize：yes 后台启动应用，相当于 ./redis-server & , &的作用。 
port : 自定义的端口号 
pidfile : 自定义的文件，表示当前程序的 pid ,进程 id。 
logfile：日志文件名 
dbfilename：持久化的 rdb 文件名
```

##### 编辑 **Slave** 配置文件

```
include /usr/local/redis-3.2.9/redis.conf 
daemonize yes 
port 6382 pidfile /var/run/redis_6382.pid
logfile 6382.log 
dbfilename dump6382.rdb 
slaveof 127.0.0.1 6380
```

#### 容灾处理

> 当 Master 服务出现故障，需手动将 slave 中的一个提升为 master， 剩下的 slave 挂至新的master 上

**总结：**

1. 一个 master 可以有多个 slave 
2. slave 下线，读请求的处理性能下降 
3. master 下线，写请求无法执行 
4. 当 master 发生故障，需手动将其中一台 slave 使用 slaveof no one 命令提升为 master，其它 slave 执行 slaveof 命令指向这个新的 master，从新的 master 处同步数据 
5. 主从复制模式的故障转移需要手动操作，要实现自动化处理，这就需要 Sentinel 哨兵，实现故障自动转移 

### sentinel哨兵

> Sentinel 哨兵是 redis 官方提供的高可用方案，可以用它来监控多个 Redis 服务实例的运行情况。Redis Sentinel 是一个运行在特殊模式下的 Redis 服务器。Redis Sentinel 是在多个 Sentinel 进程环境下互相协作工作的。

#### 主要任务

1. 监控：Sentinel 不断的检查主服务和从服务器是否按照预期正常工作。 
2. 提醒：被监控的 Redis 出现问题时，Sentinel 会通知管理员或其他应用程序。 
3. 自动故障转移：监控的主 Redis 不能正常工作，Sentinel 会开始进行故障迁移操作。将一个从服务器升级新的主服务器。 让其他从服务器挂到新的主服务器。同时向客户端提供新的主服务器地址。

![哨兵模式图解](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%9B%BE%E8%A7%A3.png)

#### 监控

1. Sentinel 会不断检查 Master 和 Slave 是否正常 
2. 如果 Sentinel 挂了，就无法监控，所以需要多个哨兵，组成 Sentinel 网络，一个健康的 Sentinel 至少有 3 个 Sentinel 应用。 彼此在独立的物理机器或虚拟机。 
3. 监控同一个 Master 的 Sentinel 会自动连接，组成一个分布式的 Sentinel 网络，互相通信并交换彼此关于被监控服务器的信息 
4. 当一个 Sentinel 认为被监控的服务器已经下线时，它会向网络中的其它 Sentinel 进行确认，判断该服务器是否真的已经下线 
5. 如果下线的服务器为主服务器，那么 Sentinel 网络将对下线主服务器进行自动故障转移，通过将下线主服务器的某个从服务器提升为新的主服务器（随机的），并让其从服务器转移到新的主服务器下，以此来让系统重新回到正常状态
6. 下线的旧主服务器重新上线，Sentinel 会让它成为从，挂到新的主服务器下 

## Dubbo

> 高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。

### 基本流程

![Dubbo工作流程](https://raw.githubusercontent.com/BlueLava127/PictureBed/master/TyporaImg/Dubbo%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

+ **服务提供者（Provider）**：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务
+ **服务消费者（Consumer）**: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用
+ **注册中心（Registry）**：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 –**如果信息有变，注册中心提供新的信息给消费者**
+ **监控中心（Monitor）**：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 –**监控服务提供者、消费者状态，与开发没有直接关系**

#### 调用流程

+ 服务容器spring负责启动，加载，运行服务提供者
+ 服务提供者在启动时，向注册中心注册自己提供的服务
+ 服务消费者在启动时，向注册中心订阅自己所需的服务
+ 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者
+ 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用
+ 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心

# Java设计模式
